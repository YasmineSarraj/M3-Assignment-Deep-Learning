Unnamed: 0,text,summary
0," Attention Is All You Need
Ashish Vaswani
Google Brain
avaswani@google.comNoam Shazeer
Google Brain
noam@google.comNiki Parmar
Google Research
nikip@google.comJakob Uszkoreit
Google Research
usz@google.com
Llion Jones
Google Research
llion@google.comAidan N. Gomezy
University of Toronto
aidan@cs.toronto.eduÅukasz Kaiser
Google Brain
lukaszkaiser@google.com
Illia Polosukhinz
illia.polosukhin@gmail.com
Abstract
The dominant sequence transduction models are based on complex recurrent or
convolutional neural networks that include an encoder and a decoder. The best
performing models also connect the encoder and decoder through an attention
mechanism. We propose a new simple network architecture, the Transformer,
based solely on attention mechanisms, dispensing with recurrence and convolutions
entirely. Experiments on two machine translation tasks show these models to
be superior in quality while being more parallelizable and requiring signiï¬cantly
less time to train. Our model achieves 28.4 BLEU on the WMT 2014 English-
to-German translation task, improving over the existing best results, including
ensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task,
our model establishes a new single-model state-of-the-art BLEU score of 41.8 after
training for 3.5 days on eight GPUs, a small fraction of the training costs of the
best models from the literature. We show that the Transformer generalizes well to
other tasks by applying it successfully to English constituency parsing both with
large and limited training data.
1 Introduction
Recurrent neural networks, long short-term memory [ 13] and gated recurrent [ 7] neural networks
in particular, have been ï¬rmly established as state of the art approaches in sequence modeling and
Equal contribution. Listing order is random. Jakob proposed replacing RNNs with self-attention and started
the effort to evaluate this idea. Ashish, with Illia, designed and implemented the ï¬rst Transformer models and
has been crucially involved in every aspect of this work. Noam proposed scaled dot-product attention, multi-head
attention and the parameter-free position representation and became the other person involved in nearly every
detail. Niki designed, implemented, tuned and evaluated countless model variants in our original codebase and
tensor2tensor. Llion also experimented with novel model variants, was responsible for our initial codebase, and
efï¬cient inference and visualizations. Lukasz and Aidan spent countless long days designing various parts of and
implementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating
our research.
yWork performed while at Google Brain.
zWork performed while at Google Research.
31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.arXiv:1706.03762v5  [cs.CL]  6 Dec 2017 transduction problems such as language modeling and machine translation [ 35,2,5]. Numerous
efforts have since continued to push the boundaries of recurrent language models and encoder-decoder
architectures [38, 24, 15].
Recurrent models typically factor computation along the symbol positions of the input and output
sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden
statesht, as a function of the previous hidden state ht"," This paper proposes the Transformer, a model architecture based on attention mechanisms that is superior in quality and requires less time to train than other models. It achieved a BLEU score of 28.4 on the WMT 2014 English-to-German translation task and a BLEU score of 41.8 on the WMT 2014 English-to-French translation task. The Transformer was also successfully applied to English constituency parsing and other tasks. The paper also discusses the attention mechanism, computational complexity, parallelization, and maximum path length of different layer types."
1," On the Beneï¬ts of Biophysical Synapses
Julian Lemmel, Radu Grosu
Faculty of Informatics of Technische Universit Â¨at Wien, Austria.
julian.lemmel@tuwien.ac.at, radu.grosu@tuwien.ac.at
Abstract
The approximation capability of ANNs and their RNN instan-
tiations, is strongly correlated with the number of parameters
packed into these networks. However, the complexity barrier
for human understanding, is arguably related to the number
of neurons and synapses in the networks, and to the associ-
ated nonlinear transformations. In this paper we show that
the use of biophysical synapses, as found in LTCs, have two
main beneï¬ts. First, they allow to pack more parameters for
a given number of neurons and synapses. Second, they allow
to formulate the nonlinear-network transformation, as a linear
system with state-dependent coefï¬cients. Both increase inter-
pretability, as for a given task, they allow to learn a system
linear in its input features, that is smaller in size compared
to the state of the art. We substantiate the above claims on
various time-series prediction tasks, but we believe that our
results are applicable to any feedforward or recurrent ANN.
Introduction
Inspired by spiking neurons, artiï¬cial neurons (ANs) com-
bine in one unit, the additive behavior of biological neurons
with the graded nonlinear behavior of their synapses (Bishop
1995; Goodfellow, Bengio, and Courville 2016). This makes
ANs implausible from a biophysical point of view, and pre-
cluded their adoption in neural science.
Artiï¬cial neural networks (ANNs) however, correct this
biological blunder. In ANNs it is irrelevant what is the mean-
ing of a neuron, and what is that of a synapse. What mat-
ters, is the mathematical expression of the network itself.
This was best exempliï¬ed by ResNets, which were forced,
for technical reasons, to separate the additive transforma-
tion from the graded one, and introduce new state variables,
which are the outputs of the additive neural, rather than the
nonlinear synaptic units (He et al. 2016).
This separation allows us to reconcile ResNets with liq-
uid time-constant neural networks (LTCs), a biophysical
model for nonspiking neurons, that shares architectural mo-
tifs, such as activation, inhibition, sequentialization, mutual
exclusion, and synchronization, with gene regulatory net-
works (Lechner et al. 2019, 2020; Hasani et al. 2021; Alon
2007). LTCs capture the behavior of neurons in the retina of
large species (Kandel et al. 2013), and that of the neurons
Copyright Â© 2022, Association for the Advancement of Artiï¬cial
Intelligence (www.aaai.org). All rights reserved.in small species, such as the C.elegans nematode (Wicks,
Roehrig, and Rankin 1996). In LTCs, a neuron is a capaci-
tor, and its rate of change is the sum of a leaking current, and
of synaptic currents. The conductance of a synapse varies in
a graded nonlinear fashion with the potential of the presy-
naptic neuron, and this is multiplied with a difference of po-
tential of the postsynaptic neuron, to produce the synaptic
current. Hence, the graded nonlinear transformation is the
one that synapses perform, which is indeed the case in na-
ture, and not the one performed by neurons.
In contrast to ResNets, NeuralODEs and CT-RNNs (Chen
et al. 2018; Funahashi and Nakamura 1993), LTCs multi-
ply (or gate) the conductance with a difference of poten-
tial. This is dictated by physics, as one needs to obtain a
current. Gating makes each neuron interpretable as a lin-
ear system with state-dependent coefï¬cients (Alvarez-Melis
and Jaakkola 2018; C Â¸ imen 2008). Moreover, LTCs associate
each activation function to a synapse (like in nature) and not
to a neuron (like in ANNs). This allows LTCs to pack con-
siderably more parameters in a network with a given number
of neurons and synapses. As the approximation capability
of ANNs and LTCs is strongly correlated with their num-
ber of learnable parameters, LTCs are able to approximate of neurons and synapses. As the approximation capability
of ANNs and LTCs is strongly correlated with their num-
ber of learnable parameters, LTCs are able to approximate
the same behavior with a much smaller network, that is ex-
plainable in terms of its architectural motifs. We argue that
nonlinearity and the size of a neural network are the major
complexity barriers for human understanding.
Moving the activation functions to synapses can be ac-
complished in any ANN, with the same beneï¬ts as for LTCs
in network-size reduction. The gating of sigmoidal activa-
tion functions can be replaced with hyperbolic-tangent acti-
vation functions. However, one looses the biophysical inter-
pretation of a neural network, the linear interpretation of its
neurons, and the polarity of its synapses.
We compared the expressive power of LTCs with that
of CT-RNNs, (Augmented) NeuralODEs, LSTMs, and CT-
GRUs, for various recurrent tasks. In this comparison, we
considered LTCs and CT-RNNs with both neural and synap-
tic activation functions. We also investigated the beneï¬ts of
gating sigmoidal activation with a difference of potential.
Our results show that synaptic activation considerably re-
duces the number of neurons and associated synapses re-
quired to solve a task, not only in LTCs but also in CT-
RNNs. We also show that the use of hyperbolic-tangent ac-arXiv:2303.04944v1  [cs.NE]  8 Mar 2023 tivation functions in CT-RNNs has similar expressive power
as gating sigmoids with a difference of potential, but it
looses the linear interpretation.
The rest of the paper is structured as follows. First, we
provide a fresh look into ANNs, ResNets, NeuralODEs, CT-
RNNs, and LTCs. This paves the way to then show the ben-
eï¬ts of biophysical synapses in various recurrent tasks. Fi-
nally we discuss our results and touch on future work.
A Fresh Look at Neural Networks
Artiï¬cial Neural Networks
An AN receives one or more inputs, sums them up in a linear
fashion, and passes the result through a nonlinear activation
function, whose bias bis the condition for the neuron to ï¬re
(spike). However, activation is graded (non-spiking), with
smooth (e.g. sigmoidal) shape. Formally:
yt+1
i=(nX
j=1wt
jiyt
j+bt+1
i)(x) =1
1 +e"," This paper examines the use of biophysical synapses in Artificial Neural Networks (ANNs) and Long-Term Context (LTC) networks. It is argued that biophysical synapses allow for more parameters to be packed into a given number of neurons and synapses, and that the nonlinear transformations can be formulated as a linear system with state-dependent coefficients. The paper provides evidence for these claims on various time-series prediction tasks, and suggests that the results are applicable to any feedforward or recurrent ANN. It also discusses the use of NeuralODEs, Mujoco, and the State-Dependent Riccati Equation (SDRE) Control, as well as the torchdyn package and the LISI type of RNN."
2," MOREA: a GPU-accelerated Evolutionary Algorithm for
Multi-Objective Deformable Registration of 3D Medical Images
Georgios Andreadis
Leiden University Medical Center
Leiden, The Netherlands
G.Andreadis@lumc.nlPeter A.N. Bosman
Centrum Wiskunde & Informatica
Amsterdam, The Netherlands
Peter.Bosman@cwi.nlTanja Alderliesten
Leiden University Medical Center
Leiden, The Netherlands
T.Alderliesten@lumc.nl
ABSTRACT
Finding a realistic deformation that transforms one image into
another, in case large deformations are required, is considered
a key challenge in medical image analysis. Having a proper im-
age registration approach to achieve this could unleash a number
of applications requiring information to be transferred between
images. Clinical adoption is currently hampered by many exist-
ing methods requiring extensive configuration effort before each
use, or not being able to (realistically) capture large deformations.
A recent multi-objective approach that uses the Multi-Objective
Real-Valued Gene-pool Optimal Mixing Evolutionary Algorithm
(MO-RV-GOMEA) and a dual-dynamic mesh transformation model
has shown promise, exposing the trade-offs inherent to image reg-
istration problems and modeling large deformations in 2D. This
work builds on this promise and introduces MOREA: the first evo-
lutionary algorithm-based multi-objective approach to deformable
registration of 3D images capable of tackling large deformations.
MOREA includes a 3D biomechanical mesh model for physical plau-
sibility and is fully GPU-accelerated. We compare MOREA to two
state-of-the-art approaches on abdominal CT scans of 4 cervical
cancer patients, with the latter two approaches configured for the
best results per patient. Without requiring per-patient configura-
tion, MOREA significantly outperforms these approaches on 3 of
the 4 patients that represent the most difficult cases.
KEYWORDS
deformable image registration, multi-objective optimization, smart
mesh initialization, repair method, GOMEA
1 INTRODUCTION
In recent decades, the field of radiation oncology has experienced
rapid developments. Key to its modern practice are medical images
acquired before, during, and after treatment. Although these im-
ages are already guiding clinical decision-making in many ways,
the transfer of information between multiple images that feature
large deformations or content mismatches has proven to be a hard
challenge and has eluded widespread clinical adoption. In general,
the challenge of Deformable Image Registration (DIR) is to find a
realistic transformation that matches two or more image spaces
to each other, as illustrated in Figure 1. Given this transformation,
other metadata could be transferred between images, such as anno-
tated contours [ 30] or 3D radiation dose distributions [ 33], opening
up opportunities to make radiation treatment more precise [16].
The DIR problem consists of three main objectives: an image-
based objective (for a visual comparison), a contour-based objective
(for an assessment of object contour overlap), and a realism-basedobjective (to measure the energy required to perform the defor-
mation). These objectives are conflicting, especially when large
deformations and content mismatches are at play [ 1]. DIR is there-
fore an inherently multi-objective problem, making Evolutionary
Algorithms (EAs) well-suited for its optimization [19].
A diverse set of approaches to DIR has emerged [ 5,17,45]. These
all take a single-objective approach, requiring the user to choose
the weights associated with the optimization objectives for each
use, a priori . This can however hinder clinical adoption, since it has
been shown that choosing good weights (and other parameters) for
specific patients is difficult in general and can strongly influence
registration quality [ 36]. Even when configured for the best results,
many existing approaches struggle with large deformations and
content mismatches between images because of limitations of their registration quality [ 36]. Even when configured for the best results,
many existing approaches struggle with large deformations and
content mismatches between images because of limitations of their
underlying transformation models and (often gradient-descent-
based) optimization techniques. This shortcoming forms a second
obstacle to their translation into clinical workflows. Therefore, there
still is a need for a DIR approach that does not require a priori
objective weight configuration andcan tackle large deformations.
The need to configure objective weights a priori has previously
been addressed by taking a multi-objective approach [ 2]. This re-
moves the need to select weights for the optimization objectives in a
scalarized problem formulation a priori , since a set of solutions can
be produced that appropriately represents the trade-off between
different conflicting objectives, allowing the user to select a solu-
tion from this set, a posteriori . To overcome the second obstacle, a
flexible dual-dynamic triangular mesh transformation model that
allows for inverse-consistent, biomechanical registration has been
introduced [ 3]. This model can match structures on both images to
capture large deformations. The Multi-Objective Real-Valued Gene-
pool Optimal Mixing Evolutionary Algorithm (MO-RV-GOMEA)
has proven to be effective at performing DIR with this model for
2D images by decomposing the problem into local, partial evalu-
ations [ 10]. The Graphics Processing Unit (GPU) is exceptionally
well-suited to execute these partial evaluations in parallel, yielding
(a)Source image
 (b)Target image
 (c)Example registration
Figure 1: Illustration of two images with large deformations
and an example of a deformable image registration with
MOREAâ€™s dual-dynamic mesh transformation model.arXiv:2303.04873v1  [cs.CV]  8 Mar 2023 Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
significant speed-ups [ 12]. Recently, first steps have been taken to
extend this GPU-accelerated approach to 3D images [ 4], for which
the benefits of partial evaluations may be even greater due to the
increase in the amount of image information (from 65k pixels in
2D to more than 2 million voxels in 3D), leading to more, but also
costlier partial evaluations. While this extended approach has been
shown to be capable of solving simple registration problems of sin-
gle objects, it misses several crucial components required to tackle
clinical problems that feature multiple interacting objects.
In this work, we therefore introduce MOREA, the first EA-based
Multi-Objective Registration approach capable of registering 3D im-
ages with large deformations using a biomechanical model, without
requiring a priori configuration of objective weights. In MOREA, a
3D tetrahedral mesh is initialized on interesting structures using a
novel custom mesh generation approach, and a repair mechanism
for folded meshes is embedded. With MOREA we furthermore im-
prove on prior modeling strategies [ 4] for all objectives to ensure
desirable deformations will be achieved.
2 DEFORMABLE IMAGE REGISTRATION FOR
LARGE DEFORMATIONS
In this section, we define the DIR optimization problem (Section 2.1)
and examine existing approaches (Section 2.2).
2.1 Problem Definition
The problem of DIR for a pair of 2 images is to find a non-rigid
transformation ğ‘‡that deforms a source image ğ¼ğ‘ to match a tar-
get imageğ¼ğ‘¡as closely as possible [ 40]. We distinguish between
unidirectional andsymmetric registration: in unidirectional registra-
tion, onlyğ‘‡(ğ¼ğ‘ )â‰ˆğ¼ğ‘¡is optimized, while in symmetric registration,
ğ‘‡â€²(ğ¼ğ‘¡)â‰ˆğ¼ğ‘ is also optimized [ 40]. This can improve the physical
viability of the registration. Another desirable distinction for reg-
istrations is inverse-consistency [40], guaranteeing a one-to-one
correspondence between any point in the source image and its
corresponding point in the target image.
Registrations can generally be evaluated according to three
classes of quality metrics. Image intensity metrics compare the pre-
dicted voxel intensity values of ğ‘‡(ğ¼ğ‘ )to the voxel intensity values
ofğ¼ğ‘¡, using metrics such as cross-correlation or mutual informa-
tion [ 26].Contour metrics judge registration accuracy by applying
ğ‘‡to pairs of sets of points, representing contours ( ğ¶ğ‘ andğ¶ğ‘¡), and
computing the distances between those point sets. One example is
the Chamfer distance [ 22]: for each pairâŸ¨ğ¶ğ‘ ,ğ¶ğ‘¡âŸ©, the longest mini-
mum distance is calculated between points in ğ‘‡(ğ¶ğ‘ )and any point
inğ¶ğ‘¡. DIR approaches can also use these contours at initialization
time, to build transformation models for use during optimization.
Finally, deformation magnitude metrics express registration realism
by measuring the force needed to apply the deformation, using a
physical model of the image space [ 23]. This can serve as a regular-
ization mechanism, discouraging the registration to overfit.
2.2 Related Work
These three quality metrics are conflicting objectives that form a
trade-off [ 1]. A number of single-objective registration approaches
have emerged in recent years, typically attempting to deal with thistrade-off by exploring different objective scalarizations. This how-
ever has the downside of having to set objective weights, a priori .
We categorize these existing approaches broadly according to the
above defined classes of quality metrics, into classes of approaches
mainly optimizing for (1) intensity match, (2) contour match, and
(3) both matches simultaneously. These and other features are com-
pared for selected prominent approaches in Table 1.
An example of the first class, optimizing for intensity match, is
the Elastix toolbox [ 28]. It uses a B-spline based transformation
model, which uses BÃ©zier curves to model physical space. With this
model, Elastix optimizes for intensity, regularized by deformation the Elastix toolbox [ 28]. It uses a B-spline based transformation
model, which uses BÃ©zier curves to model physical space. With this
model, Elastix optimizes for intensity, regularized by deformation
magnitude metrics. While this is a good fit for many applications,
we observe that registering more complex, large deformations with
local discontinuities (such as studied in this work) can be difficult.
The ANTs SyN registration approach [ 5] was conceived to model
such large deformations, featuring symmetric, inverse-consistent,
and intensity-based registration using time-varying velocity fields.
A third intensity-based approach is the Demons algorithm [ 42], us-
ing principles from optical flow and Maxwellâ€™s Demons for inverse-
consistent registration. A more recent version of this approach also
has a mechanism to handle content mismatch between images [ 34].
Both the ANTs and Demons approach can in theory flexibly model
large deformations, but lack biomechanical modeling capabilities
and only operate on image intensity. This can hamper reliably
producing anatomically valid registrations [30].
This is one reason to consider the second class of approaches.
One of these approaches is the Thin-Plate Splines Robust Point
Matching approach (TPS-RPM), which deforms contours using a
thin-plate spline model [ 18]. Subsequent work validated this on
an abdominal test case, registering a deforming bladder and two
surrounding organs [ 44]. There is also a symmetric version of TPS-
RPM, which improves robustness on large deformations [ 8]. Work
conducted in parallel also applies a similar model to contours for ab-
dominal registration problems [ 39]. While large deformations can
be modeled, the biomechanical plausibility of the transformation is
not guaranteed, and objective weights still require configuration.
Another contour-based approach is MORFEUS [ 17], which registers
a mesh representation of imaged objects using a Finite Element
Method (FEM) solver. It has shown promising results on brachyther-
apy applications in the abdomen [ 37]. Although MORFEUS uses
a biomechanical model, which improves realism, it does not take
image intensities into account, thus losing detail between object
surfaces and relying too heavily on (user-supplied) contours.
Recent work has targeted this shortcoming by proposing a com-
bined contour-based and image-based approach: the ANAtomically
CONstrained Deformation Algorithm (ANACONDA) [ 45] optimizes
a fixed scalarization of image and contour terms by using the quasi-
Newton algorithm. This approach however lacks biomechanical
modeling, and also introduces yet another parameter to configure.
Other hybrid attempts have also emerged, such as a combination
of the Demons approach with local FEM meshes [ 48], or the use
of an image-based registration step to derive tissue elasticities that
are later used in an FEM-based registration approach [29].
In general, we see a gap: an approach that includes all registra-
tion aspects in one model. As Table 1 shows, we target this gap
with MOREA by being both image-based and contour-based, fea-
turing biomechanical modeling, and exploiting the multi-objective MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
Feature Elastix [28] ANTs SyN [5] Demons [42] TPS-RPM [18] ANACONDA [45] MORFEUS [17] MOREA (this work)
Image-based âœ“ âœ“ âœ“ âœ— âœ“ âœ— âœ“
Contour-based âœ— âœ— âœ— âœ“ âœ“ âœ“ âœ“
Biomechanical âœ— âœ— âœ— âœ— âœ— âœ“ âœ“
Multi-objective âœ— âœ— âœ— âœ— âœ— âœ— âœ“
Table 1: Comparison of selected prominent existing DIR approaches by supported registration features.
nature of the DIR problem. These novelties are made possible by
the flexibility and robustness of EAs, which are well-suited to op-
timize non-differentiable, multi-objective problems. Additionally,
the objective functions include millions of image voxel values and
are therefore expensive to compute, calling for hardware acceler-
ation. Modern model-based EAs such as MO-RV-GOMEA feature
excellent GPU compatibility, making them a good fit for optimizing
the DIR problem.
3 MO-RV-GOMEA
The structure of Black-Box Optimization (BBO) problems only gets
revealed through repeated function evaluations. Gray-Box Opti-
mization (GBO) problems, on the other hand, have a (partly) known
problem structure, which can be exploited during optimization. The
GOMEA suite of EAs has proven to be exceptionally well suited
for efficiently solving both benchmark and real-world GBO prob-
lems [ 41]. Its extension to multi-objective, real-valued problems,
MO-RV-GOMEA [ 11], has even found real-world adoption in clini-
cal practice for prostate brachytherapy treatment planning [ 7,13].
We give an overview of the key working principles of MO-RV-
GOMEA here. A detailed description may be found in literature [ 14].
Non-dominated solutions are preserved across generations in an
elitist archive with a pre-specified capacity [ 31]. Each generation
starts with the selection of a subset of non-dominated solutions from
the current population. This selection is clustered into ğ‘˜equally
sized clusters. For each cluster, MO-RV-GOMEA employs a linkage
model that describes dependence relations between variables using
a set of dependent variable sets, called Family of Subset (FOS) ele-
ments. This linkage model can be learned during optimization in a
BBO setting, but in MOREA, we employ a static linkage model based
on topological proximity of variables (see Section 4.2.1). Variation
then proceeds by considering variables in FOS elements jointly in
a procedure called optimal mixing . In this step, distributions are
estimated for each FOS element in each cluster, and new, partial
solutions are sampled from these distributions. Newly sampled
partial solutions are evaluated and accepted if their insertion into
the parent solution results in a solution that dominates the parent
solution or that is non-dominated in the current elitist archive.
4 APPROACH
The approach outlined in this work builds on the recently pro-
posed multi-objective approach for 3D images [ 4]. In this section,
we present the new techniques we have added, in modeling the
problem (Section 4.1), initializing the population of solutions (Sec-
tion 4.2), and optimizing the deformations (Section 4.3).4.1 Modeling
4.1.1 Enhancing realism with tissue-specific elasticities. Adjacent
work has indicated that using tissue-specific elasticities, instead
of assuming one homogeneous elasticity for the entire image re-
gion, can enhance the realism of resulting deformations [ 37,46].
Following this insight, we extend the deformation magnitude ob-
jective used in existing work [ 4] by computing an elasticity factor
for each tetrahedron, based on its underlying image region. Imple-
mentation details for this computation are provided in Appendix A.
We observe in exploratory experiments that this leads to better
registration outcomes (see Appendix Section C.3.1).
To compute the deformation magnitude objective, we consider
all corresponding edges ğ‘’ğ‘ andğ‘’ğ‘¡of each tetrahedron ğ›¿âˆˆÎ”, be-
longing to the mesh on the source image and the mesh on the target To compute the deformation magnitude objective, we consider
all corresponding edges ğ‘’ğ‘ andğ‘’ğ‘¡of each tetrahedron ğ›¿âˆˆÎ”, be-
longing to the mesh on the source image and the mesh on the target
image, respectively. This includes 4 spoke edges that better capture
flattening motion, giving a total of 10 edges per tetrahedron [ 4].
Given the tetrahedron-specific elasticity constant ğ‘ğ›¿, the objective
is computed as follows:
ğ‘“magnitude =1
10|Î”|âˆ‘ï¸
ğ›¿âˆˆÎ”ï£®ï£¯ï£¯ï£¯ï£¯ï£°âˆ‘ï¸
(ğ‘’ğ‘ ,ğ‘’ğ‘¡)âˆˆğ¸ğ›¿ğ‘ğ›¿(âˆ¥ğ‘’ğ‘ âˆ¥âˆ’âˆ¥ğ‘’ğ‘¡âˆ¥)2ï£¹ï£ºï£ºï£ºï£ºï£»
4.1.2 Robustly estimating image similarity. The intensity objective
we use is defined as a voxel-to-voxel comparison by taking the sum
of squared intensity differences, with special handling for compar-
isons of foreground (i.e., non-zero intensity) and background (i.e.,
zero intensity) voxels. We use a random sampling technique that is
well-suited for GPU acceleration (defined in detail in Appendix A).
Using the set of all sampled image points on both images, ğ‘ƒğ‘ and
ğ‘ƒğ‘¡, and image intensities of source image ğ¼ğ‘ and target image ğ¼ğ‘¡, the
objective is defined as follows:
ğ‘“intensity =1
|ğ‘ƒğ‘ |+|ğ‘ƒğ‘¡|ï£®ï£¯ï£¯ï£¯ï£¯ï£°âˆ‘ï¸
ğ‘ğ‘ âˆˆğ‘ƒğ‘ â„(ğ‘ğ‘ ,ğ‘‡(ğ‘ğ‘ ))+âˆ‘ï¸
ğ‘ğ‘¡âˆˆğ‘ƒğ‘¡â„(ğ‘ğ‘¡,ğ‘‡â€²(ğ‘ğ‘¡))ï£¹ï£ºï£ºï£ºï£ºï£»
â„(ğ‘ğ‘ ,ğ‘ğ‘¡)=ï£±ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£³(ğ‘ğ‘ âˆ’ğ‘ğ‘¡)2ğ‘ğ‘ >0âˆ§ğ‘ğ‘¡>0
0 ğ‘ğ‘ =0âˆ§ğ‘ğ‘¡=0
1 otherwise
4.1.3 Approximating the guidance error. In contrast to previous
work where an exact guidance measure was used as one of the ob-
jectives [ 4], in this work we have opted to introduce a measure that
is an approximation thereof that can be much more efficiently com-
puted using the GPU-accelerated sampling method that we already
use for the calculation of the values for the image similarity objec-
tive. Preliminary experiments showed very similar results (when
looking at the voxel displacement fields), also because a perfect Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
/gid01748
/gid01748/gid01748
/gid01748
/gid01748/gid01748
/gid01748/gid01748
/gid01748/gid01748/gid01748
/gid01748
(a)The initial configura-
tion, with positive area
signs for each triangle.
/gid01748
/gid01748/gid01748
/gid01748
/gid01748/gid01748
/gid01748/gid01748
/gid01748/gid01748/gid01748
/gid01162(b)The fold, detected
by a sign change in the
folded (red) triangle.
(c)The repair method,
resolving the fold by
moving the red point.
Figure 2: 2D illustration of a mesh configuration with and
without a constraint violation (fold). One of the triangles is
folded, due to the red point having moved outside the cen-
tral triangle, colored yellow. The folded area is colored red.
guidance error is not necessarily the best solution. In Appendix A,
we provide details regarding the implementation.
MOREAâ€™s guidance objective is computed at positions ğ‘ƒğ‘ and
ğ‘ƒğ‘¡, using the set ğºof all point set pairs âŸ¨ğ¶ğ‘ ,ğ¶ğ‘¡âŸ©ğ‘–and the minimal
point-to-point-set distance ğ‘‘(ğ‘,ğ¶). The total number of guidance
points is indicated as |ğºğ‘ |and|ğºğ‘¡|, and a truncation radius as ğ‘Ÿ.
The guidance objective is now defined as follows:
ğ‘“guidance =1
|ğ‘ƒğ‘ |+|ğ‘ƒğ‘¡|âˆ‘ï¸
âŸ¨ğ¶ğ‘ ,ğ¶ğ‘¡âŸ©âˆˆğº""
|ğ¶ğ‘ |
|ğºğ‘ |ğ‘”(ğ‘ƒğ‘ ,ğ‘‡,ğ¶ğ‘ ,ğ¶ğ‘¡)+|ğ¶ğ‘¡|
|ğºğ‘¡|ğ‘”(ğ‘ƒğ‘¡,ğ‘‡â€²,ğ¶ğ‘¡,ğ¶ğ‘ )#
ğ‘”(ğ‘ƒ,Î¦,ğ¶,ğ¶â€²)=âˆ‘ï¸
ğ‘âˆˆğ‘ƒ
ğ‘‘(ğ‘,ğ¶)<ğ‘Ÿ""
ğ‘Ÿâˆ’ğ‘‘(ğ‘,ğ¶)
ğ‘Ÿ(ğ‘‘(ğ‘,ğ¶)âˆ’ğ‘‘(Î¦(ğ‘),ğ¶â€²))2#
4.1.4 Rapidly computing constraints. MOREAâ€™s solutions represent
meshes with hundreds of points, which can easily get entangled
into folded configurations. Such constraint violations should be
prevented, to uphold the guarantee of inverse-consistency. Prior
work [ 4] used a strategy that proved error-prone in more complex
meshes. MOREA includes a novel fold detection method that is
based on an observed phenomenon: a mesh fold will cause the sign
of at least one tetrahedronâ€™s volume to change, as illustrated in
Figure 2 (the figure is in 2D, but this also holds in 3D). Our method
uses this phenomenon to detect folds and to measure their severity,opening up repair opportunities (see Section 4.3.1). Implementation
details for our method are provided in Appendix A.
4.2 Initialization of Registration Solutions
Significant performance gains can be obtained if the initial guesses
given to the optimizer are closer to desirable objective space regions
than a random guess or grid-like initializations [ 9]. We introduce
two techniques that provide such initial guesses.
4.2.1 Exploiting problem structures with mesh initialization. We
initialize the meshes to align with objects in the image, adapting
an existing method for 2D images [ 9] and expanding it to facilitate
parallelization on the GPU. First, we place points on the contours
of objects in the source image to capture their shape (see Fig. 3a).
We choose these points by greedily taking a spread-out subset from
the contour annotations also used for the guidance objective, as
well as a small fraction of randomly chosen points across the image.
Then, we perform a Delaunay tetrahedralization on these points,
using the TetGen suite [ 25] (see Fig. 3b). This yields a mesh that we
duplicate to the target image space to complete the dual-dynamic
transformation model.
As laid out in Section 3, MO-RV-GOMEA evaluates groups of
variables (i.e., FOS elements) jointly during variation. Exploratory
experiments have shown that using edges as FOS elements (i.e.,
groups of two connected points, with the variables encoding their
coordinates), is beneficial for this problem. If two FOS elements
are completely independent because their variables are not needed
for the partial evaluation of each set, variation and evaluation for
these FOS elements can be done in parallel. We conduct two further
steps to facilitate parallel evaluation and optimization on the GPU.
First, we execute a greedy set cover algorithm1to find a subset
of edges that covers all points (see Fig. 3c), so that each variable
(point coordinate) undergoes variation. We could alternatively use First, we execute a greedy set cover algorithm1to find a subset
of edges that covers all points (see Fig. 3c), so that each variable
(point coordinate) undergoes variation. We could alternatively use
all edges, but this would lead to points being included in several
FOS sets and thus undergoing variation multiple times per genera-
tion. For parallelization purposes, it is more efficient to select an
(approximately) minimal set of edges.
Given the edge subset found by the set cover, we now determine
which FOS elements can be safely optimized in parallel. For this,
we build an interaction graph based on topological proximity [ 12],
where two elements are connected if their sets of dependent tetra-
hedra overlap, i.e., the tetrahedra that are reevaluated when an
1Source: https://github.com/martin-steinegger/setcover
(a)Points placed on poten-
tially interesting positions.
(b)Custom mesh derived
from these points.
(c)Edges selected for varia-
tion through set cover.
(d)Interaction graph (blue)
between selected edges.
(e)Graph coloring computed
on interaction graph.
Figure 3: 2D illustration of the mesh initialization process, which produces a custom mesh and determines which groups of
edges (i.e., FOS elements) can be optimized in parallel. Selected edges are highlighted in red, interaction edges in blue. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
element is changed (see Fig. 3d). Given this graph, parallel groups
are created with the DSATUR graph coloring algorithm [ 15] (see
Fig. 3e). The dependent tetrahedra of each parallel group can be
evaluated in parallel on the GPU, which has been proven to lead to
speed-ups of more than 100x on 2D images [12].
Tetrahedral mesh quality can further be improved by specifying
surfaces that should be included in the generated mesh. We apply
this principle to the bladder by generating a surface mesh using the
Marching Cubes algorithm. We then specify its triangular surfaces
as constraints to the mesh generation algorithm, ensuring that
bladder surface triangles are included in the mesh. Exploratory
experiments show superior performance when using this step (see
Appendix B.3.1).
4.2.2 Ensuring diversity in initial population. To promote diversity
in the initial population, prior work generates random deviations
for each point in the mesh, starting at a grid-initialized solution [ 4].
We observe that this method can produce many folded mesh con-
figurations in generated solutions, which get discarded and thus
hamper convergence speed. In this work, we use a radial-basis-
function approach to introduce large deformations free of mesh
folds. Implementation details on how these fields are generated and
applied to solution meshes are provided in Appendix A.
4.3 Repairing and Steering
During optimization, we apply two techniques to improve the qual-
ity of solutions obtained, and the time needed to reach them.
4.3.1 Repairing infeasible solutions. By default, infeasible solutions
(i.e., solutions with either of the two meshes having one or more
folds) are discarded. This, however, can hamper the creation of
high-quality offspring, as infeasible solutions may still provide
useful information for higher-quality search space regions. We
therefore devise a repair method that attempts to reverse folds
on a point-by-point basis. For each point in a folded tetrahedron,
the method mutates the point using a Gaussian distribution scaled
by its estimated distance to the surrounding 3D polygon. After
64 samples, the change with the best constraint improvement is
selected, if present. If all samples result in a deterioration, repair is
aborted. The repair process for one point is illustrated in Figure 2c.
4.3.2 Applying pressure with adaptive steering. In general, an ap-
proximation set should be as diverse as possible while resembling
the Pareto set as closely as possible. In practice, however, not all
regions of the Pareto front are of equal interest to users. A user con-
ducting medical DIR for images with large deformations is typically
not interested in solutions with a small deformation magnitude.
The user is actually most interested in solutions with good guid-
ance objective values, and we would like the algorithm to steer its
search towards that region in the objective space. Following earlier
work [ 1], we implement an adaptive steering strategy, which steers
the front towards high-quality guidance solutions after an explo-
ration period of 100 generations. Given the best guidance objective
valueğ‘ ğºof any solution in the elitist archive, we only preserve
solutions with guidance objective values between [ğ‘ ğº; 1.5ğ‘ ğº], i.e.,
this becomes a hard constraint.5 EXPERIMENTS
We compare MOREA to existing state-of-the-art registration ap-
proaches. Due to the complexity of the problem, we do not impose
one time limit on all approaches, but rather ensure that they have
(reasonably) converged. We repeat all approaches with all configu-
rations 5 times, seeded reproducibly. All MOREA registration runs
are run on Dell Precision 7920R machines with NVIDIA RTX A5000
GPUs. Additional information on experimental setup and results is
provided in the appendix.
5.1 Registration Problems
We test all approaches on 4 clinical registration problems with large GPUs. Additional information on experimental setup and results is
provided in the appendix.
5.1 Registration Problems
We test all approaches on 4 clinical registration problems with large
deformations (see Table 2). We retrospectively select two successive
Computerized Tomography (CT) scans of the abdominal area of
cervical cancer patients, acquired for radiation treatment planning
purposes, with a Philips Brilliance Big Bore scanner. On the first CT
scan, the bladder of the patient is filled, and on the second scan, the
bladder is empty and thus has shrunken significantly. This large
deformation is challenging to register correctly while respecting
the surrounding organs (e.g., rectum and bowel) and bony anatomy.
Patients 1â€“3 represent common cases in clinical practice, exhibiting
large deformations and little to no margin between bladder and
bowel in the full-bladder scan. The bladder of Patient 4 largely
preserves its shape and exhibits a wide margin between bladder
and bowel, making registration easier. This case, however, is also
rarer in practice, and therefore less representative.
The axial slices of the CT scans have a thickness of 3 mm,
with in-slice resolutions ranging between (0.86,0.86)mm and
(1.07,1.07)mm. Each scan is resampled to (1.5,1.5,1.5)mm for
consistency. Afterward, each scan pair is rigidly registered (i.e.,
translated, rotated, or scaled linearly) to align the bony anatomies
of both scans, using bone contours delineated by a radiation
therapy technologist (RTT). Each pair is cropped to an axis-aligned
bounding box surrounding the bladder with a 30 mm margin,
taking the maximal bounds from both images. This restricts the
registration to the region where treatment was delivered, including
the surrounding organs at risk.
Contours of key organs in each scan have been annotated by
an RTT and verified by a radiation oncologist. The sets of points
defining these contours serve as input to the guidance objective
of MOREA. We also use these clinical contours to generate binary
masks for each organ and the bones by filling 2D polygonal esti-
mates formed by contours on each slice. As is common in practice,
these contours can overlap, since organs are delineated indepen-
dently and are often surrounded by a small safety margin. Registra-
tion approaches therefore need to be robust enough to handle this
overlap. Several anatomically relevant corresponding landmarks
have been annotated by an RTT and verified by a radiation oncolo-
gist on both scans, for evaluation purposes (see Appendix D).
5.2 Registration Approaches
We consider a number of existing, popular registration approaches
for which executable code is available. For these approaches, we
follow a two-phase configuration process. First, we explore relevant
coarse-grained settings for a single patient scan pair (of Patient 1), Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
Instance Source Target
Patient 1
Patient 2
Patient 3
Patient 4
Table 2: Sagittal slices of all registration problems, with or-
gans contoured in different colors.
to find a suitable configuration for the imaging modality and prob-
lem difficulty. Then, we conduct fine-grained configuration on the
remaining settings (e.g., objective scalarization weights) for each
patient scan pair. We describe the resulting configuration for each
approach below, including the general coarse-grained configuration
of MOREA. A detailed overview of how we reached these configu-
rations, with additional configuration experiments, can be found in
Appendix C.
5.2.1 Elastix. We configure Elastix to conduct a regularized, multi-
resolution [ 43] image registration. Recommended settings2did not
yield satisfactory results on our scans, therefore we first register
composite mask images onto each other for each patient. This
is used as starting point for optimization on the original image
intensities. As a fine-grained configuration step for each patient,
we configure the weight assigned to the deformation magnitude
2Based on an official parameter settings database: https://elastix.lumc.nl/modelzoo/objective in a fixed sweep of exponentially increasing weights of
[0,0.001,0.01,..., 10.0], as is done in related work [8].
5.2.2 ANTs SyN. For the ANTs SyN algorithm, the recommended
settings3for multi-resolution registration also were not satisfactory,
which led us to conduct initial configuration experiments with sev-
eral key parameters, listed in Appendix C. We also add a composite
mask in an additional image channel that is registered alongside the
image. For each patient, we test the same regularization weight of
the overall deformation by testing the same weights as for Elastix.
5.2.3 This work: MOREA. MOREA uses a single-resolution ap-
proach and is configured to generate a mesh of 600 points (i.e., the
problem is 3600-dimensional), using the strategies for mesh gen-
eration described in Section 4.2. We set the elitist archive capacity
to 2000 and use 10 clusters during optimization, with a runtime
budget of 500 generations, during which the EA converges (see
Appendix D). As MOREA is a multi-objective approach returning
an approximation set of registrations, we do not need to configure
it further for each patient.
5.3 Evaluation of Registrations
Solutions to complex registration problems, such as the problems
in this study, require a multi-faceted evaluation. Below, we outline
two main methods for evaluating registrations: surface-based ac-
curacy and visual inspection. Additional methods are described in
Appendix Section B.2 and applied in Appendices C and D.
5.3.1 Surface-based registration accuracy. A key part of evaluating
registration accuracy is to assess how well the surfaces (contours) of
objects align [ 16]. We use the Hausdorff distance, which represents
the largest minimal distance between any two points on two object
surfaces. This can be interpreted as the severity of the worst surface
match. To account for potential deformation inaccuracies at the
border regions of the image, we discard a margin of 15 mmon each
side for the computation of this metric. Since this is smaller than the
earlier cropping margin of 30 mm, the bladder and regions around
it are left untouched by this second crop.
5.3.2 Visual inspection. Surface-based accuracy analysis is com-
plemented by a visual inspection, since a registration with a good
contour match can still have undesirable deformations in regions
between contours. This inspection includes viewing slices of the
target image overlaid with the source contours transformed using
the computed forward DVF of the registration. To also inspect the
deformation between contours, we also visualize the full deforma-
tion: First, we render the DVF itself with a quiver plot. Second,
we overlay a regular grid onto a slice and deform it with the DVF, deformation between contours, we also visualize the full deforma-
tion: First, we render the DVF itself with a quiver plot. Second,
we overlay a regular grid onto a slice and deform it with the DVF,
which gives a different perspective.
5.4 Comparison of Registrations
All registration solutions from all approaches are compared using
the same evaluation pipeline, to ensure a fair comparison. Each
approach is configured to output its registrations in the form of a
forward and an inverse DVF, which define the deformation on the
source and the target image, respectively. Existing approaches either
3Based on technical documentation: https://github.com/ANTsX/ANTs/wiki/Anatomy-
of-an-antsRegistration-call MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
(a)Patient 1
 (b)Patient 2
 (c)Patient 3
 (d)Patient 4
Figure 4: A selection of the best predicted deformations for each patient, represented by deformed contours rendered onto the
target image with its reference contours (i.e., target in blue). Annotated slices showing all organs are provided in Table 2.
(a) Elastix
 (b) ANTs
 (c) MOREA
Figure 5: Forward deformation vector fields and deformed contours of selected predicted deformations on Patient 1, for all 3
approaches (down-sampled for visibility). Arrow colors represent deformation magnitudes, in voxels (1 voxel =1.5mm).
directly or indirectly can be configured to output such DVFs. For
MOREA, we rasterize the deformation encoded by the two deformed
meshes of a solution, using an existing rasterization method [ 24].
Since we are comparing single-objective approaches to a multi-
objective approach (MOREA), we need to select solutions from
MOREAâ€™s approximation set. We conduct this a posteriori selection
by starting at the solution with the best guidance objective value
and manually navigating through the approximation front to find a
solution with a good trade-off between contour quality and realism.
We also conduct statistical testing using the two-sided Mann-
Whitney U test (a standard non-parametric test) to compare MOREA
to ANTs and Elastix. The Hausdorff distance of the bladder contour
is used as the test metric, as it describes the largest deforming organ.
To correct for multiple tests in the pair-wise comparisons, we apply
Bonferroni correction to the ğ›¼-level and reduce it from 0.05 to 0.025.
6 RESULTS AND DISCUSSION
Figure 4 shows selected outcomes from each per-patient fine-
grained configuration experiment, along with a solution from
MOREAâ€™s approximation front for each patient. For Elastix, we
select the runs with regularization weights 1.0, 1.0, 10.0, and 10.0
on Patients 1â€“4, respectively, and for ANTs, we select all runs with
weight 0. The full results of our configuration experiments for bothProblem MOREA vs. Elastix MOREA vs. ANTs
Patient 1 0.011 (+) 0.007 (+)
Patient 2 0.007 (+) 0.007 (+)
Patient 3 0.012 (+) 0.007 (+)
Patient 4 0.007 (+) 0.195 ( -)
Table 3: p-values of pair-wise comparisons of Hausdorff dis-
tances for the bladder between approaches. A plus ( +) indi-
cates a better mean with MOREA, a minus ( -) the opposite.
Significant results are highlighted.
existing approaches can be inspected in Appendix Sections B.1.2
and B.2.2. Convergence plots for Patient 1, which show how all
approaches have converged to the results presented here, can
be found in Appendix D. As described in Section 5.1, there is an
intrinsic difference in difficulty between the scans. In general, we
observe MOREA generally outperforming other approaches on
the more difficult patients (1â€“3), as can be seen visually in the
deformed contours shown in Figure 4 and in the additional renders
and analyses provided in Appendix D.
ForPatient 1 , we also render DVF slices in Figure 5, showing the
transformation computed for each region of one slice. We observe
that the deformations returned by Elastix and ANTs only deform Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
Figure 6: Approximation front produced by MOREA on Pa-
tient 1. We render 3 zoomed-in registration solutions.
the top region of the bladder. MOREA is the only approach which
distributes this deformation across the entire bladder, which is a
more realistic deformation in this flexible volume. Figure 6 plots
the approximation set that is produced by MOREA on Patient 1,
highlighting 3 solutions with slightly different deformations. This
illustrates the range of solutions presented to the user, all of which
spread the deformation across the bladder.
Patient 2 , which features the largest volume change in the blad-
der, seems to prove the most difficult: MOREA comes closest to
modeling its deformation (see Fig. 4), although this comes at the
cost of the bowel also being moved downwards. A probable cause
is the little space (i.e., margin) left between the two organs in the
source image. Here, MOREAâ€™s result exposes a more fundamental
problem that affects all approaches: structures separated by little to
no margin in one image cannot be separated in the other image with
a transformation model consisting of a single mesh. The change of
bladder shape in Patient 3 is less severe than for Patient 2, but still
proves challenging for Elastix and ANTs (see Fig. 4). Especially the
back region (located left of the image center) does not match the
target. Patient 4 represents a relatively easy registration problem,
with little change in the shape of the bladder and a clear margin
between bladder and bowel (see Fig. 2). On this problem, visual
inspection shows that ANTs and MOREA both find a good bladder
contour fit, while Elastix struggles with both bladder and bowel.
Examining these results quantitatively, we conduct significance
tests on the Hausdorff distance of the bladder, listed in Table 3.
In all patients, the contour match of the bladder as deformed by
MOREA is significantly superior to Elastixâ€™s contour match. ANTs
models the contour of the bladder significantly less accurately than
MOREA in 3 out of 4 cases, with the fourth case (Patient 4) not
having a significantly different result. Appendix D lists significance
test results for all organs, which confirm these trends, but also show
that MOREAâ€™s Hausdorff distance can sometimes be significantlyhigher than that of ANTs or Elastix. This does not however need
to imply worse registration performance, as a qualitative analysis
shows. For example, the deformed shape of the sigmoid of Patient 2
found by ANTs is strongly off (see Figure 4). However, its metric
value is deemed significantly better than MOREAâ€™s, even though
MOREA is closer to the target in terms of general shape.
7 CONCLUSIONS
This work uniquely brings multiple lines of research in the field of
deformable image registration together. We have introduced a reg-
istration approach, MOREA, that is both contour-based and image-
based, uses a biomechanical model, and performs multi-objective op-
timization. This combination uniquely positions MOREA to tackle
challenging 3D image registration problems with large deforma-
tions and content mismatches. MOREA was built on the MO-RV-
GOMEA model-based evolutionary algorithm with several problem-
specific extensions, such as GPU acceleration, solution repair, and
object-aligned mesh initialization. Our experiments have shown
promising results on 4 cervical cancer patient scans, reaching higher
contour registration accuracy than two state-of-the-art approaches
on 3 of the 4 patients, representing the most difficult cases. Impor-
tantly, the deformation produced by MOREA seems to be more
uniformly spread across objects than the deformations produced
by existing approaches, which is deemed to be more realistic.
Solutions obtained by MOREA still contain local inaccuracies
which does leave room for improvement, in particular in regions
where organs interface. In fact, the results of this study expose a Solutions obtained by MOREA still contain local inaccuracies
which does leave room for improvement, in particular in regions
where organs interface. In fact, the results of this study expose a
more fundamental problem in DIR, which is the inability of typical
DIR models to capture local discontinuities and content mismatches.
This motivates future research into the modeling of independent or-
gan motion, following recent work on this topic [ 35,38]. MOREAâ€™s
extensible, biomechanical model could be well-positioned for ex-
pansions to capture these phenomena. Given such an expanded
approach, a larger validation study, with more patients and involv-
ing domain experts, could help close the gap to clinical practice.
ACKNOWLEDGMENTS
The authors thank W. Visser-Groot and S.M. de Boer (Dept. of Ra-
diation Oncology, LUMC, Leiden, NL) for their contributions to
this study. This research is part of the research programme Open
Technology Programme with project number 15586, which is fi-
nanced by the Dutch Research Council (NWO), Elekta, and Xomnia.
Further, the work is co-funded by the public-private partnership
allowance for top consortia for knowledge and innovation (TKIs)
from the Dutch Ministry of Economic Affairs. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
A TECHNICAL IMPLEMENTATION DETAILS
FOR THE MOREA APPROACH
In this appendix, we provide additional technical implementation
details for the MOREA approach proposed in Section 4.
A.1 Modeling the deformation magnitude
MOREAâ€™s deformation magnitude objective models heterogeneous
elasticities for different image regions. For each tetrahedron ğ›¿, we
establish the elasticity of its underlying image region by sampling
from object-specific binary masks (see Figure 7). These masks are
computed for each object by filling the interior of its contour (avail-
able as guidance), yielding a discrete object segmentation. We com-
pute the overlap that each object mask has with the tetrahedron
ğ›¿, which produces one fraction per object. In the example given
in Figure 7, this would be a fraction of 0.4 for the object corre-
sponding to this mask. These object fractions are multiplied by
pre-determined elasticity factors for different tissue types, yielding
an overall element-specific factor for ğ›¿. At present, only bones and
bladder are assigned custom factors. The magnitude objective value
forğ›¿is multiplied by this factor to better model the actual energy
required to deform this image region.
A.2 Modeling the image similarity
The image intensity objective of MOREA is defined as a sum of
squared intensity differences at certain sample points. Modeling
the partial objective value of one tetrahedron requires determining
which image voxels to sample. The existing prototype [ 4] tries to
find all voxels with center points lying inside the tetrahedron, us-
ing a line-search-inspired method. We observe, however, that this
discrete association of voxels with tetrahedra leads to undesirable
behavior around tetrahedral surfaces, with voxels sometimes be-
ing associated with multiple or no neighboring tetrahedra. This
phenomenon can be used to improve the sampled value while not
improving or even deteriorating the true value.
In our approach, we therefore introduce a random-sampling
based method which samples the image space continuously, in-
terpolating intensity values between voxel centers. This is also
better-suited for GPU acceleration, since there are less decision
points at which execution needs to pause. We uniformly sample ğ‘
points in each tetrahedron using its barycentric coordinate system,
withğ‘being determined by the volume of the tetrahedron. For
each point, we sample 4 random real numbers ğ‘Ÿğ‘–âˆˆ[0; 1]and take
âˆ’log(ğ‘Ÿğ‘–)for a uniform spread. We then normalize the coordinates
by their sum, to ensure that they lie in the tetrahedron. Instead of a
conventional random number generator, we use the Sobol sequence,
for a more even spread of sample points. We ensure reproducibility
by seeding the Sobol sequence for each tetrahedron with a seed de-
rived from its coordinates. Therefore, the same positions are always
sampled per tetrahedron configuration.
A.3 Modeling the guidance error
The guidance error objective of MOREA approximates the contour
match of a solution. Previous work [ 4] computes the extent of a
contour match by considering each point in ğ¶ğ‘ and computing the
distance of its corresponding version in target space to the closest
point in the set ğ¶ğ‘¡. This requires iterating over all points in ğ¶ğ‘ ,
Figure 7: 2D illustration of how one tetrahedral element
(here: the red triangle) overlaps with the mask of an organ.
The computed overlap fractions are used to establish the
elasticity factor for this tetrahedronâ€™s deformation magni-
tude.
(a)Source contour point set.
T(ps)
 1
 1
 2 2
 3 4
 4 5
 5 6
 6  6 6 6
 6  6 7 7  7  7  7  7
 7
 7 8 8 (b)Target contour point set.
Figure 8: Two point sets of object contours in a source and
target image, with minimal distance maps visualized using
isolines. A randomly sampled point ğ‘ğ‘ is close to the source
contour, but the transformed ğ‘‡(ğ‘ğ‘ )is farther away from the target image, with minimal distance maps visualized using
isolines. A randomly sampled point ğ‘ğ‘ is close to the source
contour, but the transformed ğ‘‡(ğ‘ğ‘ )is farther away from the
target contour. The yellow shaded area represents the trun-
cation area beyond which sampled points are discarded.
establishing which tetrahedron they are located in, and computing
the transformation at that point. We introduce a new, continuous
guidance formulation that approximates point-wise distances and
proved to be faster and more robust, in preliminary experiments.
During the random sampling process used for the intensity ob-
jective on the source image ğ¼ğ‘ , we also consider the same locations
on a distance map of ğ¶ğ‘ , which gives the closest point to the source
contour (see Figure 8). The distance at that point in the map of ğ¶ğ‘ 
is subtracted from the distance at the corresponding point in the
map ofğ¶ğ‘¡, and weighted inversely by the distance to the source
contour. The distances are truncated to a radius around each guid-
ance point, measuring 2.5% of the width of the image, so that far
away movements do not influence the guidance error of a point set.
We normalize the guidance error of each point set by the number of
points in that set compared to the total number of guidance points,
to counteract biases towards more well-defined or larger contours.
A.4 Accurately detecting mesh folds
A function detecting constraint violations needs to have high pre-
cision (i.e., accurately identify all violations) and low latency (i.e.,
quickly return its answer). It should furthermore be defined contin-
uously, so that the method can also assess the severity of violations.
This is important for methods that repair violations.
Prior work on mesh-based 3D image registration [ 4] uses a ray-
intersection method, testing if a point is inside a so-called bounding Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
Figure 9: A 2D vector field produced by our radial-basis-
function approach used to generate solutions. Red dots
mark attractors, with their size indicating their weight.
polygon. This method has proven error-prone in 3D in preliminary
experiments, producing false positives and negatives. We therefore
develop a new method for detecting folds in a tetrahedral mesh,
based on the signed volumes of its tetrahedra [ 21]. Our method
calculates the signed volume of each tetrahedron in the initial mesh
configuration, to establish a set of reference signs. When a point is
moved, we recalculate the signed volumes of all tetrahedra that this
affects and compare them to the respective reference signs. The
signs of at least one tetrahedron will flip if a fold has occurred. We
use this phenomenon to detect mesh constraint violations and to
compute the severity of each violation, using the absolute value of
the violating signed volume.
A.5 Ensuring diversity in the initial population
Even with a smartly initialized mesh, the diversity of the popula-
tion at generation 0 plays an important role [ 32]. Prior work uses
one reference solution and generates random deviations by sam-
pling around each mesh point with increasingly large variance [ 4].
For low-resolution meshes, this method can be effective, but for
higher-resolution meshes, this method can lead to many constraint
violations in the generated solutions (i.e., folded mesh configura-
tions). We introduce a method for initialization noise that generates
large deformations free of constraint violations, inspired by ap-
proaches using radial basis functions in other domains [ 47]. Our
method places a number of Gaussian kernels on both source and
target images and models a sense of gravity from mesh points to-
wards these kernels. These forces are applied in incremental rounds,
as long as they do not cause constraint violations. A deformation
vector field generated by this strategy is depicted in Figure 9. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
B EXTENDED PROBLEM SPECIFICATION
In this appendix, we provide additional information on the regis-
tration problems used in this study and specify additional methods
for evaluation and comparison of registration quality.
B.1 Additional Problem Information
Table 4 lists the in-slice resolutions of the CT scans used. This is
the physical resolution of each slice prior to our resampling step
to(1.5,1.5)mm. We also provide additional views on each medical
image: For each patient, Table 5 lists two slices per source and target
image. This provides a useful additional perspective, since some
movements are better visible from a different angle.
B.2 Additional Evaluation Methods
We evaluate each solution with four types of methods, based on
(1) surface-based registration accuracy, (2) visual inspection using
2D and 3D visualizations, (3) volume-based registration accuracy,
(4) landmark registration accuracy. Method types (1) and (2) have
been described in Section 5.3. Here, we give an additional strategy
for (1), and outline additional methods (3) and (4).
B.2.1 Surface-based registration accuracy. Alternatively to the
Hausdorff distance, the 95th percentile of the Hausdorff distance is
another indicator we use in our study. This represents the distance
for which it holds that 95% of all surface point distances are smaller
than this distance. Both Hausdorff and Hausdorff 95th percentile
metrics are computed using the pymia PyPI package.
B.2.2 Volume-based registration accuracy. Adjacent to surface ac-
curacy, we are interested in the accuracy of individual volumes
(e.g., organs, bones) represented in the images. A common metric
for this is the Dice coefficient, which represents the fraction of
volume overlap compared to total volumes. Using binary masks of
each annotated object in the images, we compute this metric on a
voxel-by-voxel basis. We compare the binary masks corresponding
to the target image against binary masks of the source image trans-
formed using the computed deformation. With the same reasoning
as for surface-based evaluation (see Section 5.3), we discard the
same border margin when evaluating volume-based metrics.
B.2.3 Landmark registration accuracy. A set of corresponding land-
marks not provided to the algorithm during optimization can be
used to locally assess the accuracy of a registration. For each pair
of landmarks, we transform the source landmark using the forward
transformation to target space, and compute landmark accuracy as
the Euclidean distance between the transformed source landmark
and its corresponding target landmark. This is a common accuracy
measure in image registration studies [ 16,20], but can be less accu-
rate as an indicator of overall registration quality, since landmarks
are placed on visible anatomical structures that often have limited
movement, as is the case in our scans.B.3 Comparing Multi-Object Metrics
The metrics of individual organs cannot be adequately interpreted
in isolation, as organ motions are related and therefore form trade-
offs. We visualize these trade-offs by plotting scores for different
organs in one parallel coordinates plot, similar to the color-coded
heatmap comparison presented in [ 27]. These line plots help inform
decisions that need to take registration quality across registration
targets into account.
Patient Scan In-slice Resolution
Patient 1Full bladder (0.86,0.86)mm
Empty bladder (0.98,0.98)mm
Patient 2Full bladder (1.04,1.04)mm
Empty bladder (1.07,1.07)mm
Patient 3Full bladder (0.98,0.98)mm
Empty bladder (0.98,0.98)mm
Patient 4Full bladder (1.04,1.04)mm
Empty bladder (1.00,1.00)mm
Table 4: In-slice resolutions for the slices of each CT scan,
prior to resampling them to (1.5,1.5)mm. Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
Instance Source image: sagittal Target image: sagittal Source image: coronal Target image: coronal
Patient 1
Patient 2
Patient 3
Patient 4
Table 5: Slices of all registration problems, with organs contoured. Sagittal: side view; coronal: front-to-back view. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
C CONFIGURATION OF COMPARED
APPROACHES
C.1 Elastix
We use Elastix version 5.0.0. Based on parameter settings from the
Elastix Model Zoo4, we apply multi-resolution Elastix registration
to our registration problems with a range of configurations, trying
to find the optimal configuration for each problem (see Section C.1.3
for our parameter files). Inspired by an approach implementing sym-
metric registration in Elastix using a group-wise methodology [ 6],
we also experiment with a symmetric variant which registers both
images to a common image mid-space. For all setups, we relax con-
vergence requirements by increasing the number of iterations per
resolution to 10,000, which is significantly larger (5 times) than
the computational budget given in most reference files. This is
done to give Elastix sufficient opportunity to model the large defor-
mations present. We also stabilize optimization by increasing the
number of image sampling points from the frequently used 10,000
to 20,000. Although increasing the computational complexity, this
should make image intensity approximations used internally during
optimization more accurate and computed gradients more reliable.
Elastix computes the inverse transform by default, meaning a vec-
tor field defined in fixed (target) space leading to moving (source)
space. To compute the forward transform, which is needed to trans-
form annotations from moving (source) to fixed (target) space, we
rerun the registrations with the given parameter files and the com-
puted transform as initial transform, but replace the metric(s) with
theDisplacementMagnitudePenalty metric. This effectively finds
theforward transform of the computed inverse transform. Export-
ing this forward transform in isolation, by removing the initial
transform pointer from the parameter file, yields the desired DVF.
Elastix does not support the optimization of object contour
matches, which are optimized by the MOREA approach through
the guidance objective. To ensure a fair comparison, we attempt
to input this information as a pair of composite mask images to
implicitly pass on contour information. Each mask image is made
by combining the different binary object masks available for each
scan, giving each object segmentation a different homogeneous
intensity value. In runs where this feature is enabled, we precede
the CT image registration run with a registration of these prepared
composite masks.
C.1.1 Coarse-grained configuration experiments. First, we conduct
an initial set of runs on Patient 1 to establish a suitable base con-
figuration for this problem modality and difficulty. We explore the
influence of registration direction (unidirectional vs. symmetric)
and the use of a composite mask registration step (with vs. without),
assuming a regularization weight of 0.001, to give Elastix flexibility
for large deformations (a large weight on the deformation magni-
tude weight can hinder large deformations).
In Figure 10, we plot the performance of Elastix using symmet-
ric and unidirectional registration, reporting two different metrics
(Dice score and 95th percentile of the Hausdorff distance). We ob-
serve that unidirectional registration generally performs similarly
or better compared to symmetric registration, except for the rec-
tum and anal canal, in terms of Dice score. Due to the relatively
4https://elastix.lumc.nl/modelzoo/
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 10: Comparison of symmetric and unidirectional reg-
istration in Elastix, for multiple runs. The baseline score af-
ter rigid registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 11: Visual renders of deformations predicted by
Elastix configurations using unidirectional and symmetric
registration, without mask registration step. (a) Sagittal slice.
 (b) Coronal slice.
Figure 11: Visual renders of deformations predicted by
Elastix configurations using unidirectional and symmetric
registration, without mask registration step.
large performance gain in the bladder (the most strongly deforming
organ), we choose unidirectional registration at this point. This
choice is supported by visual inspection of Figure 11, which shows
slightly better performance on the bladder in the coronal slice.
We now turn to the use of a composite mask registration step, in
an attempt to get larger deformations by simplifying the informa-
tion input to Elastix. Figure 12 shows the same metrics, but with Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 12: Comparison of unidirectional registration with
and without a composite mask registration step in Elastix,
for multiple runs. The baseline score after rigid registration
is plotted in blue.
and without the use of such a step (while using unidirectional reg-
istration). The results do not identify one clear superior approach,
since the Dice score of the with-mask configuration is generally
superior but the Hausdorff 95th percentile is lower for the without-
mask configuration. Figure 13 indicates that adding a mask step
improves the modeling of the base region of the bladder, but the
middle region is merely contracted sideways without moving the
top region downwards, thereby not resulting in anatomically real-
istic deformations. Nevertheless, we choose this version over the
version without mask registration step, since the large deformation
needed is modeled more closely with the step added.
C.1.2 Fine-grained configuration experiments per patient. For each
patient, we try exponentially increasing regularization weights; an
exponential regularization weight sweep that is also used in similar
work [ 8]. The Dice scores on each patient are reported in Figure 14
and the 95th percentiles of the Hausdorff distance in Figure 15.
Renders for each problem are provided in Figures 16â€“19.
We observe that the optimal regularization weight varies
strongly between different registration problems. While the scans
of Patient 1 (Fig. 16) are best served with a weight of 1.0 out of the
tried settings, the scans of Patient 3 (Fig. 18) seem better off with a
weight of 10.0.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 13: Visual renders of deformations predicted by
Elastix configurations with and without a composite mask
registration step, using unidirectional registration. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
(a) Patient 1.
 (b) Patient 2.
(c) Patient 3.
 (d) Patient 4.
Figure 14: Dice scores for per-patient fine-grained configuration runs in Elastix. The baseline score after rigid registration is
plotted in blue.
(a) Patient 1.
 (b) Patient 2.
(c) Patient 3.
 (d) Patient 4.
Figure 15: Hausdorff 95th percentiles for per-patient fine-grained configuration runs in Elastix. The baseline score after rigid
registration is plotted in blue. Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
(a) Sagittal slice.
 (b) Coronal slice.
Figure 16: Visual renders of deformations predicted by
Elastix with different regularization weights, on Patient 1.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 17: Visual renders of deformations predicted by
Elastix with different regularization weights, on Patient 2.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 18: Visual renders of deformations predicted by
Elastix with different regularization weights, on Patient 3.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 19: Visual renders of deformations predicted by
Elastix with different regularization weights, on Patient 4. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
C.1.3 Parameter files. Below, we list the parameter files that we
used for the different variants of Elastix registration. Tokens starting
with the $character denote variables that are resolved before we
pass the file to Elastix (e.g., a random seed that we increment at
every repeat).
Listing 1: Forward transform parameters for conventional,
unidirectional deformation.
// ImageTypes
(FixedImagePixelType ""short"")
(FixedImageDimension 3)
(MovingImagePixelType ""short"")
(MovingImageDimension 3)
// Multi resolution
(Registration ""MultiMetricMultiResolutionRegistration"")
(HowToCombineTransforms ""Compose"")
(NumberOfHistogramBins 32)
(NumberOfResolutions 4)
(MaximumNumberOfIterations 10000)
// Optimizer
(Optimizer ""AdaptiveStochasticGradientDescent"")
(AutomaticParameterEstimation ""true"")
(UseAdaptiveStepSizes ""true"")
(CheckNumberOfSamples ""true"")
(UseDirectionCosines ""true"")
(RandomSeed $random_seed)
// Metric
(Metric ""AdvancedMattesMutualInformation""
""TransformBendingEnergyPenalty"")
(Metric0Weight 1.0)
(Metric1Weight $regularization_weight)
// Components
(FixedImagePyramid ""FixedSmoothingImagePyramid"")
(MovingImagePyramid ""MovingSmoothingImagePyramid"")
(Interpolator ""BSplineInterpolator"")
(ResampleInterpolator ""FinalBSplineInterpolator"")
(Resampler ""DefaultResampler"")
(Transform ""BSplineTransform"")
// Transform
(FinalGridSpacingInPhysicalUnits 2.0)
// Sampling
(ImageSampler ""RandomCoordinate"")
(NewSamplesEveryIteration ""true"")
(NumberOfSpatialSamples 20000)
// Interpolation and resampling
(BSplineInterpolationOrder 1)
(FinalBSplineInterpolationOrder 3)
(DefaultPixelValue 0)
// Output and other
(WriteTransformParametersEachIteration ""false"" ""false"" ""false""
""false"" ""false"")
(WriteTransformParametersEachResolution ""true"" ""true"" ""true"" ""true""
""true"")
(ShowExactMetricValue ""false"" ""false"" ""false"" ""false"" ""false"")
(WriteResultImageAfterEachResolution ""false"")
(WriteResultImage ""true"")
(ResultImagePixelType ""short"")
(ResultImageFormat ""nii.gz"")Listing 2: Forward transform parameters for symmetric de-
formation.
// ImageTypes
(FixedImagePixelType ""short"")
(FixedInternalImagePixelType ""short"")
(FixedImageDimension 4)
(MovingImagePixelType ""short"")
(MovingInternalImagePixelType ""short"")
(MovingImageDimension 4)
// Multi resolution
(Registration ""MultiResolutionRegistration"")
(HowToCombineTransforms ""Compose"")
(NumberOfHistogramBins 32)
(NumberOfResolutions 4)
(MaximumNumberOfIterations 10000)
(MaximumNumberOfSamplingAttempts 10)
// Optimizer
(Optimizer ""AdaptiveStochasticGradientDescent"")
(AutomaticParameterEstimation ""true"")
(UseAdaptiveStepSizes ""true"")
(CheckNumberOfSamples ""true"")
(UseDirectionCosines ""true"")
(RandomSeed \$random_seed)
// Metric
(Metric ""$metric"")
(NumEigenValues 1)
(TemplateImage ""ArithmeticAverage"" ""ArithmeticAverage"")
(Combination ""Sum"" ""Sum"")
(SubtractMean ""true"")
(MovingImageDerivativeScales 1.0 1.0 1.0 0.0)
// Components
(FixedImagePyramid ""FixedSmoothingImagePyramid"")
(MovingImagePyramid ""MovingSmoothingImagePyramid"")
(ImagePyramidSchedule 8 8 8 0 4 4 4 0 2 2 2 0 1 1 1 0)
(Interpolator ""ReducedDimensionBSplineInterpolator"")
(ResampleInterpolator ""FinalReducedDimensionBSplineInterpolator"")
(Resampler ""DefaultResampler"")
(Transform ""BSplineStackTransform"")
// Transform
(FinalGridSpacingInPhysicalUnits 2.0)
// Sampling
(ImageSampler ""RandomCoordinate"")
(NewSamplesEveryIteration ""true"")
(NumberOfSpatialSamples 20000)
// Interpolation and resampling
(BSplineTransformSplineOrder 1)
(FinalBSplineInterpolationOrder 3)
(DefaultPixelValue 0)
// Output and other
(WriteTransformParametersEachIteration ""false"" ""false"" ""false""
""false"")
(WriteTransformParametersEachResolution ""true"" ""true"" ""true"" ""true"")
(ShowExactMetricValue ""false"" ""false"" ""false"" ""false"")
(WriteResultImageAfterEachResolution ""false"")
(WriteResultImage ""true"")
(ResultImagePixelType ""short"")
(ResultImageFormat ""nii.gz"") Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
C.2 ANTs SyN
We use ANTs SyN algorithm version 2.4.2. We bootstrap a regis-
tration command using the antsRegistrationSyN.sh script and
customize it to fit our problem (see Section C.2.3 for our run com-
mands). Following official recommendations5, we consider the fol-
lowing settings to be left tunable for this problem: (1) what region
radius to use for the cross correlation metric, (2) whether to use
composite masks as an additional image modality channel during
registration, (3) what gradient step size to use, (4) what regular-
ization weight to assign to local deformations between time steps,
and (5) what regularization weight to assign to the total deforma-
tion. We configure the first four parameters for Patient 1, and then
configure the fifth parameter for each patient, separately.
In our setup, we relaxed convergence limits compared to guide-
lines to allow for longer, and hopefully more accurate registration.
In terms of metrics, we do not use the point set registration metric
that is mentioned in the manual, as the manual states that this
metric is not currently supported in ANTs SyN.
We encountered that ANTs SyN random seed does not have any
effect on the outcome of registration with the Cross Correlation
(CC) measure, even with a random sampling strategy. The current
version seems fully deterministic, but without taking the random
seed into account, therefore always producing the same output,
regardless of the seed. This is problematic, since we would like to
get multiple outputs that expose how the registration approach
reacts to slightly varying inputs. To mitigate the lack of control on
the determinism of the registration, we slightly perturb the sigma
smoothing factors (see Listing 3) with very small (deterministically
random) deltas. Î”3is normally distributed and capped between
[âˆ’0.1,0.1],Î”2between[âˆ’0.05,0.05], andÎ”1between[âˆ’0.01,0.01].
C.2.1 Coarse-grained configuration experiments. We conduct an
initial set of coarse-grained configuration experiments on Patient 1
with the ANTs SyN algorithm. The officially recommended set-
tings serve as our baseline: a cross-correlation radius of 4 voxels,
a gradient step size of 0.1, registration of only the image itself (no
additional channels), and an update regularization weight of 3.0.
For each of these settings, we experiment with different deviations
from the baseline.
Cross correlation radius First, we investigate the impact of a different
cross correlation radius. Larger values should improve registration
accuracy, since more context information is taken into account
when computing the cross correlation of a sample. Figure 20 con-
firms this expectation, although it shows little impact overall. Most
organs show little deviation in score, but the anal canal is registered
more accurately in terms of Dice score when the radius is increased.
We observe that there are diminishing returns here, e.g., a change
of radius from 7 to 8 provides only marginal improvement. Still, we
decide to use the largest setting tested (8 voxels, meaning 12 mm
in the case of the clinical problems), since this setting provides
the best outcome and there is no time limit on registration in our
study. The visual render in Figure 21 shows the visual impact of
this setting, which can be described as limited.
5https://github.com/ANTsX/ANTs/wiki/Anatomy-of-an-antsRegistration-call
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 20: Comparison of registrations with different region
radii for the ANTs cross correlation metric. The baseline
score after rigid registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 21: Visual renders of deformations predicted by ANT
configurations with different CC radii.
Composite mask channel Second, we explore the effect of including
a composite mask image channel during registration. Figure 22 configurations with different CC radii.
Composite mask channel Second, we explore the effect of including
a composite mask image channel during registration. Figure 22
provides evidence that including a mask channel has added value in
terms of Dice score for registration of all organs. The difference in
performance is only slightly visible in Figure 23, but the difference
in metric values motivates our decision to use a mask channel in
the upcoming patient-specific configuration steps.
Gradient step size Third, we examine the impact of using a different
gradient step size on the registration performance of ANTs. A MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 22: Comparison of registrations with and without a
composite mask channel in ANTs. The baseline score after
rigid registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 23: Visual renders of deformations predicted by ANT
configurations with and without a composite mask channel.
larger step size between time points in ANTsâ€™ registration could
lead to larger deformations becoming feasible, since optimization
is less likely to get stuck in local minima. Figure 24 indicates that
choosing a larger step size than the recommended value of 0.1 can
be beneficial, with 1.0 providing a good trade-off for different organs.
Larger step sizes such as 5.0 cause the algorithm to overshoot the
target and strongly deform a number of organs, as can be seen in
the contour renders (Figure 25). We choose a gradient step size of
1.0 for its good trade-off between performance targets.
Update regularization weight Finally, we use the deduced settings
from the previous three sweeps to test which update regularization
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 24: Comparison of ANTs registrations with different
gradient step sizes between time points. The baseline score
after rigid registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 25: Visual renders of deformations predicted by ANT
configurations with different gradient step sizes.
weight performs best. Figure 26 shows best overall performance
for 4.0, in both metrics. Visually, Figure 27 indicates that weights
4.0 and 5.0 lead to the best registration outcomes, with little visible
difference between the two. Based on visual and quantitative results,
we choose an update regularization weight of 4.0 for the patient-
specific configuration experiments.
C.2.2 Fine-grained configuration experiments per patient. We try
exponentially increasing total regularization weights for all prob-
lem instances. Figures 28 and 29 plot the Dice scores and Hausdorff
95th percentiles for each problem instance, and Figures 30â€“33 show Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 26: Comparison of ANTs registrations with differ-
ent update regularization weights between time points. The
baseline score after rigid registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 27: Visual renders of deformations predicted by ANT
configurations with different update regularization weights.
renders of the deformed contours that ANTs predicts for these in-
stances. We observe that regularization has a strong impact on per-
formance in all examined cases, but that often the (relatively) better
outcomes are still acquired without regularization. Figures 30â€“32
show ANTs failing to model the large deformation taking place in
the bladder and its surrounding organs, regardless of the regular-
ization. The Dice and Hausdorff metric results underscore these
observations. In Figure 33, ANTs shows that it can model the blad-
der deformation quite closely, but it should be noted that this is
morphologically also the easiest problem.C.2.3 Run commands. We list the two commands that we used for
registration with ANTs. Tokens starting with the $character denote
variables that are resolved before we execute these commands. Note
that the random seed, even though given to the command, is not
functional and does not change the output.
Listing 3: ANTs registration command for multivariate reg-
istration with composite masks.
$ANTSPATH/antsRegistration
--verbose 1
--random-seed $random_seed
--dimensionality 3
--float 0
--collapse-output-transforms 1
--output [ , Warped.nii.gz, InverseWarped.nii.gz ]
--interpolation Linear
--use-histogram-matching 0
--winsorize-image-intensities [ 0.005, 0.995 ]
--initial-moving-transform [ $fixed_composite_mask,
$moving_composite_mask, 1 ]
--transform SyN[ $gradient_step_size,
$update_regularization_weight,
$total_regularization_weight ]
--metric CC[ $fixed_composite_mask, $moving_composite_mask, 1,
$cross_correlation_radius ]
--metric CC[ $fixed_image, $moving_image, 1,
$cross_correlation_radius ]
--convergence [ 2000x1000x500x250, 1e-6, 10 ]
--shrink-factors 8x4x2x1
--smoothing-sigmas {3+delta_3}x{2+delta_2}x{1+delta_1}x0vox
Listing 4: ANTs registration command for multivariate reg-
istration without composite masks.
$ANTSPATH/antsRegistration
--verbose 1
--random-seed $random_seed
--dimensionality 3
--float 0
--collapse-output-transforms 1
--output [ , Warped.nii.gz, InverseWarped.nii.gz ]
--interpolation Linear
--use-histogram-matching 0
--winsorize-image-intensities [ 0.005, 0.995 ]
--initial-moving-transform [ $fixed_image, $moving_image, 1 ]
--transform SyN[ $gradient_step_size,
$update_regularization_weight,
$total_regularization_weight ]
--metric CC[ $fixed_image, $moving_image, 1,
$cross_correlation_radius ]
--convergence [ 2000x1000x500x250, 1e-6, 10 ]
--shrink-factors 8x4x2x1
--smoothing-sigmas {3+delta_3}x{2+delta_2}x{1+delta_1}x0vox MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
(a) Patient 1.
 (b) Patient 2.
(c) Patient 3.
 (d) Patient 4.
Figure 28: Dice scores for per-patient fine-grained configuration runs in ANTs, with the baseline after rigid registration in
blue.
(a) Patient 1.
 (b) Patient 2.
(c) Patient 3.
 (d) Patient 4.
Figure 29: Hausdorff 95th percentiles for per-patient fine-grained configuration runs in ANTs, with the baseline after rigid
registration in blue. Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
(a) Sagittal slice.
 (b) Coronal slice.
Figure 30: Visual renders of deformations predicted by ANTs
with different total regularization weights, on Patient 1.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 31: Visual renders of deformations predicted by ANTs
with different total regularization weights, on Patient 2.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 32: Visual renders of deformations predicted by ANTs
with different total regularization weights, on Patient 3.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 33: Visual renders of deformations predicted by ANTs
with different total regularization weights, on Patient 4. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
C.3 This Work: MOREA
We describe several coarse-grained configuration experiments that
we conducted with MOREA on Patient 1. The base parameter file
we derived from these experiments can be found in Section C.3.2.
We do not conduct fine-grained configuration steps, since MOREA
is a multi-objective approach.
For MOREAâ€™s guidance objective, we perform an additional pre-
processing step on each scan, to address the discrepancy between
resolutions in different dimensions. The initial resampling step
bringing each scan to a uniform voxel resolution of 1.5 mmleads to
the between-slice dimension being over-sampled (originally, slices
are 3 mm apart). Contour annotations are placed only on slices,
which means that the new slices added by resampling to 1.5 mm,
between original slices, do not have contour information. These
slice â€œgapsâ€ in the contours of objects can be exploited during
optimization. We address this with an intermediate step, building a
3D model of each object across slices and generating border points
from this model.
C.3.1 Coarse-grained configuration experiments.
Heterogeneous elasticity In Section 4.1, we describe a model that
enables capturing biomechanical properties of different tissue types
in the deformation magnitude objective. The core principle of this
biomechanical model is to ascribe heterogeneous elasticities to
different regions of image space, corresponding with objects (e.g.,
organs and bones) present. In this first configuration experiment,
we compare the performance of this model with the performance of
the model which is used by prior work [ 4], assuming homogeneous
elasticity of image space. This experiment was conducted without
a contour on the body, later experiments do have this contour.
The metric results in Figure 34 indicate that the heterogeneous
model generally receives higher Dice scores and similar Hausdorff
95th percentiles. Figure 35 shows renderings of selected solutions
with the heterogeneous and homogeneous models, which confirm
this trend. We observe in both slices that heterogeneous elasticity
especially shows improved performance on the bladder deforma-
tion, potentially due to the increased elasticity that this models
assigns to the bladder.
Mesh generation Using the biomechanical model that experiments
in the previous subsection covered, we now investigate the impact
of different mesh point placement strategies. The strategy used to
create meshes from these points is described in Section 4.2.1.
In this experiment, compare how well a random (Sobol-sequence
based) placement compares to a contour-based strategy where
points are sampled per contour and a contour-based strategy which
has special handling for the bladderâ€™s surface. Figure 36a shows the
bladder being modeled best by the last strategy, with contour-based
strategies in general performing better than random, across organs.
The renders in Figure 37 indicate that a random placement method
can model the general deformation, but is too coarse to accurately
treat details of specific organs and parts of the bones. Both contour-
based strategies perform well, but around the bladderâ€™s surface, the
strategy with special surface constraints excels.
Supplying guidance information The multi-objective line of reg-
istration approaches, which MOREA continues, can have a third
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 34: Comparison of the use of heterogeneous elas-
ticities in the deformation magnitude objective of MOREA
against the prior use of a homogeneous elasticity model, for
multiple runs. The baseline score after rigid registration is
plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 35: Visual renders of deformations predicted by
MOREA with a heterogeneous elastic deformation model
and a homogeneous model.
objective that captures guidance (contour) match. In this experi- Figure 35: Visual renders of deformations predicted by
MOREA with a heterogeneous elastic deformation model
and a homogeneous model.
objective that captures guidance (contour) match. In this experi-
ment, we assess what the impact of this objective is on the quality
of registrations.
The quantitative results in Figure 38 leave little doubt that the
adoption of a guidance objective is crucial to modeling large defor-
mations. Without it, the bladder remains largely in place, as can be
seen in Figure 39. It seems that in this problem, image information
is not sufficient to guide the optimization. Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 36: Comparison of different mesh point placement
strategies, for multiple runs. The baseline score after rigid
registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 37: Visual renders of deformations predicted by
MOREA with different mesh point placement strategies.
(a) Dice scores.
(b) 95th percentiles of the Hausdorff distance.
Figure 38: Comparison of MOREA registrations with and
without guidance information, for multiple runs. The base-
line score after rigid registration is plotted in blue.
(a) Sagittal slice.
 (b) Coronal slice.
Figure 39: Visual renders of deformations predicted by
MOREA with and without guidance enabled. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
C.3.2 Parameter file. We pass parameters to MOREA in a self-
written parameter file format. Below we list the parameter file used
as basis for the experiments listed in this work.
Listing 5: Parameter file used as basis for the main MOREA
experiments.
sweep_descriptor = ""$experiment_descriptor""
num_runs = 5
problem_id = ""$problem_id""
zip = true
problem_guidance_enabled = true
problem_guidance_selection = ""-1""
cuda_compute_level = 80
cuda_gpu_id = 0
ea_num_generations = 500
ea_population_size = 700
ea_num_clusters = 10
ea_archive_size = 2000
ea_adaptive_steering_enabled = true
ea_adaptive_steering_activated_at_num_generations = 100
ea_adaptive_steering_guidance_threshold = 1.5
morea_init_noise_method = ""global-gaussian""
morea_init_noise_factor = 1.0
morea_mesh_generation_method = ""annotation-group-random-bladder-10""
morea_mesh_num_points = 600
morea_max_num_mesh_levels = 1
morea_num_generations_per_level = 0
morea_magnitude_metric = ""biomechanical""
morea_image_metric = ""squared-differences""
morea_guidance_metric = ""continuous-per-group""
morea_sampling_rate = 1.0
morea_fos_type = ""edges""
morea_symmetry_mode = ""transform-both""
morea_dual_dynamic_mode = ""dual""
morea_repair_method = ""gaussian""
morea_ams_strategy = ""none""
morea_num_disruption_kernels = 0
morea_disruption_frequency = 0 Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
D FULL EXPERIMENTAL RESULTS
In this appendix, we list more extensive results of the experiments
presented in Section 6. Figure 40 and 41 give full metric results for all
patients, comparing the three approaches with parallel coordinate
plots. Table 6 lists significance test results for all organ Hausdorff
distances. A visual perspective is provided by Table 8, which shows
an additional slice per patient, overlaid with the predicted deforma-
tions. Below, we analyze convergence behavior (Section D.1) and
landmark performance (Section D.2).
D.1 Convergence Behavior
We plot the convergence behavior of each approach on Patient 1
in Figure 42 to show how each approach has converged before
yielding the results we show here. Elastix and ANTs both have
a multi-resolution approach. To deal with the discontinuities in
multi-stage resolution, we mark resolution switches in those plots
with red vertical lines. Our configuration of Elastix also has a mask
registration step, meaning that there are in total 8 segments (4 reso-
lutions of mask registration and 4 resolutions of image registration).
The scaling of the value to be optimized is not always normalized
across resolutions, which explains the jumps in value ranges be-
tween resolutions. Note that ANTs uses a separate â€œconvergence
valueâ€ to determine when it has converged, plotted in Figure 42d.
For MOREA, we plot the achieved hypervolume and the best guid-
ance objective value achieved. The sudden decrease in hypervolume
at generation 100 is related to the adaptive steering strategy used,
which purges any solutions with unfavorable guidance objective
values from the elitist archive.
D.2 Landmark Accuracy
We list landmark registration accuracy on all 4 patients in Table 7.
We aggregate all errors of all landmarks across repeats for one pa-
tient and approach, and compute the mean and standard deviation
on this sample set. Since these landmarks are generally placed on
visible, anatomically stable locations, and typically not in strongly
deforming regions, this accuracy should be interpreted as a measure
of how well the method preserves certain anatomical structures.
This measure is therefore less suitable as a measure of how well
the registration problem is â€œsolvedâ€, for which visual (DVF and
rendered) inspection is still key. For some landmarks, the precise lo-
cation can be ambiguously defined or less visible on certain patients.
These landmarks are, however, still accurately placeable between
scans by using the visual context they are situated in and taking
consistent placement decisions for each pair of scans.
Generally, we observe that Elastix performs worse than ANTs
and MOREA, and MOREA always improves or roughly maintains
the baseline landmark registration error. We do not see a consis-
tent correlation between actual registration performance on large
deforming objects and target registration error values, due to the
aforementioned reasons.Problem Contour MOREA / Elastix MOREA / ANTs
Patient 1bladder 0.011 (+) 0.007 (+)
bones 0.009 (+) 0.006 (+)
rectum 0.007 (+) 0.007 (+)
anal canal 0.007 (+) 0.007 (+)
sigmoid 0.007 (+) 0.007 (+)
bowel 0.010 (+) 0.011 (+)
body 0.006 (+) 0.006 (-)
Patient 2bladder 0.007 (+) 0.007 (+)
bones 0.007 (+) 0.007 (+)
rectum 0.118 (+) 0.007 (-)
anal canal 0.123 (-) 0.180 (-)
sigmoid 0.007 (+) 0.007 (-)
bowel 0.401 (+) 0.007 (+)
body 0.655 (+) 1.000 (-)
Patient 3bladder 0.012 (+) 0.007 (+)
bones 0.007 (+) 0.007 (+)
rectum 0.290 (+) 0.007 (-)
anal canal 0.118 (-) 0.007 (+)
sigmoid 0.007 (+) 0.007 (+)
bowel 0.007 (+) 0.056 (+)
body 0.007 (+) 0.118 (+)
Patient 4bladder 0.007 (+) 0.195 (-)
bones 0.007 (-) 0.007 (-)
rectum 0.010 (-) 0.007 (-)
anal canal 0.606 (+) 0.007 (-)
sigmoid 0.009 (+) 0.118 (+)
bowel 0.119 (+) 0.119 (-)
body 0.020 (-) 0.020 (-)
Table 6: p-values of pair-wise comparisons of Hausdorff dis-
tances for all contours between approaches, computed by sigmoid 0.009 (+) 0.118 (+)
bowel 0.119 (+) 0.119 (-)
body 0.020 (-) 0.020 (-)
Table 6: p-values of pair-wise comparisons of Hausdorff dis-
tances for all contours between approaches, computed by
the two-sided Mann-Whitney U test. A plus ( +) indicates a
better mean with MOREA, a minus ( -) the opposite. Signifi-
cant results are highlighted according to an ğ›¼of 0.025.
Problem Baseline Elastix ANTs MOREA
Patient 1 4.8 Â±3.1 5.6Â±2.8 4.2Â±2.0 4.8Â±2.0
Patient 2 7.5 Â±4.0 11.8Â±7.3 7.7Â±4.3 7.8Â±3.8
Patient 3 9.5 Â±6.7 6.4Â±2.0 7.7Â±2.6 6.5Â±1.9
Patient 4 14.1 Â±9.5 8.1Â±4.3 6.3Â±3.4 6.8Â±4.0
Table 7: Target registration errors (mean and standard devi-
ation) for the shown registrations of each approach on each
patient, across repeats. All errors are specified in mm. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
Instance Transformed: sagittal Transformed: coronal
Patient 1
Patient 2
Patient 3
Patient 4
Table 8: A selection of the best predicted deformations of the compared registration approaches, represented by deformed
contours compared to the target contours and image. Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
(a) Patient 1.
 (b) Patient 2.
(c) Patient 3.
 (d) Patient 4.
Figure 40: Dice scores for all approaches on all patients. The baseline score after rigid registration is plotted in blue.
(a) Patient 1.
 (b) Patient 2.
(c) Patient 3.
 (d) Patient 4.
Figure 41: Hausdorff distances for all approaches on all patients. The baseline score after rigid registration is plotted in blue. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
0 10000 20000 30000 40000 50000 60000 70000 80000
Iterations2.12.01.91.81.71.61.51.41.31.2Objective value
(a) Elastix: objective value at each iteration.
0 10000 20000 30000 40000 50000 60000 70000 80000
Iterations2.12.01.91.81.71.61.51.4Objective value (b) Elastix: best objective value achieved at each point.
0 10 20 30 40 50 60 70 80
Time steps0.960.940.920.900.880.860.840.820.800.78Objective value
(c) ANTs: objective value at each iteration.
0 10 20 30 40 50 60 70 80
Time steps0.0020.0000.0020.0040.0060.0080.010Convergence value (d) ANTs: convergence measure at each iteration.
0 100 200 300 400 500
Generations1015202530354045Hypervolume
(e) MOREA: hypervolume at each generation.
0 100 200 300 400 500
Generations0.00.10.20.30.40.5Guidance error (f) MOREA: best guidance objective value found at each generation.
Figure 42: Convergence plots for all 3 approaches on one run of Patient 1. Vertical red lines indicate a change of resolution.
For ANTs, this leads to 4 optimization segments. For Elastix, we first run a mask registration step (with 4 segments) and then
an image registration step (with again 4 segments). Georgios Andreadis, Peter A.N. Bosman, and Tanja Alderliesten
REFERENCES
[1]T. Alderliesten, P. A. N. Bosman, and A. Bel. 2015. Getting the most out of
additional guidance information in deformable image registration by leveraging
multi-objective optimization. In SPIE Medical Imaging 2015: Image Processing .
94131R.
[2]T. Alderliesten, J. J. Sonke, and P. A. N. Bosman. 2012. Multi-objective optimization
for deformable image registration: proof of concept. In SPIE Medical Imaging
2012: Image Processing , Vol. 8314. 831420.
[3]T. Alderliesten, J. J. Sonke, and P. A. N. Bosman. 2013. Deformable image reg-
istration by multi-objective optimization using a dual-dynamic transformation
model to account for large anatomical differences. In SPIE Medical Imaging 2013:
Image Processing , Vol. 8669. 866910.
[4]G. Andreadis, P. A. N. Bosman, and T. Alderliesten. 2022. Multi-objective dual
simplex-mesh based deformable image registration for 3D medical images - proof
of concept. In SPIE Medical Imaging 2022: Image Processing . 744â€“750.
[5]B. B. Avants, C. L. Epstein, M. Grossman, and J. C. Gee. 2008. Symmetric dif-
feomorphic image registration with cross-correlation: Evaluating automated
labeling of elderly and neurodegenerative brain. Medical Image Analysis 12, 1
(2008), 26â€“41.
[6]F. Bartel, M. Visser, M. de Ruiter, J. Belderbos, F. Barkhof, H. Vrenken, J. C. de
Munck, and M. van Herk. 2019. Non-linear registration improves statistical power
to detect hippocampal atrophy in aging and dementia. NeuroImage: Clinical 23
(2019), 101902.
[7]D. L. J. Barten, B. R. Pieters, A. Bouter, M. C. van der Meer, S. C. Maree, K. A.
Hinnen, H. Westerveld, P. A. N. Bosman, T. Alderliesten, N. van Wieringen,
and A. Bel. 2023. Towards artificial intelligence-based automated treatment
planning in clinical practice: A prospective study of the first clinical experiences
in high-dose-rate prostate brachytherapy. Brachytherapy In Press (2023).
[8]L. Bondar, M. S. Hoogeman, E. M. VÃ¡squez Osorio, and B. J.M. Heijmen. 2010. A
symmetric nonrigid registration method to handle large organ deformations in
cervical cancer patients. Medical Physics 37, 7 (2010), 3760â€“3772.
[9]P. A. N. Bosman and T. Alderliesten. 2016. Smart grid initialization reduces
the computational complexity of multi-objective image registration based on a
dual-dynamic transformation model to account for large anatomical differences.
InSPIE Medical Imaging 2016: Image Processing . 978447.
[10] A. Bouter, T. Alderliesten, and P. A. N. Bosman. 2017. A novel model-based
evolutionary algorithm for multi-objective deformable image registration with
content mismatch and large deformations: benchmarking efficiency and quality.
InSPIE Medical Imaging 2017: Image Processing , Vol. 10133. 1013312.
[11] A. Bouter, T. Alderliesten, and P. A. N. Bosman. 2021. Achieving highly scal-
able evolutionary real-valued optimization by exploiting partial evaluations.
Evolutionary Computation 29, 1 (2021), 129â€“155.
[12] A. Bouter, T. Alderliesten, and P. A. N. Bosman. 2021. GPU-Accelerated Par-
allel Gene-pool Optimal Mixing applied to Multi-Objective Deformable Image
Registration. In IEEE Congress on Evolutionary Computation . 2539â€“2548.
[13] A. Bouter, T. Alderliesten, B. R. Pieters, A. Bel, Y. Niatsetski, and P. A. N. Bosman.
2019. GPU-accelerated bi-objective treatment planning for prostate high-dose-
rate brachytherapy. Medical Physics 46, 9 (2019), 3776â€“3787.
[14] A. Bouter, N. H. Luong, C. Witteveen, T. Alderliesten, and P. A. N. Bosman. 2017.
The multi-objective real-valued gene-pool optimal mixing evolutionary algorithm.
InProceedings of the 2017 Genetic and Evolutionary Computation Conference . 537â€“
544.
[15] D. BrÃ©laz. 1979. New methods to color the vertices of a graph. Commun. ACM
22, 4 (1979), 251â€“256.
[16] K. K. Brock, S. Mutic, T. R. McNutt, H. Li, and M. L. Kessler. 2017. Use of image
registration and fusion algorithms and techniques in radiotherapy: Report of 22, 4 (1979), 251â€“256.
[16] K. K. Brock, S. Mutic, T. R. McNutt, H. Li, and M. L. Kessler. 2017. Use of image
registration and fusion algorithms and techniques in radiotherapy: Report of
the AAPM Radiation Therapy Committee Task Group No. 132: Report. Medical
Physics 44, 7 (2017), e43â€“e76.
[17] K. K. Brock, M. B. Sharpe, L. A. Dawson, S. M. Kim, and D. A. Jaffray. 2005. Accu-
racy of finite element model-based multi-organ deformable image registration.
Medical Physics 32, 6 (2005), 1647â€“1659.
[18] H. Chui and A. Rangarajan. 2000. A new algorithm for non-rigid point matching.
InIEEE Conference on Computer Vision and Pattern Recognition . 44â€“51.
[19] K. Deb. 2001. Multi-Objective Optimization using Evolutionary Algorithms . Wiley.
[20] B. Eiben, V. Vavourakis, J. H. Hipwell, S. Kabus, T. Buelow, C. Lorenz, T.
Mertzanidou, S. Reis, N. R. Williams, M. Keshtgar, and D. J. Hawkes. 2016. Symmet-
ric Biomechanically Guided Prone-to-Supine Breast Image Registration. Annals
of Biomedical Engineering 44, 1 (2016), 154â€“173.
[21] C. Ericson. 2004. Real-time collision detection (1 ed.). CRC Press.
[22] M. Faisal Beg, M. I. Miller, A. TrouvÃ©trouv, and L. Younes. 2005. Computing
Large Deformation Metric Mappings via Geodesic Flows of Diffeomorphisms.
International Journal of Computer Vision 61, 2 (2005), 139â€“157.
[23] B. Fischer and J. Modersitzki. 2008. Ill-posed medicine - An introduction to image
registration. Inverse Problems 24, 3 (2008), 1â€“16.
[24] J. Gascon, J. M. Espadero, A. G. Perez, R. Torres, and M. A. Otaduy. 2013. Fast
deformation of volume data using tetrahedral mesh rasterization. In Proceed-
ings - SCA 2013: 12th ACM SIGGRAPH / Eurographics Symposium on ComputerAnimation . 181â€“186.
[25] S. Hang. 2015. TetGen, a Delaunay-Based Quality Tetrahedral Mesh Generator.
ACM Trans. Math. Software 41, 2 (2015), 1â€“36.
[26] F. Khalifa, G. M. Beache, G. Gimelâ€™farb, J. S. Suri, and A. S. El-Baz. 2011. State-of-
the-Art Medical Image Registration Methodologies: A Survey. In Multi Modal-
ity State-of-the-Art Medical Image Segmentation and Registration Methodologies .
Springer, 235â€“280.
[27] A. Klein, J. Andersson, B. A. Ardekani, J. Ashburner, B. Avants, M. C. Chiang,
G. E. Christensen, D. L. Collins, J. Gee, P. Hellier, J. H. Song, M. Jenkinson, C.
Lepage, D. Rueckert, P. Thompson, T. Vercauteren, R. P. Woods, J. J. Mann, and
R. V. Parsey. 2009. Evaluation of 14 nonlinear deformation algorithms applied to
human brain MRI registration. NeuroImage 46, 3 (2009), 786â€“802.
[28] S. Klein, M. Staring, K. Murphy, M. A. Viergever, and J. P.W. Pluim. 2010. Elastix:
A toolbox for intensity-based medical image registration. IEEE Transactions on
Medical Imaging 29, 1 (2010), 196â€“205.
[29] M. Li, E. Castillo, X. L. Zheng, H. Y. Luo, R. Castillo, Y. Wu, and T. Guerrero. 2013.
Modeling lung deformation: A combined deformable image registration method
with spatially varying Youngâ€™s modulus estimates. Medical Physics 40, 8 (2013),
1â€“10.
[30] G. Loi, M. Fusella, E. Lanzi, E. Cagni, C. Garibaldi, G. Iacoviello, F. Lucio, E.
Menghi, R. Miceli, L. C. Orlandini, Antonella Roggio, Federica Rosica, Michele
Stasi, Lidia Strigari, Silvia Strolin, and Christian Fiandra. 2018. Performance
of commercially available deformable image registration platforms for contour
propagation using patient-based computational phantoms: A multi-institutional
study. Medical Physics 45, 2 (2018), 748â€“757.
[31] H. N. Luong and P. A. N. Bosman. 2012. Elitist Archiving for Multi-Objective
Evolutionary Algorithms: To Adapt or Not to Adapt. In Proceedings of the 12th
Conference on Parallel Problem Solving from Nature . 72â€“81.
[32] H. Maaranen, K. Miettinen, and A. Penttinen. 2007. On initial populations of
a genetic algorithm for continuous optimization problems. Journal of Global
Optimization 37, 3 (2007), 405â€“436.
[33] R. Mohammadi, S. R. Mahdavi, R. Jaberi, Z. Siavashpour, L. Janani, A. S. Meigooni,
and R. Reiazi. 2019. Evaluation of deformable image registration algorithm for [33] R. Mohammadi, S. R. Mahdavi, R. Jaberi, Z. Siavashpour, L. Janani, A. S. Meigooni,
and R. Reiazi. 2019. Evaluation of deformable image registration algorithm for
determination of accumulated dose for brachytherapy of cervical cancer patients.
Journal of Contemporary Brachytherapy 11, 5 (2019), 469â€“478.
[34] S. Nithiananthan, S. Schafer, D. J. Mirota, J. W. Stayman, W. Zbijewski, D. D. Reh,
G. L. Gallia, and J. H. Siewerdsen. 2012. Extra-dimensional Demons: A method for
incorporating missing tissue in deformable image registration. Medical Physics
39, 9 (2012), 5718â€“5731.
[35] D. F. Pace, M. Niethammer, and S. R. Aylward. 2012. Sliding Geometries in De-
formable Image Registration. In International MICCAI Workshop on Computational
and Clinical Challenges in Abdominal Imaging . 141â€“148.
[36] K. Pirpinia, P. A. N. Bosman, C. E. Loo, G. Winter-Warnars, N. N. Y. Janssen, A. N.
Scholten, J. J. Sonke, M. van Herk, and T. Alderliesten. 2017. The feasibility of
manual parameter tuning for deformable breast MR image registration from a
multi-objective optimization perspective. Physics in Medicine and Biology 62, 14
(2017), 5723â€“5743.
[37] B. Rigaud, A. Klopp, S. Vedam, A. Venkatesan, N. Taku, A. Simon, P. Haigron, R.
De Crevoisier, K. K. Brock, and G. Cazoulat. 2019. Deformable image registration
for dose mapping between external beam radiotherapy and brachytherapy images
of cervical cancer. Physics in Medicine and Biology 64, 11 (2019), 115023.
[38] L. Risser, F. X. Vialard, H. Y. Baluwala, and J. A. Schnabel. 2013. Piecewise-
diffeomorphic image registration: Application to the motion estimation between
3D CT lung images with sliding conditions. Medical Image Analysis 17, 2 (2013),
182â€“193.
[39] B. Schaly, J. A. Kempe, G. S. Bauman, J. J. Battista, and J. van Dyk. 2004. Tracking
the dose distribution in radiation therapy by accounting for variable anatomy.
Physics in Medicine and Biology 49, 5 (2004), 791â€“805.
[40] A. Sotiras and N. Paragios. 2012. Deformable Image Registration: A Survey . Tech-
nical Report. Center for Visual Computing, Department of Applied Mathematics,
Ecole Centrale de Paris, Equipe GALEN, INRIA Saclay.
[41] D. Thierens and P. A. N. Bosman. 2011. Optimal mixing evolutionary algorithms.
InProceedings of the 2011 Genetic and Evolutionary Computation Conference .
617â€“624.
[42] J.-P. Thirion. 1998. Image matching as a diffusion process: an analogy with
Maxwellâ€™s Demons. Medical Image Analysis 2, 3 (1998), 243â€“260.
[43] M. Unser, A. Aldroubi, and C. R. Gerfen. 1993. Multiresolution image registra-
tion procedure using spline pyramids. In SPIE Mathematical Imaging: Wavelet
Applications in Signal and Image Processing , Vol. 2034. 160â€“170.
[44] E. M. VÃ¡squez Osorio, M. S. Hoogeman, L. Bondar, P. C. Levendag, and B. J. M.
Heijmen. 2009. A novel flexible framework with automatic feature correspon-
dence optimization for nonrigid registration in radiotherapy. Medical Physics 36,
7 (2009), 2848â€“2859.
[45] O. Weistrand and S. Svensson. 2015. The ANACONDA algorithm for deformable
image registration in radiotherapy. Medical Physics 42, 1 (2015), 40â€“53.
[46] S. Wognum, L. Bondar, A. G. Zolnay, X. Chai, M. C. C. M. Hulshof, M. S. Hoogeman,
and A. Bel. 2013. Control over structure-specific flexibility improves anatomical
accuracy for point-based deformable registration in bladder cancer radiotherapy. MOREA: a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images
Medical Physics 40, 2 (2013), 1â€“15.
[47] W. Zhang, Y. Ma, J. Zheng, and W. J. Allen. 2020. Tetrahedral mesh deformation
with positional constraints. Computer Aided Geometric Design 81 (2020), 1â€“16.[48] H. Zhong, J. Kim, H. Li, T. Nurushev, B. Movsas, and I. J. Chetty. 2012. A finite
element method to correct deformable image registration errors in low-contrast
regions. Physics in Medicine and Biology 57, 11 (2012), 3499â€“3515."," This paper presents MOREA, a GPU-accelerated Evolutionary Algorithm for Multi-Objective Deformable Registration of 3D Medical Images. Experiments on 4 cervical cancer patient scans show that MOREA outperforms two state-of-the-art approaches in terms of contour registration accuracy. Additionally, the paper introduces a fold detection method, a radial-basis-function approach to introduce large deformations free of mesh folds, and a repair method to reverse folds on a point-by-point basis. Results indicate that the heterogeneous elasticity model generally receives higher Dice scores and similar Hausdorff 95th percentiles, and that contour-based strategies perform better than random mesh point placement."
3," What Performance Indicators to Use for Self-Adaptation in
Multi-Objective Evolutionary Algorithms
Furong Ye
f.ye@liacs.leidenuniv.nl
LIACS, Leiden University
Leiden, NetherlandsFrank Neumann
frank.neumann@adelaide.edu.au
The University of Adelaide
Adelaide, AustraliaJacob de Nobel
j.p.de.nobel@liacs.leidenuniv.nl
LIACS, Leiden University
Leiden, Netherlands
Aneta Neumann
aneta.neumann@adelaide.edu.au
The University of Adelaide
Adelaide, AustraliaThomas BÃ¤ck
T.H.W.Baeck@liacs.leidenuniv.nl
LIACS, Leiden University
Leiden, Netherlands
ABSTRACT
Parameter control has succeeded in accelerating the convergence
process of evolutionary algorithms. Empirical and theoretical stud-
ies for classic pseudo-Boolean problems, such as OneMax ,Leadin-
gOnes , etc., have explained the impact of parameters and helped us
understand the behavior of algorithms for single-objective optimiza-
tion. In this work, by transmitting the techniques of single-objective
optimization, we perform an extensive experimental investigation
into the behavior of the self-adaptive GSEMO variants.
We test three self-adaptive mutation techniques designed for
single-objective optimization for the OneMinMax ,COCZ ,LOTZ ,
andOneJumpZeroJump problems. While adopting these techniques
for the GSEMO algorithm, we consider different performance met-
rics based on the current non-dominated solution set. These metrics
are used to guide the self-adaption process.
Our results indicate the benefits of self-adaptation for the tested
benchmark problems. We reveal that the choice of metrics signifi-
cantly affects the performance of the self-adaptive algorithms. The
self-adaptation methods based on the progress in one objective
can perform better than the methods using multi-objective met-
rics such as hypervolume, inverted generational distance, and the
number of the obtained Pareto solutions. Moreover, we find that
the self-adaptive methods benefit from the large population size
forOneMinMax andCOCZ .
KEYWORDS
Multi-objective evolutionary algorithm, self-adaptation, mutation,
performance metric
ACM Reference Format:
Furong Ye, Frank Neumann, Jacob de Nobel, Aneta Neumann, and Thomas
BÃ¤ck. 2023. What Performance Indicators to Use for Self-Adaptation in
Multi-Objective Evolutionary Algorithms . In Genetic and Evolutionary
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
GECCO â€™23, July 15â€“19, 2023, Lisbon, Portugal
Â©2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN xxx. . . $15.00
https://doi.org/xxxComputation Conference (GECCO â€™23), July 15â€“19, 2023, Lisbon, Portugal.
ACM, New York, NY, USA, 9 pages. https://doi.org/xxx
1 INTRODUCTION
Evolutionary algorithms (EAs) are capable of finding global optima
by creating offspring solutions via global search variators. Apart
from the guarantee of reaching a global optimum, a major concern
in designing algorithms is the convergence rate, as we can not
afford infinite running time in real-world applications. The study
of parameter control is essential in this, in order to understand the
relation between variator parameters and the dynamic behavior of
algorithms. For example, in the context of single-objective pseudo-
boolean optimization ğ‘“:{0,1}ğ‘›â†’R, the mutation of EAs creates
offspringğ‘¦by flipping 0<â„“â‰¤ğ‘›bits of the parent solution ğ‘¥,
whereâ„“can be sampled from different distributions depending on
the design of mutation operators. Previous studies [ 2,3,5,10] have offspringğ‘¦by flipping 0<â„“â‰¤ğ‘›bits of the parent solution ğ‘¥,
whereâ„“can be sampled from different distributions depending on
the design of mutation operators. Previous studies [ 2,3,5,10] have
demonstrated the impact of the choice of â„“onOneMax ,Leadin-
gOnes , and other classic problems, and self-adaptive methods have
been proven to have higher convergence rates than the ones with
static settings.
While there have been detailed studies for single-objective prob-
lems, detailed investigations complement existing theoretical stud-
ies for multi-objective benchmark problems that are missing in the
literature. In the area of runtime analysis, the most basic multi-
objective benchmark problems that have been studied in a rigor-
ous way are LOTZ ,COCZ , and OneMinMax . Furthermore, One-
JumpZeroJump has recently been introduced as a multi-modal multi-
objective benchmark problem. Investigations in the area of runtime
analysis have been started by [ 15]. In this work, the authors stud-
ied a variant of the simple evolutionary multi-objective optimizer
(SEMO) which produces an offspring by flipping a single bit and
always maintaining a set of non-dominated trade-offs according to
the given objective functions. Runtime bounds of Î˜(ğ‘›3)for LOTZ
andğ‘‚(ğ‘›2logğ‘›)for COCZ have been shown in [ 15].OneMinMax
has been investigated in [ 4,13,16] and it has been shown that
the global simple evolutionary multi-objective optimizer (GSEMO),
which differs from SEMO by apply standard bit mutations instead of
single bit flips, computes the whole Pareto front for OneMinMax in
expected time ğ‘‚(ğ‘›2logğ‘›). Furthermore, hypervolume-based evolu-
tionary algorithms have been studied for OneMinMax in [4,16] and
the computation of structural diverse populations has been investi-
gated in [ 4]. In [ 17], different parent selection methods have beenarXiv:2303.04611v1  [cs.NE]  8 Mar 2023 GECCO â€™23, July 15â€“19, 2023, Lisbon, Portugal Furong Ye, Frank Neumann, Jacob de Nobel, Aneta Neumann, and Thomas BÃ¤ck
analyzed for OneMinMax andLOTZ and their benefit has been
shown when incorporated into GSEMO. Recently, OneMinMax
has also been used to study the runtime behavior of the NSGA-II
algorithm [ 22]. All the bounds obtained are asymptotic ones, i.e.
they are missing the leading constants. Therefore, it is interesting
to carry out more detailed experimental investigations of simple
evolutionary multi-objective algorithms from the area of runtime
analysis alongside some variations such as different mutation oper-
ators and the use of larger offspring population sizes. We carry out
such experimental investigations in this work with the hope that
it provides complementary insights that enable further progress
in the theoretical understanding of evolutionary multi-objective
optimization.
In this work, we analyze several variation operators that flip â„“
randomly selected distinct bits and study the impact of â„“for multi-
objective evolutionary algorithms (MOEAs). More precisely, we
equip GSEMO with several self-adaptive mutation operators and
investigate its performance for OneMinMax ,LOTZ ,COCZ , and
OneJumpZeroJump . Based on the experimental results, we study
the impact of the number of offspring (i.e., population size ğœ†) for the
self-adaptive GSEMO variants. Moreover, we investigate the impact
of the metrics used to guide self-adaptation. For the single-objective
optimization problems, each solution maps to a fitness function
valueğ‘“, which self-adaptive EAs can use directly as a performance
indicator to guide the dynamic parameter control. However, for the
multi-objective optimization problems ğ‘“:{0,1}ğ‘›â†’Rğ‘š, where
ğ‘šis the number of the objectives (note that we consider only bi-
objectives in this work), each solution maps to a set of objective
function values, which renders the choice of the appropriate per-
formance indicator to guide adaptation less obvious. Since MOEAs
usually maintain a set of non-dominated solutions, we can use a
metricğ‘’(ğ‘¥):ğ‘¥â†’Rto calculate the relative improvement gain
from a solution ğ‘¥with the non-dominated set, which can be used
to apply the single-objective techniques to MOEAs.
Overall, this paper performs an extensive experimental investi-
gation on GSEMO variants, addressing whether self-adaptive muta-
tion can benefit MOEAs. In practice, this involves the translation of
self-adaptive mutation mechanisms of single-objective optimization
algorithms to MOEAs. Empirical analysis is conducted to illustrate
the behavior of self-adaptive mutation for MOEAs, focusing on
two principal factors, population size, and performance indicator.
We hope the presented results can inspire future theoretical under-
standing of self-adaptation MOEAs. Moreover, such fundamental
analysis of the classic problems can provide guidelines for designing
MOEAs in practical applications.
2 PRELIMINARIES
2.1 Benchmark Problems
As discussed in the Introduction section, the motivation of this
work is to perform empirical analyses and investigate the behav-
ior of MOEAs. Therefore, 4classic multi-objective optimization
problems that attracted many runtime analysis studies are selected
for benchmarking. The problem definitions are provided in the
following.2.1.1 OneMinMax .OneMinMax introduced in [ 13] is a bi-objective
pseudo-Boolean optimization problem that generalizes the classical
single-objective OneMax problem to the bi-objective case:
OneMinMax :{0,1}ğ‘›â†’N2,ğ‘¥â†¦â†’ ğ‘›âˆ‘ï¸
ğ‘–=1ğ‘¥ğ‘–,ğ‘›âˆ’ğ‘›âˆ‘ï¸
ğ‘–=1ğ‘¥ğ‘–!
(1)
The problem is maximizing the numbers of both oneandzero bits,
and the objective of maximizing the number of onebits is identical
to the classic pseudo-Boolean optimization problem OneMax :
{0,1}ğ‘›â†’N,ğ‘¥â†¦â†’Ãğ‘›
ğ‘–=1ğ‘¥ğ‘–. For the OneMinMax problem, all
solutions locate at the optimal Parent front, and the goal is to
obtain the complete set of Pareto front {(ğ‘–,ğ‘›âˆ’1)|ğ‘–âˆˆ[0..ğ‘›]}
2.1.2 COCZ ..COCZ [15] is another extension of the OneMax solutions locate at the optimal Parent front, and the goal is to
obtain the complete set of Pareto front {(ğ‘–,ğ‘›âˆ’1)|ğ‘–âˆˆ[0..ğ‘›]}
2.1.2 COCZ ..COCZ [15] is another extension of the OneMax
problem which is called Count Ones Count Zeroes . Its definition is
given below.
COCZ :{0,1}ğ‘›â†’N2,ğ‘¥â†¦â†’Â©Â­
Â«ğ‘›âˆ‘ï¸
ğ‘–=1ğ‘¥ğ‘–,ğ‘›/2âˆ‘ï¸
ğ‘–=1ğ‘¥ğ‘–+ğ‘›âˆ‘ï¸
ğ‘–=ğ‘›/2(1âˆ’ğ‘¥ğ‘–)ÂªÂ®
Â¬(2)
whereğ‘›=2ğ‘˜,ğ‘˜âˆˆN. The Pareto front of COCZ is a setPconsisting
of the solutions with ğ‘›/2ones in the first half of the bit string. The
size ofPisğ‘›/2. Differently from OneMinMax , of which all possible
solutions locate at the Pareto front, many solutions that are strictly
dominated by others exist in the search space of COCZ .
2.1.3 LOTZ .The Leading Ones, Trailing Zeroes (LOTZ ) introduced
in [15] maximizes the numbers of leading onebits and trailing zero
bits, simultaneously. The problem can be defined as
LOTZ :{0,1}ğ‘›â†’N2,ğ‘¥â†¦â†’Â©Â­
Â«ğ‘›âˆ‘ï¸
ğ‘–=1ğ‘–Ã–
ğ‘—=1ğ‘¥ğ‘—,ğ‘›âˆ‘ï¸
ğ‘–=1ğ‘›Ã–
ğ‘—=ğ‘–(1âˆ’ğ‘¥ğ‘—)ÂªÂ®
Â¬(3)
The Pareto front of LOTZ is{(ğ‘–,ğ‘›âˆ’ğ‘–âˆ’1)|ğ‘–âˆˆ[1..ğ‘›âˆ’2]}âˆª{(ğ‘–,ğ‘›âˆ’ğ‘–)|
ğ‘–âˆˆ {0,ğ‘›}}, given by the set of ğ‘›+1solutionsğ‘¥={1ğ‘–0(ğ‘›âˆ’ğ‘–)|
ğ‘–âˆˆ[0..ğ‘›]}. One property of LOTZ is that for all non-dominated
solutions, the neighbors that are with 1Hamming distance are
either better or worse but incomparable.
2.1.4 OneJumpZeroJump .TheOneJumpZeroJump problem, which
was originally proposed in [ 7], obtains objectives that are isomor-
phic to the classic single-objective problem Jumpğ‘˜:{0,1}ğ‘›â†’
N.Jumpğ‘˜(ğ‘¥)=ğ‘›+|ğ‘¥|1if|ğ‘¥|1âˆˆ[0..ğ‘›âˆ’ğ‘˜]âˆª{ğ‘›}, and Jumpğ‘˜(ğ‘¥)=
ğ‘›âˆ’|ğ‘¥|1otherwise , where|ğ‘¥|ğ‘–=Ãğ‘›
ğ‘–=0ğ‘¥ğ‘–andğ‘˜â‰¥2is a given
parameter. OneJumpZeroJump is defined as
OneJumpZeroJump ğ‘˜:{0,1}ğ‘›â†’N2,ğ‘¥â†¦â†’(ğ‘¦1,ğ‘¦2),
ğ‘¦1=ğ‘˜+|ğ‘¥|1if|ğ‘¥|1â‰¤ğ‘›âˆ’ğ‘˜orğ‘¥=1ğ‘›,otherwiseğ‘›âˆ’|ğ‘¥|1,
ğ‘¦2=ğ‘˜+|ğ‘¥|0if|ğ‘¥|0â‰¤ğ‘›âˆ’ğ‘˜orğ‘¥=0ğ‘›,otherwiseğ‘›âˆ’|ğ‘¥|0(4)
The Pareto front of OneJumpZeroJump is{(ğ‘,2ğ‘˜+ğ‘›âˆ’ğ‘)|ğ‘âˆˆ
[2ğ‘˜,ğ‘›]âˆª{ğ‘˜,ğ‘›+ğ‘˜}}. We setğ‘˜=2for the experiments in this work.
OneJumpZeroJump is a multimodal problem obtaining a valley of
low fitness values in the search space, and the size of this valley
depends on ğ‘˜.
2.2 The GSEMO Algorithm
The simple evolutionary multi-objective optimizer (SEMO) [ 15]
uses a population ğ‘ƒof solutions that do not dominate each other. What Performance Indicators to Use for Self-Adaptation in Multi-Objective Evolutionary Algorithms GECCO â€™23, July 15â€“19, 2023, Lisbon, Portugal
The population is initialized with a random solution. Then, the
algorithm creates offspring by selecting a solution ğ‘¥fromğ‘ƒuni-
formly at random (u.a.r.) and flipping one bit of ğ‘¥. If any solutions
ofğ‘ƒthat are dominated by ğ‘¥, those solutions will be removed, and
ğ‘¥will be added to ğ‘ƒ. The algorithm terminates until reaching ter-
minate conditions, e.g., the budget is used out, or the full Parent
front is reached. Global SEMO (GSEMO) [ 12] differs from SEMO by
applying the standard bit mutation instead of flipping exact one-bit
while creating offspring. As shown in Algorithm 1, GSEMO applies
the standard bit mutation forcing to flip at least one bit each time.
More precisely, â„“is sampled for a conditional binomial distribution
Bin>0(ğ‘›,ğ‘)following the suggestion in [ 18], and offspring is cre-
ated by flipâ„“(ğ‘¥)flippingâ„“bits chosen u.a.r. of ğ‘¥. For the comparison
to the self-adaption methods, we denote the static GSEMO using
ğ‘=1/ğ‘›.
Algorithm 1: Global SEMO
1Input: mutation rate ğ‘=1/ğ‘›;
2Initialization: Sampleğ‘¥âˆˆ{0,1}ğ‘›uniformly at random
(u.a.r.), and evaluate ğ‘“(ğ‘¥);
3ğ‘ƒâ†{ğ‘¥};
4Optimization: while not stop condition do
5 Selectğ‘¥âˆˆğ´u.a.r.;
6 Sampleâ„“âˆ¼Bin>0(ğ‘›,ğ‘), createğ‘¦â†flipâ„“(ğ‘¥), and
evaluateğ‘“(ğ‘¦);
7 ifthere is noğ‘§âˆˆğ´such thatğ‘¦âª¯ğ‘§then
8ğ´={ğ‘§âˆˆğ´|ğ‘§âª¯Ì¸ğ‘¦}âˆª{ğ‘¦}
3 MULTI-OBJECTIVE SELF-ADAPTATION
3.1 The Self-Adaptive GSEMO Variants
As discussed in previous studies [ 2,3,5,10], the optimal param-
eter settings of EAs can change during the optimization process.
Many empirical and theoretical results [ 3,5,14,21] have shown
that the EAs with self-adaptive mutation can outperform the stan-
dard bit mutation for classical single-objective problems such as
OneMax ,LeadingOnes , and Jump . We expect that GSEMO can
benefit from using self-adaptation of mutation. Moreover, we are
curious whether the self-adaption methods can perform similarly
as in single-objective optimization.
For self-adaption in MOEAs, the (1+(ğœ†,ğœ†))GSEMO was pro-
posed and shown in [ 6] improvements in running time compared
to the classic GSEMO. The algorithm uses the variators of mutation
and crossover with dynamic parameters. Recently, a self-adjusting
GSEMO [ 7], which increases mutation rate after ğ‘‡iterations not
obtaining new non-dominated solutions, was tested for OneJumpZe-
roJump . In this section, we test three GSEMO variants using self-
adaptive mutation that has been studied in much single-objective
benchmarking work [ 8]. The GSEMO variants sample an offspring
population of size ğœ†for each generation, and the sampling distribu-
tions adjust based on the performance ğ‘’(ğ‘¥)of the new solutions.
The procedures of GSEMO variants are introduced below, and we
introduce the design of ğ‘’(ğ‘¥)and study its impact in the later sec-
tions.3.1.1 The two-rate GSEMO. The two-rate EA with self-adaptive
mutation rate was proposed and analyzed in [ 5] for OneMax . It
starts with an initial mutation rate of ğ‘Ÿ/ğ‘›. In each generation, it
samples half offspring using doubled mutation rate and samples
the other half using a half mutation rate. Then the mutation rate
that is used to create the best offspring in this generation has a
higher probability of 3/4to be chosen for the next generation. In
the two-rate GSEMO (see Algorithm 4), we follow the outline of
GSEMO and sample offspring populations using the same mutation
strategy of the two-rate EA. The solutionsâ€™ performance ğ‘’(ğ‘¦)(line
12) is evaluated using the three measures mentioned above.
Algorithm 2: The two-rate GSEMO
1Input: Population size ğœ†,ğ‘Ÿinit;
2Initialization: Sampleğ‘¥âˆˆ{0,1}ğ‘›uniformly at random
(u.a.r.), and evaluate ğ‘“(ğ‘¥);
3ğ‘Ÿâ†ğ‘Ÿinit,ğ‘ƒâ†{ğ‘¥};
4Optimization: while not stop condition do
5 fori = 1,. . . ,ğœ†do
6 Selectğ‘¥âˆˆğ‘ƒu.a.r.;
7 ifğ‘–<âŒŠğœ†/2âŒ‹then
8 Sampleâ„“(ğ‘–)âˆ¼Bin>0(ğ‘›,ğ‘Ÿ/(2ğ‘›))
9 else
10 Sampleâ„“(ğ‘–)âˆ¼Bin>0(ğ‘›,(2ğ‘Ÿ)/ğ‘›),
11 Createğ‘¦(ğ‘–)â†flipâ„“(ğ‘–)(ğ‘¥), and evaluate ğ‘’(ğ‘¦(ğ‘–));
12ğ‘¦(ğ‘–âˆ—)â†arg max{ğ‘’(ğ‘¦(1)),...,ğ‘’(ğ‘¦(ğœ†))}; 6 Selectğ‘¥âˆˆğ‘ƒu.a.r.;
7 ifğ‘–<âŒŠğœ†/2âŒ‹then
8 Sampleâ„“(ğ‘–)âˆ¼Bin>0(ğ‘›,ğ‘Ÿ/(2ğ‘›))
9 else
10 Sampleâ„“(ğ‘–)âˆ¼Bin>0(ğ‘›,(2ğ‘Ÿ)/ğ‘›),
11 Createğ‘¦(ğ‘–)â†flipâ„“(ğ‘–)(ğ‘¥), and evaluate ğ‘’(ğ‘¦(ğ‘–));
12ğ‘¦(ğ‘–âˆ—)â†arg max{ğ‘’(ğ‘¦(1)),...,ğ‘’(ğ‘¦(ğœ†))};
13 ifğ‘–âˆ—<âŒŠğœ†/2âŒ‹thenğ‘ â†3/4elseğ‘ â†1/4;
14 Sampleğ‘âˆˆ[0,1]u.a.r.;
15 ifğ‘â‰¤ğ‘ thenğ‘Ÿâ†max{ğ‘Ÿ/2,1/2}else
ğ‘Ÿâ†min{2ğ‘Ÿ,ğ‘›/4};
16 forğ‘–=1,...,ğœ† do
17 ifthere is noğ‘§âˆˆğ´such thatğ‘¦(ğ‘–)âª¯ğ‘§then
18 ğ´={ğ‘§âˆˆğ´|ğ‘§âª¯Ì¸ğ‘¦(ğ‘–)}âˆª{ğ‘¦(ğ‘–)}
3.1.2 The Log-Normal GSEMO. The logNormal GSEMO applies
the standard bit mutation and adjusts the mutation rate ğ‘using a
log-normal update rule [ 14]. While creating offspring populations,
a new mutation rate ğ‘â€²is sampled as shown in line 7 of Algorithm 3.
This strategy allows the mutation rate to increase and decrease with
identical probabilities. However, the new mutation rate can be any
value around the mean of the sample distribution, which is different
from the two-rate strategy that allows only double and half values.
Moreover, it chooses the ğ‘â€²that is used to create the best solution
as theğ‘for the next generation.
3.1.3 The Variance Controlled GSEMO. The variance-controlled
GSEMO (var-ctrl) applies the normalized bit mutation [ 21] that sam-
plesâ„“from a normal distribution ğ‘(ğ‘Ÿ,ğœ2)(line 6 in Algorithm 4).
Similar to the log-normal GSEMO, it also uses a greedy strategy to
adjustğ‘Ÿ, which is replaced by the value of â„“that creates the best
solution. An advantage of using normal distributions is that we can
control not only the mean of sampled â„“but also its variance. In this GECCO â€™23, July 15â€“19, 2023, Lisbon, Portugal Furong Ye, Frank Neumann, Jacob de Nobel, Aneta Neumann, and Thomas BÃ¤ck
Algorithm 3: The log-normal GSEMO
1Input: Population size ğœ†, mutation rate ğ‘;
2Initialization: Sampleğ‘¥âˆˆ{0,1}ğ‘›uniformly at random
(u.a.r.), and evaluate ğ‘“(ğ‘¥);
3ğ‘ƒâ†{ğ‘¥};
4Optimization: while not stop condition do
5 forğ‘–=1,...,ğœ† do
6 Selectğ‘¥âˆˆğ‘ƒu.a.r.;
7ğ‘(ğ‘–)="," This paper investigates the use of self-adaptive mutation techniques in multi-objective evolutionary algorithms (EAs) to accelerate the convergence process. It tests three self-adaptive mutation techniques on the OneMinMax, COCZ, LOTZ, and OneJumpZeroJump problems, and finds that the choice of performance metrics significantly affects the performance of the self-adaptive algorithms. Additionally, the paper discusses the runtime analysis of the Simple Evolutionary Multi-Objective Optimizer (SEMO) and the Global Simple Evolutionary Multi-Objective Optimizer (GSEMO), and examines the impact of metrics for self-adaptation in the GSEMO algorithm. Results indicate potential benefits of self-adaptive mutation for GSEMO, and that self-adaptive algorithms can benefit from large population sizes."
4," Using Affine Combinations of BBOB Problems for Performance
Assessment
Diederick Vermetten
Leiden Institute for Advanced
Computer Science
Leiden, The Netherlands
d.l.vermetten@liacs.leidenuniv.nlFurong Ye
Leiden Institute for Advanced
Computer Science
Leiden, The Netherlands
f.ye@liacs.leidenuniv.nlCarola Doerr
Sorbonne UniversitÃ©, CNRS, LIP6
Paris, France
Carola.Doerr@lip6.fr
ABSTRACT
Benchmarking plays a major role in the development and analysis
of optimization algorithms. As such, the way in which the used
benchmark problems are defined significantly affects the insights
that can be gained from any given benchmark study. One way
to easily extend the range of available benchmark functions is
through affine combinations between pairs of functions. From the
perspective of landscape analysis, these function combinations
smoothly transition between the two base functions.
In this work, we show how these affine function combinations
can be used to analyze the behavior of optimization algorithms. In
particular, we highlight that by varying the weighting between the
combined problems, we can gain insights into the effects of added
global structure on the performance of optimization algorithms. By
analyzing performance trajectories on more function combinations,
we also show that aspects such as the scaling of objective functions
and placement of the optimum can greatly impact how these results
are interpreted.
KEYWORDS
Black-box Optimization, Benchmarking, Performance Analysis
1 INTRODUCTION
Benchmarking is a key aspect in the development of optimization
algorithms. Not only are benchmark problems used to compare the
effectiveness of different optimizers with regard to a standardized
set of problems, the analysis of algorithm behavior on these prob-
lems is often used to gain insight into the characteristics of the
algorithm. Because of this, the design of benchmark problems has
a major impact on the field of optimization as a whole [1].
One of the most common benchmark suites in single-objective,
continuous, noiseless optimization is fittingly called Black Box Op-
timization Benchmark (BBOB) [ 7]. This suite is part of the COCO
framework [ 6], which has seen significant adoption in the last
decade. This suite consists of 24 problems, each defined to repre-
sent a set of global landscape properties. For each of these problems,
many different instances can be created through a set of transfor-
mations, allowing researchers to test different invariances of their
algorithm. Because of its popularity, studies into the specifics of
the BBOB suite are numerous [13, 16, 17].
One particularly popular method to investigate continuous opti-
mization problems is Exploratory Landscape Analysis (ELA) [ 15].
This technique aims to characterize the low-level landscape proper-
ties through a large set of features. Applying this to the BBOB suite
shows that instances of the 24 functions generally group together,
with separation between functions being relatively robust [ 20].This observation raised the question of how the spaces between
problems could be explored.
In a recent study, affine combinations between pairs of BBOB
problems were proposed and analyzed using ELA [ 4]. The resulting
analysis shows that varying the weight of these combinations has a
relatively smooth impact on the landscape features. As such, these
new functions could potentially be used to study the transition
between different landscapes, which opens up a more in-depth
analysis of the relation between landscapes and algorithm behavior.
To investigate to what extent the affine function combinations
can be used to study algorithmic behavior, we perform a bench-
marking study through which we investigate the effect of the affine
combinations on the performance of five numerical black-box opti-
mization algorithms. We make use of function combinations which
include a sphere model to show the impact of added global structure combinations on the performance of five numerical black-box opti-
mization algorithms. We make use of function combinations which
include a sphere model to show the impact of added global structure
on the relative ranking between algorithms. Additionally, we show
that by combining functions with different global properties we
donâ€™t always obtain smooth transitions in performance. We pro-
vide examples where the combination of two functions can either
be significantly more challenging or slightly easier than the base
functions it consists of.
2 RELATED WORK
2.1 BBOB Problem Suite
Within continuous optimization benchmarking, one of the most
popular suites of benchmarks is the BBOB family, which has been
designed as part of the COCO framework. The noiseless, single-
objective suite consists of 24 problems, each of which can be in-
stantiated with a set of different transformations. These function
instances aim to preserve the global function properties while vary-
ing factors such as the location of the global optimum, such that an
optimizer can not directly exploit these aspects. However, the exact
influence these transformations have on the low-level landscape
properties is not as straightforward, which can lead to noticeable
differences in algorithm behavior on different instances of the same
function [13].
2.2 Affine Function Combinations
While using function instances allows the BBOB suite to cover a
wider range of problem landscapes than the raw functions alone,
there are limits to the types of landscapes which can be created in
this way. Recently, it has been proposed to use affine combinations
between pairs of BBOB functions to generate new benchmark func-
tions [ 4]. These combinations have been shown to smoothly fill the
space of low-level landscape properties, as measured through a set
of ELA features. These results have shown that even a relatively
1arXiv:2303.04573v1  [cs.NE]  8 Mar 2023 Diederick Vermetten, Furong Ye, and Carola Doerr
simple function creation procedure has the potential to give us new
insights into the way function landscapes work.
3 EXPERIMENTAL SETUP
In this work, we make use of a slightly modified version of the
affine function combinations from [ 4]. In particular, we define the
combination between two functions from the BBOB suite as follows:
ğ¶(ğ¹1,ğ¼1,ğ¹2,ğ¼2,ğ›¼)(ğ‘¥)=
exp
ğ›¼log"," This paper examines the use of affine combinations of BBOB problems for performance assessment. It investigates the effect of the affine combinations on the performance of five numerical black-box optimization algorithms, and explores the potential of a modified version of affine function combinations to give new insights into the way function landscapes work. It also reviews various methods for comparing continuous optimizers in a black-box setting, and presents the IEEE Symposium Series on Computational Intelligence (SSCI) 2021, BIAS: A Toolbox for Benchmarking Structural Bias in the Continuous Domain (Vermetten et al., 2022), Reproducibility files and additional figures (Vermetten et al., 2023), and IOHanalyzer: Detailed Performance Analysis for Iterative Optimization Heuristic (Wang et al., 2022)."
5," arXiv:2303.04347v1  [cs.NE]  8 Mar 2023Published as a conference paper at ICLR 2022
OPTIMAL ANN-SNN C ONVERSION FOR HIGH-
ACCURACY AND ULTRA -LOW -LATENCY SPIKING
NEURAL NETWORKS
Tong Bu1, Wei Fang1, Jianhao Ding1, PengLin Dai2, Zhaofei Yu1 *, Tiejun Huang1
1Peking University,2Southwest Jiaotong University
*Corresponding author: yuzf12@pku.edu.cn
ABSTRACT
Spiking Neural Networks (SNNs) have gained great attractio n due to their dis-
tinctive properties of low power consumption and fast infer ence on neuromorphic
hardware. As the most effective method to get deep SNNs, ANN- SNN conversion
has achieved comparable performance as ANNs on large-scale datasets. Despite
this, it requires long time-steps to match the ï¬ring rates of SNNs to the activation
of ANNs. As a result, the converted SNN suffers severe perfor mance degradation
problems with short time-steps, which hamper the practical application of SNNs.
In this paper, we theoretically analyze ANN-SNN conversion error and derive the
estimated activation function of SNNs. Then we propose the q uantization clip-
ï¬‚oor-shift activation function to replace the ReLU activat ion function in source
ANNs, which can better approximate the activation function of SNNs. We prove
that the expected conversion error between SNNs and ANNs is z ero, enabling us
to achieve high-accuracy and ultra-low-latency SNNs. We ev aluate our method
on CIFAR-10/100 and ImageNet datasets, and show that it outp erforms the state-
of-the-art ANN-SNN and directly trained SNNs in both accura cy and time-steps.
To the best of our knowledge, this is the ï¬rst time to explore h igh-performance
ANN-SNN conversion with ultra-low latency (4 time-steps). Code is available at
https://github.com/putshua/SNN conversion QCFS
1 I NTRODUCTION
Spiking neural networks (SNNs) are biologically plausible neural networks based on the dynamic
characteristic of biological neurons (McCulloch & Pitts, 1 943; Izhikevich, 2003). As the third gener-
ation of artiï¬cial neural networks (Maass, 1997), SNNs have attracted great attention due to their dis-
tinctive properties over deep analog neural networks (ANNs ) (Roy et al., 2019). Each neuron trans-
mits discrete spikes to convey information when exceeding a threshold. For most SNNs, the spiking
neurons will accumulate the current of the last layer as the o utput within Tinference time steps.
The binarized activation has rendered dedicated hardware o f neuromorphic computing (Pei et al.,
2019; DeBole et al., 2019; Davies et al., 2018). This kind of h ardware has excellent advantages in
temporal resolution and energy budget. Existing work has sh own the potential of tremendous energy
saving with considerably fast inference (StÂ¨ ockl & Maass, 2 021).
In addition to efï¬ciency advantages, the learning algorith m of SNNs has been improved by leaps
and bounds in recent years. The performance of SNNs trained b y backpropagation through time
and ANN-SNN conversion techniques has gradually been compa rable to ANNs on large-scale
datasets (Fang et al., 2021; Rueckauer et al., 2017). Both te chniques beneï¬t from the setting of
SNN inference time. Setting longer time-steps in backpropa gation can make the gradient of surro-
gate functions more reliable (Wu et al., 2018; Neftci et al., 2019; Zenke & V ogels, 2021). However,
the price is enormous resource consumption during training . Existing platforms such as TensorFlow
and PyTorch based on CUDA have limited optimization for SNN t raining. In contrast, ANN-SNN
conversion usually depends on a longer inference time to get comparable accuracy as the original
ANN (Sengupta et al., 2019) because it is based on the equival ence of ReLU activation and integrate-
and-ï¬re modelâ€™s ï¬ring rate (Cao et al., 2015). Although long er inference time can further reduce the
conversion error, it also hampers the practical applicatio n of SNNs on neuromorphic chips.
1 Published as a conference paper at ICLR 2022
The dilemma of ANN-SNN conversion is that there exists a rema ining potential in the conver-
sion theory, which is hard to be eliminated in a few time steps (Rueckauer et al., 2016). Although
many methods have been proposed to improve the conversion ac curacy, such as weight normaliza-
tion (Diehl et al., 2015), threshold rescaling (Sengupta et al., 2019), soft-reset (Han & Roy, 2020)
and threshold shift (Deng & Gu, 2020), tens to hundreds of tim e-steps in the baseline works are still
unbearable. To obtain high-performance SNNs with ultra-lo w latency (e.g., 4 time-steps), we list the
critical errors in ANN-SNN conversion and provide solution s for each error. Our main contributions
are summarized as follows:
â€¢ We go deeper into the errors in the ANN-SNN conversion and as cribe them to clipping
error, quantization error, and unevenness error. We ï¬nd tha t unevenness error, which is
caused by the changes in the timing of arrival spikes and has b een neglected in previous
works, can induce more spikes or fewer spikes as expected.
â€¢ We propose the quantization clip-ï¬‚oor-shift activation f unction to replace the ReLU activa-
tion function in source ANNs, which better approximates the activation function of SNNs.
We prove that the expected conversion error between SNNs and ANNs is zero, indicating
that we can achieve high-performance converted SNN at ultra -low time-steps.
â€¢ We evaluate our method on CIFAR-10, CIFAR-100, and ImageNe t datasets. Compared
with both ANN-SNN conversion and backpropagation training methods, the proposed
method exceeds state-of-the-art accuracy with fewer time- steps. For example, we reach
top-1 accuracy 91.18% on CIFAR-10 with unprecedented 2 time -steps.
2 PRELIMINARIES
In this section, we ï¬rst brieï¬‚y review the neuron models for S NNs and ANNs. Then we introduce
the basic framework for ANN-SNN conversion.
Neuron model for ANNs. For ANNs, the computations of analog neurons can be simpliï¬e d as the
combination of a linear transformation and a non-linear map ping:
al=h(Wlalâˆ’1), l= 1,2,...,M (1)
where the vector aldenotes the output of all neurons in l-th layer, Wldenotes the weight matrix
between layer land layer lâˆ’1, andh(Â·)is the ReLU activation function.
Neuron model for SNNs. Similar to the previous works (Cao et al., 2015; Diehl et al., 2015;
Han et al., 2020), we consider the Integrate-and-Fire (IF) m odel for SNNs. If the IF neurons in
l-th layer receive the input xlâˆ’1(t)from last layer, the temporal potential of the IF neurons can be
deï¬ned as:
ml(t) =vl(tâˆ’1)+Wlxlâˆ’1(t), (2)
whereml(t)andvl(t)represent the membrane potential before and after the trigg er of a spike
at time-step t.Wldenote the weight in l-th layer. As soon as any element ml
i(t)ofml(t)ex-
ceeds the ï¬ring threshold Î¸l, the neuron will elicit a spike and update the membrane poten tialvl
i(t).
To avoid information loss, we use the â€œreset-by-subtractio nâ€ mechanism (Rueckauer et al., 2017;
Han et al., 2020) instead of the â€œreset-to-zeroâ€ mechanism, which means the membrane potential
vl
i(t)is subtracted by the threshold value Î¸lif the neuron ï¬res. Based on the threshold-triggered
ï¬ring mechanism and the â€œreset-by-subtractionâ€ of the memb rane potential after ï¬ring discussed
above, we can write the uplate rule of membrane potential as:
sl(t) =H(ml(t)âˆ’Î¸l), (3)
vl(t) =ml(t)âˆ’sl(t)Î¸l. (4)
Heresl(t)refers to the output spikes of all neurons in layer lat timet, the element of which equals
1 if there is a spike and 0 otherwise. H(Â·)is the Heaviside step function. Î¸lis the vector of the
ï¬ring threshold Î¸l. Similar to Deng & Gu (2020), we suppose that the postsynapti c neuron in l-th
layer receives unweighted postsynaptic potential Î¸lif the presynaptic neuron in lâˆ’1-th layer ï¬res
a spike, that is:
xl(t) =sl(t)Î¸l. (5)
2 Published as a conference paper at ICLR 2022
Table 1: Summary of notations in this paper
Symbol Deï¬nition Symbol Deï¬nition
l Layer index xl(t) Unweighted PSP1
i Neuron index sl(t) Output spikes
WlWeight Ï†l(T) Average unweigthed PSP before time T
alANN activation values zlWeighted input from lâˆ’1layer
t Time-steps h(Â·) ReLU function
T Total time-step H(Â·) Heaviside step function
Î¸lThreshold L Quantization step for ANN
Î»lTrainable threshold in ANN ErrlConversion Error
ml(t) Potential before ï¬ring /tildewidestErrlEstimated conversion Error
vl(t) Potential after ï¬ring Ï• Shift of quantization clip-ï¬‚oor function
1Postsynaptic potential
ANN-SNN conversion. The key idea of ANN-SNN conversion is to map the activation va lue of an
analog neuron in ANN to the ï¬ring rate (or average postsynapt ic potential) of a spiking neuron in
SNN. Speciï¬cally, we can get the potential update equation b y combining Equation 2 â€“ Equation 4:
vl(t)âˆ’vl(tâˆ’1) =Wlxlâˆ’1(t)âˆ’sl(t)Î¸l. (6)
Equation 6 describes the basic function of spiking neurons u sed in ANN-SNN conversion. By
summing Equation 6 from time 1toTand dividing Ton both sides, we have:
vl(T)âˆ’vl(0)
T=Wl/summationtextT
i=1xlâˆ’1(i)
Tâˆ’/summationtextT
i=1sl(i)Î¸l
T. (7)
If we use Ï†lâˆ’1(T) =/summationtextT
i=1xlâˆ’1(i)
Tto denote the average postsynaptic potential during the per iod
from 0 to Tand substitute Equation 5 into Equation 7, then we get:
Ï†l(T) =WlÏ†lâˆ’1(T)âˆ’vl(T)âˆ’vl(0)
T. (8)
Equation 8 describes the relationship of the average postsy naptic potential of neurons in adjacent
layers. Note that Ï†l(T)/greaterorequalslant0. If we set the initial potential vl(0)to zero and neglect the remaining
termvl(T)
Twhen the simulation time-steps Tis long enough, the converted SNN has nearly the
same activation function as source ANN (Equation 1). Howeve r, highTwould cause long inference
latency that hampers the practical application of SNNs. The refore, this paper aims to implement
high-performance ANN-SNN conversion with extremely low la tency.
3 CONVERSION ERROR ANALYSIS
In this section, we will analyze the conversion error betwee n the source ANN and the converted
SNN in each layer in detail. In the following, we assume that b oth ANN and SNN receive the same
input from the layer lâˆ’1, that is, alâˆ’1=Ï†lâˆ’1(T), and then analyze the error in layer l. For
simplicity, we use zl=WlÏ†lâˆ’1(T) =Wlalâˆ’1to substitute the weighted input from layer lâˆ’1
for both ANN and SNN. The absolute conversion error is exactl y the outputs from converted SNN
subtract the outputs from ANN:
Errl=Ï†l(T)âˆ’al=zlâˆ’vl(T)âˆ’vl(0)
Tâˆ’h(zl), (9)
whereh(zl) =ReLU(zl). It can be found from Equation 9 that the conversion error is n onzero if
vl(T)âˆ’vl(0)/negationslash= 0andzl>0. In fact, the conversion error is caused by three factors.
Clipping error. The output Ï†l(T)of SNNs is in the range of [0,Î¸l]asÏ†l(T) =/summationtextT
i=1xl(i)
T=
/summationtextT
i=1sl(i)
TÎ¸l(see Equation 5). However, the output alof ANNs is in a much lager range of [0,al
max],
whereal
max denotes the maximum value of al. As illustrated in Figure 1a, alcan be mapped to
Ï†l(T)by the following equation:
Ï†l(T) =clip/parenleftbiggÎ¸l
T/floorleftbiggalT
Î»l/floorrightbigg
,0,Î¸l/parenrightbigg
. (10)
3 Published as a conference paper at ICLR 2022
 
clipped

(a) Clipping error/uni00000013 /uni00000014 /uni00000015 /uni00000016 /uni00000017 /uni00000018
/uni00000037/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053Slâˆ’ 1
2 Slâˆ’ 1
1/uni00000010/uni00000017/uni00000010/uni00000015/uni00000013/uni00000015/uni00000017/uni00000033/uni00000052/uni00000057/uni00000048/uni00000051/uni00000057/uni0000004c/uni00000044/uni0000004fSl
1
(b) Even spikes/uni00000013 /uni00000014 /uni00000015 /uni00000016 /uni00000017 /uni00000018
/uni00000037/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053Slâˆ’ 1
2 Slâˆ’ 1
1/uni00000010/uni00000017/uni00000010/uni00000015/uni00000013/uni00000015/uni00000017/uni00000033/uni00000052/uni00000057/uni00000048/uni00000051/uni00000057/uni0000004c/uni00000044/uni0000004fSl
1
(c) More spikes/uni00000013 /uni00000014 /uni00000015 /uni00000016 /uni00000017 /uni00000018
/uni00000037/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053Slâˆ’ 1
2 Slâˆ’ 1
1/uni00000010/uni00000017/uni00000010/uni00000015/uni00000013/uni00000015/uni00000017/uni00000033/uni00000052/uni00000057/uni00000048/uni00000051/uni00000057/uni0000004c/uni00000044/uni0000004fSl
1
(d) Fewer spikes
Figure 1: Conversion error between source ANN and converted SNN.slâˆ’1
1andslâˆ’1
2denote the
output spikes of two neurons in layer lâˆ’1, andsl
1denotes the output spikes of a neuron in layer l.
Here the clip function sets the upper bound Î¸land the lower bound 0.âŒŠÂ·âŒ‹denotes the ï¬‚oor func-
tion.Î»lrepresents the actual maximum value of output almapped to the maximum value Î¸lof
Ï†l(T). Considering that nearly 99.9% activations of alin ANN are in the range of [0,al
max
3],
Rueckauer et al. (2016) suggested to choose Î»laccording to 99.9% activations. The activations
betweenÎ»landal
maxin ANN are mapped to the same value Î¸lin SNN, which will cause conversion
error called clipping error.
Quantization error (ï¬‚ooring error). The output spikes sl(t)are discrete events, thus Ï†l(T)are
discrete with quantization resolutionÎ¸l
T(see Equation 10). When mapping altoÏ†l(T), there exists
unavoidable quantization error. For example, as illustrat ed in Figure 1a, the activations of ANN in
the range of [Î»l
T,2Î»l
T)are mapped to the same valueÎ¸l
Tof SNN.
Unevenness error. Unevenness error is caused by the unevenness of input spikes . If the timing of
arrival spikes changes, the output ï¬ring rates may change, w hich causes conversion error. There are
two situations: more spikes as expected or fewer spikes as ex pected. To see this, in source ANN,
we suppose that two analog neurons in layer lâˆ’1are connected to an analog neuron in layer l
with weights 2 and -2, and the output vector alâˆ’1of neurons in layer lâˆ’1is[0.6,0.4]. Besides, in
converted SNN, we suppose that the two spiking neurons in lay erlâˆ’1ï¬re 3 spikes and 2 spikes in
5 time-steps (T=5), respectively, and the threshold Î¸lâˆ’1= 1. Thus,Ï†lâˆ’1(T) =/summationtextT
i=1slâˆ’1(i)
TÎ¸lâˆ’1=
[0.6,0.4]. Even though Ï†lâˆ’1(T) =alâˆ’1and the weights are same for the ANN and SNN, Ï†l(T)
can be different from alif the timing of arrival spikes changes. According to Equati on 1, the ANN
outputal=Wlalâˆ’1= [2,âˆ’2][0.6,0.4]T= 0.4. As for SNN, supposing that the threshold Î¸l= 1,
there are three possible output ï¬ring rates, which are illus trated in Figure 1 (b)-(d). If the two
presynaptic neurons ï¬res at t= 1,3,5andt= 2,4(red bars) respectively with weights 2 and -2, the
postsynaptic neuron will ï¬re two spikes at t= 1,3(red bars), and Ï†l(T) =/summationtextT
i=1sl(i)
TÎ¸l= 0.4 =al.
However, if the presynaptic neurons ï¬res at t= 1,2,3andt= 4,5, respectively, the postsynaptic
neuron will ï¬re four spikes at t= 1,2,3,4, andÏ†l(T) = 0.8>al. If the presynaptic neurons ï¬res
att= 3,4,5andt= 1,2, respectively, the postsynaptic neuron will ï¬re only one sp ikes att= 5,
andÏ†l(T) = 0.2<al. att= 3,4,5andt= 1,2, respectively, the postsynaptic neuron will ï¬re only one sp ikes att= 5,
andÏ†l(T) = 0.2<al.
Note that the clipping error and quantization error have bee n proposed in Li et al. (2021). There exist
interdependence between the above three kinds of errors. Sp eciï¬cally, the unevenness error will
degenerate to the quantization error if vl(T)is in the range of [0,Î¸l]. Assuming that the potential
vl(T)falls into [0,Î¸l]will enable us to estimate the activation function of SNNs ig noring the effect
of unevenness error. Therefore, an estimation of the output valueÏ†l(T)in a converted SNN can be
formulated with the combination of clip function and ï¬‚oor fu nction, that is:
Ï†l(T)â‰ˆÎ¸lclip/parenleftbigg1
T/floorleftbiggzlT+vl(0)
Î¸l/floorrightbigg
,0,1/parenrightbigg
. (11)
The detailed derivation is in the Appendix. With the help of t his estimation for the SNN output, the
estimated conversion error /tildewidestErrlcan be derived from Equation 9:
/tildewidestErrl=Î¸lclip/parenleftbigg1
T/floorleftbiggzlT+vl(0)
Î¸l/floorrightbigg
,0,1/parenrightbigg
âˆ’h(zl)â‰ˆErrl. (12)
4 Published as a conference paper at ICLR 2022
/uni00000013/uni00000011/uni00000015/uni00000018 Î»l
/uni00000013/uni00000011/uni00000018 Î»l
/uni00000013/uni00000011/uni0000001a/uni00000018 Î»l
Î»l
zlâˆ’ 0 .125 Î¸l/uni00000013/uni000000030 .125 Î¸l/tildewidest
Errl/uni00000013/uni00000013/uni00000011/uni00000015/uni00000018 Î¸l/uni00000013/uni00000011/uni00000018 Î¸l/uni00000013/uni00000011/uni0000001a/uni00000018 Î¸lÎ¸lÏ†l
( T ) /uni00000003/uni0000003f/uni00000003 al
(a)L=T= 4/uni00000013/uni00000011/uni00000015/uni00000018 Î»l
/uni00000013/uni00000011/uni00000018 Î»l
/uni00000013/uni00000011/uni0000001a/uni00000018 Î»l
Î»l
zlâˆ’ 0 .125 Î¸l/uni00000013/uni000000030 .125 Î¸l/tildewidest
Errl/uni00000013/uni00000013/uni00000011/uni00000015/uni00000018 Î¸l/uni00000013/uni00000011/uni00000018 Î¸l/uni00000013/uni00000011/uni0000001a/uni00000018 Î¸lÎ¸lÏ†l
( T ) /uni00000003/uni0000003f/uni00000003 al
(b)L= 4,T= 8/uni00000013/uni00000011/uni00000015/uni00000018 Î»l
/uni00000013/uni00000011/uni00000018 Î»l
/uni00000013/uni00000011/uni0000001a/uni00000018 Î»l
Î»l
zlâˆ’ 0 .125 Î¸l/uni00000013/uni000000030 .125 Î¸l/tildewidest
Errl/uni00000013/uni00000013/uni00000011/uni00000015/uni00000018 Î¸l/uni00000013/uni00000011/uni00000018 Î¸l/uni00000013/uni00000011/uni0000001a/uni00000018 Î¸lÎ¸lÏ†l
( T ) /uni00000003/uni0000003f/uni00000003 al
(c)L= 4,T= 8,Ï•=0.5
Figure 2: Comparison of SNN output Ï†l(T)and ANN output alwith same input zl
4 O PTIMAL ANN-SNN CONVERSION
4.1 QUANTIZATION CLIP -FLOOR ACTIVATION FUNCTION
According to the conversion error of Equation 12, it is natur al to think that if the commonly used
ReLU activation function h(zl)is substituted by a clip-ï¬‚oor function with a given quantiza tion
stepsL(similar to Equation 11), the conversion error at time-step sT=Lwill be eliminated. Thus
the performance degradation problem at low latency will be s olved. As shown in Equation 13, we
proposed the quantization clip-ï¬‚oor activation function t o train ANNs.
al=Â¯h(zl) =Î»lclip/parenleftbigg1
L/floorleftbiggzlL
Î»l/floorrightbigg
,0,1/parenrightbigg
, (13)
where the hyperparameter Ldenotes quantization steps of ANNs, the trainable Î»ldecides the
maximum value of alin ANNs mapped to the maximum of Ï†l(T)in SNNs. Note that zl=
WlÏ†lâˆ’1(T) =Wlalâˆ’1. With this new activation function, we can prove that the est imated con-
version error between SNNs and ANNs is zero, and we have the fo llowing Theorem.
Theorem 1. An ANN with activation function (13) is converted to an SNN wi th the same weights. If
T=L,Î¸l=Î»l, andvl(0) =0, then:
/tildewidestErrl=Ï†l(T)âˆ’al=0. (14)
Proof. According to Equation 12, and the conditions T=L,Î¸l=Î»l,vl(0) =0, we have /tildewidestErrl=
Ï†l(T)âˆ’al=Î¸lclip/parenleftBig
1
T/floorleftBig
zlT+vl(0)
Î¸l/floorrightBig
,0,1/parenrightBig
âˆ’Î»lclip/parenleftBig
1
L/floorleftBig
zlL
Î»l/floorrightBig
,0,1/parenrightBig
= 0.
Theorem 1 implies that if the time-steps Tof the converted SNN is the same as the quantization
stepsLof the source ANN, the conversion error will be zero. An examp le is illustrated in Figure 2a,
whereT=L= 4,Î¸l=Î»l. The red curve presents the estimated output Ï†l(T)of the converted
SNNs with respective to different input zl, while the green curve represents the out alof the source
ANN with respective to different input zl. As the two curve are the same, the estimated conversion
error/tildewidestErrlis zero. Nevertheless, in practical application, we focus o n the performance of SNNs
at different time-steps. There is no guarantee that the conv ersion error is zero when Tis not equal
toL. As illustrated in Figure 2b, where L= 4 andL= 8, we can ï¬nd the conversion error is
greater than zero for some zl. This error will transmit layer-by-layer and eventually de grading the
accuracy of the converted SNN. One way to solve this problem i s to train multiple source ANNs
with different quantization steps, then convert them to SNN s with different time-steps, but it comes
at a considerable cost. In the next section, we propose the qu antization clip-ï¬‚oor activation function at a considerable cost. In the next section, we propose the qu antization clip-ï¬‚oor activation function
with a shift term to solve this problem. Such an approach can a chieve high accuracy for different
time-steps, without extra computation cost.
4.2 QUANTIZATION CLIP -FLOOR -SHIFT ACTIVATION FUNCTION
We propose the quantization clip-ï¬‚oor-shift activation fu nction to train ANNs.
al=/hatwideh(zl) =Î»lclip/parenleftbigg1
L/floorleftbiggzlL
Î»l+Ï•/floorrightbigg
,0,1/parenrightbigg
. (15)
5 Published as a conference paper at ICLR 2022
Compared with Equation 13, there exists a hyperparameter ve ctorÏ•that controls the shift of the
activation function. When L/negationslash=T, we cannot guarantee the conversion error is 0. However, we
can estimate the expectation of conversion error. Similar t o (Deng & Gu, 2020), we assume that
zl
iis uniformly distributed within intervals [(tâˆ’1)Î»l/T,(t)Î»l/T]and[(lâˆ’1)Î»l/L,(l)Î»l/L]for
t= 1,2,...,T andL= 1,2,...,L , we have the following Theorem.
Theorem 2. An ANN with activation function (15) is converted to an SNN wi th the same weights.
IfÎ¸l=Î»l,vl(0) =Î¸lÏ•, then for arbitrary TandL, the expectation of conversion error reaches 0
when the shift term Ï•in source ANN is1
2.
âˆ€T,LEz/parenleftBig
/tildewidestErrl/parenrightBig/vextendsingle/vextendsingle/vextendsingle
Ï•=1
2=0. (16)
The proof is in the Appendix. Theorem 2 indicates that the shi ft term1
2is able to optimize the
expectation of conversion error. By comparing Figure 2b and Figure 2c, we can ï¬nd that when the
shift term Ï•= 0.5is added, the mean conversion error reaches zero, even thoug hL/negationslash=T. These
results indicate we can achieve high-performance converte d SNN at ultra-low time-steps.
Lis the only undetermined hyperparameter of the quantizatio n clip-ï¬‚oor-shift activation. When
T=L, the conversion error reaches zero. So we naturally think th at the parameter Lshould be set
as small as possible to get better performance at low time-st eps. However, a too low quantization
of the activation function will decrease the model capacity and further lead to accuracy loss when
the time-steps is relatively large. Choosing the proper Lis a trade-off between the accuracy at low
latency and the best accuracy of SNNs. We will further analyz e the effects of quantization steps L
in the experiment section.
4.3 ALGORITHM FOR TRAINING QUANTIZATION CLIP -FLOOR -SHIFT ACTIVATION FUNCTION
Training an ANN with quantization clip-ï¬‚oor-shift activat ion instead of ReLU is also a tough prob-
lem. To direct train the ANN, we use the straight-through est imator (Bengio et al., 2013) for the
derivative of the ï¬‚oor function, that isdâŒŠxâŒ‹
dx= 1. The overall derivation rule is given in Equation 17.
âˆ‚/hatwidehi(zl)
âˆ‚zl
i=/braceleftBigg
1,âˆ’Î»l
2L< zl
i< Î»lâˆ’Î»l
2L
0,otherwise,âˆ‚/hatwidehi(zl)
âˆ‚Î»l=ï£±
ï£´ï£²
ï£´ï£³/hatwidehi(zl)âˆ’zl
i
Î»l,âˆ’Î»l
2L/lessorequalslantzl
i< Î»lâˆ’Î»l
2L
0, zl
i<âˆ’Î»l
2L
1, zl
i/greaterorequalslantÎ»lâˆ’Î»l
2L(17)
Herezl
iis the i-th element of zl. Then we can train the ANN with quantization clip-ï¬‚oor-shif t
activation using Stochastic Gradient Descent algorithm (B ottou, 2012).
5 R ELATED WORK
The study of ANN-SNN conversion is ï¬rst launched by Cao et al. (2015). Then Diehl et al. (2015)
converted a three-layer CNN to an SNN using data-based and mo del-based normalization. To ob-
tain high-performance SNNs for complex datasets and deeper networks, Rueckauer et al. (2016)
and Sengupta et al. (2019) proposed more accurate scaling me thods to normalize weights and scale
thresholds respectively, which were later proved to be equi valent (Ding et al., 2021). Neverthe-
less, the converted deep SNN requires hundreds of time steps to get accurate results due to the
conversion error analyzed in Sec. 3. To address the potentia l information loss, Rueckauer et al.
(2016) and Han et al. (2020) suggested using â€œreset-by-subt ractionâ€ neurons rather than â€œreset-
to-zeroâ€ neurons. Recently, many methods have been propose d to eliminate the conversion
error. Rueckauer et al. (2016) recommended 99.9% percentil e of activations as scale factors,
and Ho & Chang (2020) added the trainable clipping layer. Bes ides, Han et al. (2020) rescaled
the SNN thresholds to avoid the improper activation of spiki ng neurons. Massa et al. (2020) and
Singh et al. (2021) evaluated the performance of converted S NNs on the Loihi Neuromorphic Pro-
cessor. Our work share similarity with Deng & Gu (2020); Li et al. (2021), which also shed light Singh et al. (2021) evaluated the performance of converted S NNs on the Loihi Neuromorphic Pro-
cessor. Our work share similarity with Deng & Gu (2020); Li et al. (2021), which also shed light
on the conversion error. Deng & Gu (2020) minimized the layer -wise error by introducing ex-
tra bias in addition to the converted SNN biases. Li et al. (20 21) further proposed calibration for
weights and biases using quantized ï¬ne-tuning. They got goo d results with 16 and 32 time-steps
6 Published as a conference paper at ICLR 2022
/uni00000015 /uni00000017 /uni0000001b /uni00000014/uni00000019 /uni00000016/uni00000015
/uni00000034/uni00000058/uni00000044/uni00000051/uni00000057/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000056/uni00000057/uni00000048/uni00000053/uni00000003/uni0000002f/uni00000013/uni00000011/uni0000001b/uni00000018/uni00000013/uni00000011/uni0000001c/uni00000013/uni00000011/uni0000001c/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000039/uni0000002a/uni0000002a/uni00000010/uni00000014/uni00000019/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni0000005a/uni00000012/uni00000003/uni00000056/uni0000004b/uni0000004c/uni00000049/uni00000057
/uni0000005a/uni00000012/uni00000052/uni00000003/uni00000056/uni0000004b/uni0000004c/uni00000049/uni00000057
/uni00000015 /uni00000017 /uni0000001b /uni00000014/uni00000019 /uni00000016/uni00000015
/uni00000034/uni00000058/uni00000044/uni00000051/uni00000057/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000056/uni00000057/uni00000048/uni00000053/uni00000003/uni0000002f/uni00000013/uni00000011/uni0000001b/uni00000018/uni00000013/uni00000011/uni0000001c/uni00000013/uni00000011/uni0000001c/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000035/uni00000048/uni00000056/uni00000031/uni00000048/uni00000057/uni00000010/uni00000015/uni00000013/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000015 /uni00000017 /uni0000001b /uni00000014/uni00000019 /uni00000016/uni00000015
/uni00000034/uni00000058/uni00000044/uni00000051/uni00000057/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000056/uni00000057/uni00000048/uni00000053/uni00000003/uni0000002f/uni00000013/uni00000011/uni0000001a/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000046/uni0000000c/uni00000003/uni00000039/uni0000002a/uni0000002a/uni00000010/uni00000014/uni00000019/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000013/uni00000015 /uni00000017 /uni0000001b /uni00000014/uni00000019 /uni00000016/uni00000015
/uni00000034/uni00000058/uni00000044/uni00000051/uni00000057/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000056/uni00000057/uni00000048/uni00000053/uni00000003/uni0000002f/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni00000019/uni00000013/uni00000011/uni00000019/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000047/uni0000000c/uni00000003/uni00000035/uni00000048/uni00000056/uni00000031/uni00000048/uni00000057/uni00000010/uni00000015/uni00000013/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000013
Figure 3: Compare ANNs accuracy.
without trails for more extreme time-steps. In comparison, our work aims to ï¬t ANN into SNN
with techniques eliminating the mentioned conversion erro r. The end-to-end training of quantiza-
tion layers is implemented to get better overall performanc e. Our shift correction can lead to a
single SNN which performs well at both ultra-low and large ti me-steps. Maintaining SNN per- tion layers is implemented to get better overall performanc e. Our shift correction can lead to a
single SNN which performs well at both ultra-low and large ti me-steps. Maintaining SNN per-
formance within extremely few time-steps is difï¬cult even f or supervised learning methods like
backpropagation through time (BPTT). BPTT usually require s fewer time-steps because of thor-
ough training, yet at the cost of heavy GPU computation (Wu et al., 2018; 2019; Lee et al., 2016;
Neftci et al., 2019; Lee et al., 2020; Zenke & V ogels, 2021). T he timing-based backpropagation
methods (Bohte et al., 2002; Tavanaei et al., 2019; Kim et al. , 2020) could train SNNs over a very
short temporal window, e.g. over 5-10 time-steps. However, they are usually limited to sim-
ple datasets like MNIST (Kheradpisheh & Masquelier, 2020) a nd CIFAR10 (Zhang & Li, 2020).
Rathi et al. (2019) shortened simulation steps by initializ ing SNN with conversion method and then
tuning SNN with STDP. In this paper, the proposed method achi eves high-performance SNNs with
ultra-low latency (4 time-steps).
6 E XPERIMENTS
In this section, we validate the effectiveness of our method and compare our method with other
state-of-the-art approaches for image classiï¬cation task s on CIFAR-10 (LeCun et al., 1998), CIFAR-
100 (Krizhevsky et al., 2009), and ImageNet datasets (Deng e t al., 2009). Similar to previous works,
we utilize VGG-16 (Simonyan & Zisserman, 2014), ResNet-18 ( He et al., 2016), and ResNet-20
network structures for source ANNs. We compare our method wi th the state-of-the-art ANN-
SNN conversion methods, including Hybrid-Conversion (HC) from Rathi et al. (2019), RMP from
Han et al. (2020), TSC from Han & Roy (2020), RNL from Ding et al . (2021), ReLUThreshold-
Shift (RTS) from Deng & Gu (2020), and SNN Conversion with Adv anced Pipeline (SNNC-AP)
from Li et al. (2021). Comparison with different SNN trainin g methods is also included to mani-
fest the superiority of low latency inference, including Hy bridConversion-STDB (HC-STDB) from
Rathi et al. (2019), STBP from Wu et al. (2018), DirectTraini ng (DT) from Wu et al. (2019), and
TSSL from Zhang & Li (2020). The details of the proposed ANN-S NN algorithm and training con-
ï¬gurations are provided in the Appendix.
6.1 T EST ACCURACY OF ANN WITH QUANTIZATION CLIP -FLOOR -SHIFT ACTIVATION
We ï¬rst compare the performance of ANNs with quantization cl ip-ï¬‚oor activation (green curve),
ANNs with quantization clip-ï¬‚oor-shift activation (blue c urve), and original ANNs with ReLU acti-
vation (black dotted line). Figure 3(a)-(d) report the resu lts about VGG-16 on CIFAR-10, ResNet-20
on CIFAR-10, VGG-16 on CIFAR-100 and ResNet-20 on CIFAR-100 . The performance of ANNs
with quantization clip-ï¬‚oor-shift activation is better th an ANNs with quantization clip-ï¬‚oor activa-
tion. These two ANNs can achieve the same performance as orig inal ANNs with ReLU activation
whenL >4. These results demonstrate that our quantization clip-ï¬‚oo r-shift activation function
hardly affects the performance of ANN.
6.2 C OMPARISON WITH THE STATE -OF-THE-ART
Table 2 compares our method with the state-of-the-art ANN-S NN conversion methods on CIFAR-
10. As for low latency inference (T â‰¤64), our model outperforms all the other methods with the
same time-step setting. For T = 32 , the accuracy of our method is slightly better than that of AN N
(95.54% vs. 95.52%), whereas RMP, RTS, RNL, and SNNC-AP meth ods have accuracy loss of
33.3%, 19.48%, 7.42%, and 2.01%. Moreover, we achieve an acc uracy of 93.96% using only 4
time-steps, which is 8 times faster than SNNC-AP that takes 3 2 time-steps. For ResNet-20, we
achieve an accuracy of 83.75% with 4 time-steps. Notably, ou r ultra-low latency performance is
7 Published as a conference paper at ICLR 2022
/uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015/uni00000019/uni00000017/uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000013/uni00000011/uni0000001c/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000039/uni0000002a/uni0000002a/uni00000010/uni00000014/uni00000019/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni0000005a/uni00000012/uni00000003/uni00000056/uni0000004b/uni0000004c/uni00000049/uni00000057
/uni0000005a/uni00000012/uni00000052/uni00000003/uni00000056/uni0000004b/uni0000004c/uni00000049/uni00000057
/uni00000014 /uni00000015 /uni00000017 /uni0000001b /uni00000014/uni00000019 /uni00000016/uni00000015 /uni00000019/uni00000017 /uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000013/uni00000011/uni0000001c/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000035/uni00000048/uni00000056/uni00000031/uni00000048/uni00000057/uni00000010/uni00000015/uni00000013/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015/uni00000019/uni00000017/uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000046/uni0000000c/uni00000003/uni00000039/uni0000002a/uni0000002a/uni00000010/uni00000014/uni00000019/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000013/uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015/uni00000019/uni00000017/uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c /uni0000000b/uni00000047/uni0000000c/uni00000003/uni00000035/uni00000048/uni00000056/uni00000031/uni00000048/uni00000057/uni00000010/uni00000015/uni00000013/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000013
Figure 4: Compare quantization clip-ï¬‚oor activation with/ without shift term
Table 2: Comparison between the proposed method and previou s works on CIFAR-10 dataset.
Architecture Method ANN T=2 T=4 T=8 T=16 T=32 T=64 T â‰¥512
VGG-16RMP 93.63% - - - - 60.30% 90.35% 93.63%
TSC 93.63% - - - - - 92.79% 93.63%
RTS 95.72% - - - - 76.24% 90.64% 95.73%
RNL 92.82% - - - 57.90% 85.40% 91.15% 92.95%
SNNC-AP 95.72% - - - - 93.71% 95.14% 95.79%
Ours 95.52% 91.18% 93.96% 94.95% 95.40% 95.54% 95.55% 95.59%
ResNet-20RMP 91.47% - - - - - - 91.36%
TSC 91.47% - - - - - 69.38% 91.42%
Ours 91.77% 73.20% 83.75% 89.55% 91.62% 92.24% 92.35% 92.41%
ResNet-18RTS195.46% - - - - 84.06% 92.48% 94.42%
SNNC-AP195.46% - - - - 94.78% 95.30% 95.45%
Ours 96.04% 75.44% 90.43% 94.82% 95.92% 96.08% 96.06% 96.06%
1RTS and SNNC-AP use altered ResNet-18, while ours use standa rd ResNet-18.
comparable with other state-of-the-art supervised traini ng methods, which is shown in Table S3 of
the Appendix.
We further test the performance of our method on the large-sc ale dataset. Table 3 reports the results
on ImageNet, our method also outperforms the others both in t erms of high accuracy and ultra-low
latency. For ResNet-34, the accuracy of the proposed method is 4.83% higher than SNNC-AP and
69.28% higher than RTS when T= 32 . When the time-steps is 16, we can still achieve an accuracy
of 59.35%. For VGG-16, the accuracy of the proposed method is 4.83% higher than SNNC-AP
and 68.356% higher than RTS when T= 32 . When the time-steps is 16, we can still achieve an
accuracy of 50.97%. These results demonstrate that our meth od outperforms the previous conversion
methods. More experimental results on CIFAR-100 is in Table S4 of the Appendix.
6.3 C OMPARISON OF QUANTIZATION CLIP -FLOOR AND QUANTIZATION CLIP -FLOOR -SHIFT
Here we further compare the performance of SNNs converted fr om ANNs with quantization clip-
ï¬‚oor activation and ANN with quantization clip-ï¬‚oor-shift activation. In Sec. 4, we prove that
the expectation of the conversion error reaches 0 with quant ization clip-ï¬‚oor-shift activation, no
matter whether TandLare the same or not. To verify these, we set Lto 4 and train ANNs with
quantization clip-ï¬‚oor activation and quantization clip- ï¬‚oor-shift activation, respectively. Figure 4
shows how the accuracy of converted SNNs changes with respec t to the time-steps T. The accuracy
of the converted SNN (green curve) from ANN with quantizatio n clip-ï¬‚oor activation (green dotted
line) ï¬rst increases and then decreases rapidly with the inc rease of time-steps, because we cannot
guarantee that the conversion error is zero when Tis not equal to L. The best performance is still
lower than source ANN (green dotted line). In contrast, the a ccuracy of the converted SNN from
ANN with quantization clip-ï¬‚oor-shift activation (blue cu rve) increases with the increase of T. It
gets the same accuracy as source ANN (blue dotted line) when t he time-steps is larger than 16.
6.4 E FFECT OF QUANTIZATION STEPS L
In our method, the quantization steps Lis a hyperparameter, which affects the accuracy of the con-
verted SNN. To analyze the effect of Land better determine the optimal value, we train VGG-
16/ResNet-20 networks with quantization clip-ï¬‚oor-shift activation using different quantization
steps L, including 2,4,8,16 and 32, and then converted them t o SNNs. The experimental results
8 Published as a conference paper at ICLR 2022
/uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015/uni00000019/uni00000017/uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000013/uni00000011/uni0000001c/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000039/uni0000002a/uni0000002a/uni00000010/uni00000014/uni00000019/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni0000002f/uni00000020/uni00000015
/uni0000002f/uni00000020/uni00000017
/uni0000002f/uni00000020/uni0000001b
/uni0000002f/uni00000020/uni00000014/uni00000019
/uni0000002f/uni00000020/uni00000016/uni00000015
/uni00000014 /uni00000015 /uni00000017 /uni0000001b /uni00000014/uni00000019 /uni00000016/uni00000015 /uni00000019/uni00000017 /uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000013/uni00000011/uni0000001c/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000035/uni00000048/uni00000056/uni00000031/uni00000048/uni00000057/uni00000010/uni00000015/uni00000013/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015/uni00000019/uni00000017/uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c
/uni0000000b/uni00000046/uni0000000c/uni00000003/uni00000039/uni0000002a/uni0000002a/uni00000010/uni00000014/uni00000019/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000013/uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015/uni00000019/uni00000017/uni00000014/uni00000015/uni0000001b
/uni00000036/uni0000004c/uni00000050/uni00000058/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000057/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053/uni00000056/uni00000013/uni00000011/uni00000014/uni00000018/uni00000013/uni00000011/uni00000016/uni00000018/uni00000013/uni00000011/uni00000018/uni00000018/uni00000013/uni00000011/uni0000001a/uni00000018/uni00000024/uni00000046/uni00000046/uni00000058/uni00000055/uni00000044/uni00000046/uni0000005c /uni0000000b/uni00000047/uni0000000c/uni00000003/uni00000035/uni00000048/uni00000056/uni00000031/uni00000048/uni00000057/uni00000010/uni00000015/uni00000013/uni00000003/uni00000052/uni00000051/uni00000003/uni00000026/uni0000002c/uni00000029/uni00000024/uni00000035/uni00000010/uni00000014/uni00000013/uni00000013
Figure 5: Inï¬‚uence of different quantization steps
Table 3: Comparison between the proposed method and previou s works on ImageNet dataset.
Architecture Method ANN T=16 T=32 T=64 T=128 T=256 T â‰¥1024
ResNet-34RMP 70.64% - - - - - 65.47%
TSC 70.64% - - - - 61.48% 65.10%
RTS 75.66% - 0.09% 0.12% 3.19% 47.11% 75.08%
SNNC-AP 75.66% - 64.54% 71.12% 73.45% 74.61% 75.45%
Ours 74.32% 59.35% 69.37% 72.35% 73.15% 73.37% 73.39%
VGG-16RMP 73.49% - - - - 48.32% 73.09%
TSC 73.49% - - - - 69.71% 73.46%
RTS 75.36% - 0.114% 0.118% 0.122% 1.81% 73.88%
SNNC-AP 75.36% - 63.64% 70.69% 73.32% 74.23% 75.32%
Ours 74.29% 50.97% 68.47% 72.85% 73.97% 74.22% 74.32%
on CIFAR-10/100 dataset are shown in Table S2 and Figure 5, wh ere the black dotted line denotes
the ANN accuracy and the colored curves represent the accura cy of the converted SNN. In order to
balance the trade-off between low latency and high accuracy , we evaluate the performance of con-
verted SNN mainly in two aspects. First, we focus on the SNN ac curacy at ultra-low latency (within
4 time-steps). Second, we consider the best accuracy of SNN. It is obvious to ï¬nd that the SNN
accuracy at ultra-low latency decreases as Lincreases. However, a too small Lwill decrease the
model capacity and further lead to accuracy loss. When L= 2, there exists a clear gap between the
best accuracy of SNN and source ANN. The best accuracy of SNN a pproaches source ANN when
L >4. In conclusion, the setting of parameter Lmainly depends on the aims for low latency or best
accuracy. The recommend quantization step Lis 4 or 8, which leads to high-performance converted
SNN at both small time-steps and very large time-steps.
7 D ISCUSSION AND CONCLUSION
In this paper, we present ANN-SNN conversion method, enabli ng high-accuracy and ultra-low-
latency deep SNNs. We propose the quantization clip-ï¬‚oor-s hift activation to replace ReLU activa-
tion, which hardly affects the performance of ANNs and is clo ser to SNNs activation. Furthermore,
we prove that the expected conversion error is zero, no matte r whether the time-steps of SNNs and
the quantization steps of ANNs is the same or not. We achieve s tate-of-the-art accuracy with fewer
time-steps on CIFAR-10, CIFAR-100, and ImageNet datasets. Our results can beneï¬t the imple-
mentations on neuromorphic hardware and pave the way for the large-scale application of SNNs.
Different from the work of Deng & Gu (2020), which adds the bia s of the converted SNNs to shift
the theoretical ANN-SNN curve to minimize the quantization error, we add the shift term in the
quantization clip-ï¬‚oor activation function, and use this q uantization clip-ï¬‚oor-shift function to train
the source ANN. We show that the shift term can overcome the pe rformance degradation problem
when the time-steps and the quantization steps are not match ed. Due to the unevenness error, there
still exists a gap between ANN accuracy and SNN accuracy, eve n whenL=T. Moreover, it is hard
to achieve high-performance ANN-SNN conversion when the ti me-steps T= 1. All these problems
deserve further research. One advantage of conversion-bas ed methods is that they can reduce the
overall computing cost while maintaining comparable perfo rmance as source ANN. Combining the
conversion-based methods and model compression may help si gniï¬cantly reduce the neuron activity
9 Published as a conference paper at ICLR 2022
and thus reduce energy consumptions without suffering from accuracy loss (Kundu et al., 2021;
Rathi & Roy, 2021), which is a promising direction.
10 Published as a conference paper at ICLR 2022
ACKNOWLEDGEMENT
This work was supported by the National Natural Science Foun dation of China under contracts
No.62176003 and No.62088102.
REFERENCES
Yoshua Bengio, Nicholas LÂ´ eonard, and Aaron Courville. Est imating or propagating gradients
through stochastic neurons for conditional computation. arXiv preprint arXiv:1308.3432 , 2013.
Sander M Bohte, Joost N Kok, and Han La Poutre. Error-backpro pagation in temporally encoded
networks of spiking neurons. Neurocomputing , 48(1-4):17â€“37, 2002.
LÂ´ eon Bottou. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade , pp. 421â€“
436. Springer, 2012.
Yongqiang Cao, Yang Chen, and Deepak Khosla. Spiking deep co nvolutional neural networks for
energy-efï¬cient object recognition. International Journal of Computer Vision , 113(1):54â€“66,
2015.
Ekin D Cubuk, Barret Zoph, Dandelion Mane, Vijay Vasudevan, and Quoc V Le. Autoaugment:
Learning augmentation strategies from data. In IEEE Conference on Computer Vision and Pattern
Recognition , pp. 113â€“123, 2019.
Mike Davies, Narayan Srinivasa, Tsung-Han Lin, Gautham Chi nya, Yongqiang Cao, Sri Harsha
Choday, Georgios Dimou, Prasad Joshi, Nabil Imam, Shweta Ja in, et al. Loihi: A neuromorphic
manycore processor with on-chip learning. IEEE Micro , 38(1):82â€“99, 2018.
Michael V DeBole, Brian Taba, Arnon Amir, Filipp Akopyan, Al exander Andreopoulos, William P
Risk, Jeff Kusnitz, Carlos Ortega Otero, Tapan K Nayak, Rath inakumar Appuswamy, et al.
TrueNorth: Accelerating from zero to 64 million neurons in 1 0 years. Computer , 52(5):20â€“29,
2019.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li F ei-Fei. Imagenet: A large-scale
hierarchical image database. In IEEE Conference on Computer Vision and Pattern Recognition ,
pp. 248â€“255. Ieee, 2009.
Shikuang Deng and Shi Gu. Optimal conversion of conventiona l artiï¬cial neural networks to spiking
neural networks. In International Conference on Learning Representations , 2020.
Terrance DeVries and Graham W Taylor. Improved regularizat ion of convolutional neural networks
with cutout. arXiv preprint arXiv:1708.04552 , 2017.
Peter U Diehl, Daniel Neil, Jonathan Binas, Matthew Cook, Sh ih-Chii Liu, and Michael Pfeiffer.
Fast-classifying, high-accuracy spiking deep networks th rough weight and threshold balancing.
InInternational Joint Conference on Neural Networks , pp. 1â€“8, 2015.
Jianhao Ding, Zhaofei Yu, Yonghong Tian, and Tiejun Huang. O ptimal ann-snn conversion for fast
and accurate inference in deep spiking neural networks. In International Joint Conference on
Artiï¬cial Intelligence , pp. 2328â€“2336, 2021.
Wei Fang, Zhaofei Yu, Yanqi Chen, Tiejun Huang, TimothÂ´ ee Ma squelier, and Yonghong Tian. Deep
residual learning in spiking neural networks. arXiv preprint arXiv:2102.04159 , 2021.
Bing Han and Kaushik Roy. Deep spiking neural network: Energ y efï¬ciency through time based
coding. In European Conference on Computer Vision , pp. 388â€“404, 2020.
Bing Han, Gopalakrishnan Srinivasan, and Kaushik Roy. RMP- SNN: Residual membrane poten-
tial neuron for enabling deeper high-accuracy and low-late ncy spiking neural network. In IEEE
Conference on Computer Vision and Pattern Recognition , pp. 13558â€“13567, 2020.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep r esidual learning for image recog-
nition. In IEEE conference on Computer Vision and Pattern Recognition , pp. 770â€“778, 2016.
11 Published as a conference paper at ICLR 2022
Nguyen-Dong Ho and Ik-Joon Chang. Tcl: an ann-to-snn conver sion with trainable clipping layers.
arXiv preprint arXiv:2008.04509 , 2020.
Eugene M Izhikevich. Simple model of spiking neurons. IEEE Transactions on neural networks ,
14(6):1569â€“1572, 2003.
Saeed Reza Kheradpisheh and TimothÂ´ ee Masquelier. Tempora l backpropagation for spiking neural
networks with one spike per neuron. International Journal of Neural Systems , 30(06):2050027,
2020.
Jinseok Kim, Kyungsu Kim, and Jae-Joon Kim. Unifying activa tion- and timing-based learning
rules for spiking neural networks. In Advances in Neural Information Processing Systems , pp.
19534â€“19544, 2020.
Alex Krizhevsky, Geoffrey Hinton, et al. Learning multiple layers of features from tiny images.
2009.
Souvik Kundu, Gourav Datta, Massoud Pedram, and Peter A Beer el. Spike-thrift: Towards energy-
efï¬cient deep spiking neural networks by limiting spiking a ctivity via attention-guided compres-
sion. In Proceedings of the IEEE/CVF Winter Conference on Applicati ons of Computer Vision
(WACV) , pp. 3953â€“3962, 2021.
Yann LeCun, LÂ´ eon Bottou, Yoshua Bengio, and Patrick Haffne r. Gradient-based learning applied to
document recognition. Proceedings of the IEEE , 86(11):2278â€“2324, 1998.
Chankyu Lee, Syed Shakib Sarwar, Priyadarshini Panda, Gopa lakrishnan Srinivasan, and Kaushik
Roy. Enabling spike-based backpropagation for training de ep neural network architectures. Fron-
tiers in Neuroscience , 14, 2020.
Jun Haeng Lee, Tobi Delbruck, and Michael Pfeiffer. Trainin g deep spiking neural networks using
backpropagation. Frontiers in Neuroscience , 10:508, 2016.
Yuhang Li, Shikuang Deng, Xin Dong, Ruihao Gong, and Shi Gu. A free lunch from ann: Towards
efï¬cient, accurate spiking neural networks calibration. I nInternational Conference on Machine
Learning , pp. 6316â€“6325, 2021.
Ilya Loshchilov and Frank Hutter. Sgdr: Stochastic gradien t descent with warm restarts. In Interna-
tional Conference on Learning Representations , 2016.
Wolfgang Maass. Networks of spiking neurons: the third gene ration of neural network models.
Neural Networks , 10(9):1659â€“1671, 1997.
Riccardo Massa, Alberto Marchisio, Maurizio Martina, and M uhammad Shaï¬que. An efï¬cient
spiking neural network for recognizing gestures with a DVS c amera on the Loihi neuromorphic
processor. In International Joint Conference on Neural Networks , pp. 1â€“9, 2020.
Warren S McCulloch and Walter Pitts. A logical calculus of th e ideas immanent in nervous activity.
The Bulletin of Mathematical Biophysics , 5(4):115â€“133, 1943.
Paul A Merolla, John V Arthur, Rodrigo Alvarez-Icaza, Andre w S Cassidy, Jun Sawada, Filipp
Akopyan, Bryan L Jackson, Nabil Imam, Chen Guo, Yutaka Nakam ura, et al. A million spiking-
neuron integrated circuit with a scalable communication ne twork and interface. Science , 345
(6197):668â€“673, 2014.
Emre O Neftci, Hesham Mostafa, and Friedemann Zenke. Surrog ate gradient learning in spiking
neural networks: Bringing the power of gradient-based opti mization to spiking neural networks.
IEEE Signal Processing Magazine , 36(6):51â€“63, 2019.
Jing Pei, Lei Deng, Sen Song, Mingguo Zhao, Youhui Zhang, Shu ang Wu, Guanrui Wang, Zhe
Zou, Zhenzhi Wu, Wei He, et al. Towards artiï¬cial general int elligence with hybrid tianjic chip
architecture. Nature , 572(7767):106â€“111, 2019.
Ning Qiao, Hesham Mostafa, Federico Corradi, Marc Osswald, Fabio Stefanini, Dora Sumislawska,
and Giacomo Indiveri. A reconï¬gurable on-line learning spi king neuromorphic processor com-
prising 256 neurons and 128K synapses. Frontiers in neuroscience , 9:141, 2015.
12 Published as a conference paper at ICLR 2022
Nitin Rathi and Kaushik Roy. Diet-snn: A low-latency spikin g neural network with direct input
encoding and leakage and threshold optimization. IEEE Transactions on Neural Networks and
Learning Systems , 2021.
Nitin Rathi, Gopalakrishnan Srinivasan, Priyadarshini Pa nda, and Kaushik Roy. Enabling deep
spiking neural networks with hybrid conversion and spike ti ming dependent backpropagation. In
International Conference on Learning Representations , 2019.
Kaushik Roy, Akhilesh Jaiswal, and Priyadarshini Panda. To wards spike-based machine intelligence
with neuromorphic computing. Nature , 575(7784):607â€“617, 2019.
Bodo Rueckauer, Iulia-Alexandra Lungu, Yuhuang Hu, and Mic hael Pfeiffer. Theory and
tools for the conversion of analog to spiking convolutional neural networks. arXiv preprint
arXiv:1612.04052 , 2016.
Bodo Rueckauer, Iulia-Alexandra Lungu, Yuhuang Hu, Michae l Pfeiffer, and Shih-Chii Liu. Con-
version of continuous-valued deep networks to efï¬cient eve nt-driven networks for image classiï¬-
cation. Frontiers in Neuroscience , 11:682, 2017.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjee v Satheesh, Sean Ma, Zhiheng
Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei.
ImageNet Large Scale Visual Recognition Challenge. International Journal of Computer Vision
(IJCV) , 115(3):211â€“252, 2015. doi: 10.1007/s11263-015-0816-y.
Abhronil Sengupta, Yuting Ye, Robert Wang, Chiao Liu, and Ka ushik Roy. Going deeper in spiking
neural networks: VGG and residual architectures. Frontiers in Neuroscience , 13:95, 2019.
Karen Simonyan and Andrew Zisserman. Very deep convolution al networks for large-scale image
recognition. arXiv preprint arXiv:1409.1556 , 2014.
Sonali Singh, Anup Sarma, Sen Lu, Abhronil Sengupta, Vijayk rishnan Narayanan, and Chita R
Das. Gesture-snn: Co-optimizing accuracy, latency and ene rgy of snns for neuromorphic vision
sensors. In IEEE/ACM International Symposium on Low Power Electronics and Design , pp. 1â€“6,
2021.
Christoph StÂ¨ ockl and Wolfgang Maass. Optimized spiking ne urons can classify images with high
accuracy through temporal coding with two spikes. Nature Machine Intelligence , 3(3):230â€“238,
2021.
Amirhossein Tavanaei, Masoud Ghodrati, Saeed Reza Kheradp isheh, TimothÂ´ ee Masquelier, and
Anthony Maida. Deep learning in spiking neural networks. Neural Networks , 111:47â€“63, 2019.
Yujie Wu, Lei Deng, Guoqi Li, Jun Zhu, and Luping Shi. Spatio- temporal backpropagation for
training high-performance spiking neural networks. Frontiers in Neuroscience , 12:331, 2018.
Yujie Wu, Lei Deng, Guoqi Li, Jun Zhu, Yuan Xie, and Luping Shi . Direct training for spiking
neural networks: Faster, larger, better. In AAAI Conference on Artiï¬cial Intelligence , pp. 1311â€“
1318, 2019.
Friedemann Zenke and Tim P V ogels. The remarkable robustnes s of surrogate gradient learning
for instilling complex function in spiking neural networks .Neural Computation , 33(4):899â€“925,
2021.
Wenrui Zhang and Peng Li. Temporal spike sequence learning v ia backpropagation for deep spiking
neural networks. In Advances in Neural Information Processing Systems , pp. 12022â€“12033, 2020.
13 Published as a conference paper at ICLR 2022
A A PPENDIX
A.1 NETWORK STRUCTURE AND TRAINING CONFIGURATIONS
Before training ANNs, we ï¬rst replace max-pooling with aver age-pooling and then replace the
ReLU activation with the proposed quantization clip-ï¬‚oor- shift activation (Equation 15). After
training, we copy all weights from the source ANN to the conve rted SNN, and set the threshold
Î¸lin each layer of the converted SNN equal to the maximum activa tion value Î»lof the source ANN
in the same layer. Besides, we set the initial membrane poten tialvl(0)in converted SNN as Î¸l/2to
match the optimal shift Ï•=1
2of quantization clip-ï¬‚oor-shift activation in the source A NN.
Despite the common data normalization, we use some data pre- processing techniques. For CIFAR
datasets, we resize the images into 32Ã—32, and for ImageNet dataset, we resize the image into
224Ã—224. Besides, we use random crop images, Cutout (DeVries & Taylo r, 2017) and AutoAug-
ment (Cubuk et al., 2019) for all datasets.
We use the Stochastic Gradient Descent optimizer (Bottou, 2 012) with a momentum parameter of
0.9. The initial learning rate is set to 0.1 for CIFAR-10 and I mageNet, and 0.02 for CIFAR-100. A
cosine decay scheduler (Loshchilov & Hutter, 2016) is used t o adjust the learning rate. We apply a
5Ã—10âˆ’4weight decay for CIFAR datasets while applying a 1Ã—10âˆ’4weight decay for ImageNet.
We train all models for 300 epochs. The quantization steps Lis set to 4 when training all the
networks on CIFAR-10, and VGG-16, ResNet-18 on CIFAR-100 da taset. When training ResNet-20
on CIFAR-100, the parameter Lis set to 8. When training ResNet-34 and VGG-16 on ImageNet,
the parameter Lis set to 8, 16, respectively. We use constant input when eval uating the converted
SNNs.
A.2 I NTRODUCTION OF DATASETS
CIFAR-10. The CIFAR-10 dataset (Krizhevsky et al., 2009) consists of 6 000032Ã—32images in
10 classes. There are 50000 training images and 10000 test im ages.
CIFAR-100. The CIFAR-100 dataset (Krizhevsky et al., 2009) consists of 6000032Ã—32images in
100 classes. There are 50000 training images and 10000 test i mages.
ImageNet. We use the ILSVRC 2012 dataset (Russakovsky et al., 2015), wh ich consists 1,281,167
training images and 50000 testing images.
A.3 D ERIVATION OF EQUATION 12AND PROOF OF THEOREM 2
Derivation of Equation 11
Similar to ,, We deï¬ne
ul(t) =Wlxlâˆ’1(t). (S1)
We useul
i(t)andzl
ito denote the i-th element in vector ul(t)andzl, respectively. To derive
Equation 11, some extra assumptions on the relationship bet ween ANN activation value and SNN
postsynaptic potentials are needed, which are showed in Equ ation S2.
ï£±
ï£²
ï£³ifzl
i<0,thenâˆ€t ul
i(t)<0,
if 0/lessorequalslantzl
i/lessorequalslantÎ¸l,thenâˆ€t0/lessorequalslantul
i(t)/lessorequalslantÎ¸l,
ifzl
i> Î¸l,thenâˆ€t ul
i(t)> Î¸l.(S2)
With the assumption above, we can discuss the ï¬ring behavior of the neurons in each time-step.
Whenzl
i<0orzl
i> Î¸l, the neuron will never ï¬re or ï¬re all the time-steps, which me ansÏ†l
i(T) = 0
orÏ†l
i(T) =Î¸l. In this situation, we can use a clip function to denote Ï†l
i(T).
Ï†l
i(T) = clip(zl
i,0,Î¸l). (S3)
14 Published as a conference paper at ICLR 2022
When0< zl
i< Î¸l, every input from the presynaptic neuron in SNNs falls into [0,Î¸l], then we have
âˆ€t, vl
i(t)âˆˆ[0,Î¸]. We can rewrite Equation 8 into the following equation.
Ï†l
i(T)T
Î¸l=zl
iT+vl
i(0)
Î¸lâˆ’vl
i(T)
Î¸l. (S4)
Considering thatÏ†l
i(T)T
Î¸l=/summationtextT
t=1sl
i(t)âˆˆNand0<vl
i(T)
Î¸l<1, Equation S4 is changed to:
Ï†l
i(T) =Î¸l
T/floorleftbiggzl
iT+vl
i(0)
Î¸l/floorrightbigg
. (S5)
We combine these two situations (Equation S3 and Equation S4 ), and we have:
Ï†l(T) =Î¸lclip/parenleftbigg1
T/floorleftbiggzlT+vl(0)
Î¸l/floorrightbigg
,0,1/parenrightbigg
. (S6)
Proof of Theorem 2
Before prove Theorem 2, we ï¬rst introduce Lemma 1.
Lemma 1. If random variable xâˆˆ[0,Î¸]is uniformly distributed in every small interval [mt,mt+1]
with the probability density function pt(t= 0,1,...,T ), wherem0= 0,mT+1=Î¸,mt=(tâˆ’1
2)Î¸
Tfort= 1,2,...,T ,p0=pT, we can conclude that
Ex/parenleftbigg
xâˆ’Î¸
T/floorleftbiggTx
Î¸+1
2/floorrightbigg/parenrightbigg
= 0. (S7)
Proof.
Ex/parenleftbigg
xâˆ’Î¸
T/floorleftbiggTx
Î¸+1
2/floorrightbigg/parenrightbigg
=/integraldisplayÎ¸/2T
0p0/parenleftbigg
xâˆ’Î¸
T/floorleftbiggxT
Î¸+1
2/floorrightbigg/parenrightbigg
dx
+Tâˆ’1/summationdisplay
t=1/integraldisplay(2t+1)Î¸/2T
(2tâˆ’1)Î¸/2Tpt/parenleftbigg
xâˆ’Î¸
T/floorleftbiggxT
Î¸+1
2/floorrightbigg/parenrightbigg
dx
+/integraldisplayÎ¸
(2Tâˆ’1)Î¸/2TpT/parenleftbigg
xâˆ’Î¸
T/floorleftbiggxT
Î¸+1
2/floorrightbigg/parenrightbigg
dx
=p0/integraldisplayÎ¸/2T
0xdx+Tâˆ’1/summationdisplay
t=1pt/integraldisplay(2t+1)Î¸/2T
(2tâˆ’1)Î¸/2T(xâˆ’tÎ¸
T) dx+pT/integraldisplayÎ¸
(2Tâˆ’1)Î¸/2T(xâˆ’Î¸) dx
=p0Î¸2
8T2+0âˆ’pTÎ¸2
8T2= (p0âˆ’pT)Î¸2
8T2= 0. (S8)
Theorem 2. An ANN with activation function (15) is converted to an SNN wi th the same weights.
IfÎ¸l=Î»l,vl(0) =Î¸lÏ•, then for arbitrary TandL, the expectation of conversion error reaches 0
when the shift term Ï•in source ANN is1
2.
âˆ€T,LEz/parenleftBig
/tildewidestErrl/parenrightBig/vextendsingle/vextendsingle/vextendsingle
Ï•=1
2=0. (S9)
Proof.
Ez/parenleftBig
/tildewidestErrl/parenrightBig/vextendsingle/vextendsingle/vextendsingle
Ï•=1
2=Ez/parenleftbiggÎ¸l
T/floorleftbiggzlT+vl(0)
Î¸l/floorrightbigg
âˆ’Î»l
L/floorleftbiggzlL
Î»+Ï•/floorrightbigg/parenrightbigg
. (S10)
15 Published as a conference paper at ICLR 2022
/uni00000013 /uni00000014 /uni00000015 /uni00000016 /uni00000017 /uni00000018
/uni00000037/uni0000004c/uni00000050/uni00000048/uni00000010/uni00000056/uni00000057/uni00000048/uni00000053Slâˆ’ 1
2 Slâˆ’ 1
1/uni00000010/uni00000017/uni00000010/uni00000015/uni00000013/uni00000015/uni00000017/uni00000033/uni00000052/uni00000057/uni00000048/uni00000051/uni00000057/uni0000004c/uni00000044/uni0000004fSl
1
Figure S1: More spikes than expected exists for the method of setting the maximum activation.
As every element in vector zis identical, we only need to consider one element.
Ezi/parenleftbiggÎ¸l
T/floorleftbiggzl
iT+vl
i(0)
Î¸l/floorrightbigg
âˆ’Î»l
L/floorleftbiggzl
iL
Î»+Ï•i/floorrightbigg/parenrightbigg
=Ezi/parenleftbiggÎ¸l
T/floorleftbiggzl
iT+vl
i(0)
Î¸l/floorrightbigg
âˆ’zl
i/parenrightbigg
+Ezi/parenleftbigg
zl
iâˆ’Î»l
L/floorleftbiggzl
iL
Î»+Ï•i/floorrightbigg/parenrightbigg
. (S11)
According to Lemma 1, we have
Ezi/parenleftbiggÎ¸l
T/floorleftbiggzl
iT+vl
i(0)
Î¸l/floorrightbigg
âˆ’zl
i/parenrightbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle
vl
i(0)=1/2= 0, (S12)
Ezi/parenleftbigg
zl
iâˆ’Î»l
L/floorleftbiggzl
iL
Î»+Ï•i/floorrightbigg/parenrightbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle
Ï•=1/2= 0. (S13)
Thus the sum of both terms also equals zero.
A.4 C OMPARISON OF THE METHODS WITH OR WITHOUT DYNAMIC THRESHOLD O N THE
CIFAR-100 DATASET
In this paper we use a training parameter Î»lto decide the maximum value of ANN activation.
The previous works suggested to set the maximum value of ANN a ctivation after training as the
threshold. If we set Î¸l= max sâˆˆ{0,1}n/parenleftbig
max(Î¸lâˆ’1Wls)/parenrightbig
, the situation of fewer spikes as expected
never happens, as we can prove that vl(T)< Î¸l(see Theorem 3). Despite this, there still exists
the situation of more spikes as expected. An example is given in Figure S1. Here we consider
the same example as in Figure 1. In source ANN, we suppose that two analog neurons in layer
lâˆ’1are connected to an analog neuron in layer lwith weights 2 and -2, and the output vector
alâˆ’1of neurons in layer lâˆ’1is[0.6,0.4]. Besides, in converted SNN, we suppose that the two
spiking neurons in layer lâˆ’1ï¬re 3 spikes and 2 spikes in 5 time-steps (T=5), respectively , and the
threshold Î¸lâˆ’1= 1. Thus,Ï†lâˆ’1(T) =/summationtextT
i=1slâˆ’1(i)
TÎ¸lâˆ’1= [0.6,0.4]. According to Equation 1,
the ANN output al=Wlalâˆ’1= [2,âˆ’2][0.6,0.4]T= 0.4. As for SNN, we suppose that the
presynaptic neurons ï¬res at t= 1,2,3andt= 4,5, respectively. Even through we set the threshold
Î¸l= 1to the maximum activation 2, the postsynaptic neuron will ï¬r e three spikes at t= 1,2,3, and
Ï†l(T) = 0.6>al.
Besides, setting maxsâˆˆ{0,1}n/parenleftbig
max(Î¸lâˆ’1Wls)/parenrightbig
as the threshold brings two other problems. First,
the spiking neurons will take a long time to ï¬re spikes becaus e of the large value of the threshold,
which makes it hard to maintain SNN performance within a few t ime-steps. Second, the quantization
error will be large as it is proportional to the threshold. If the conversion error is not zero for
one layer, it will propagate layer by layer and will be magniï¬ ed by larger quantization errors. We
compare our method and the method of setting the maximum acti vation on the CIFAR-100 dataset.
The results are reported in Table S1, where DT represents the dynamic threshold in our method. The
results show that our method can achieve better performance .
16 Published as a conference paper at ICLR 2022
Table S1: Comparison between our method and the method of set ting the maximum activation.
DT1w/o shift T=4 T=8 T=16 T=32 T=64 T=128 T=256 T â‰¥512
VGG-16 on CIFAR-100 with L=4
/check /check 69.62% 73.96% 76.24% 77.01% 77.10% 77.05% 77.08% 77.08%
/checkÃ— 21.57% 41.13% 58.92% 65.38% 64.19% 58.60% 52.99% 49.41%
Ã—/check 1.00% 0.96% 1.00% 1.10% 2.41% 13.76% 51.70% 77.10%
Ã— Ã— 1.00% 1.00% 0.90% 1.00% 1.01% 2.01% 19.59% 70.86%
1Dynamic threshold.
Theorem 3. If the threshold is set to the maximum value of ANN activation , that is Î¸l=
maxsâˆˆ{0,1}n/parenleftbig
max(Î¸lâˆ’1Wls)/parenrightbig
,andvl
i(0)< Î¸l.Then at any time-step, the membrane potential
of each neuron after spike vl
i(t)will be less than Î¸l, whereirepresents the index of each neuron.
Proof. We prove it by induction. For t= 0, it is easy to see vl
i(0)< Î¸l. Fort >0, we suppose
thatvl
i(tâˆ’1)< Î¸l. Since we have set the threshold to the maximum possible inpu t, andxlâˆ’1
i(t)
represents the input from layer lâˆ’1to thei-th neuron in layer l,xlâˆ’1
i(t)will be no larger than Î¸l
for arbitrary t. Thus we have
ml
i(t) =vl
i(tâˆ’1)+xlâˆ’1
i(t)< Î¸l+Î¸l= 2Î¸l, (S14)
sl
i(t) =H(ml
i(t)âˆ’Î¸l), (S15)
vl
i(t) =ml
i(t)âˆ’sl
i(t)Î¸l. (S16)
IfÎ¸l/lessorequalslantml
i(t)<2Î¸l, then we have vl
i(t) =ml
i(t)âˆ’Î¸l< Î¸l. Ifml
i(t)< Î¸l, thenvl
i(t) =ml
i(t)< Î¸l.
By mathematical induction, vl
i(t)< Î¸lholds for any t/greaterorequalslant0.
A.5 E FFECT OF QUANTIZATION STEPS L
Table S2 reports the performance of converted SNNs with diff erent quantization steps Land differ-
ent time-steps T. For VGG-16 and quantization steps L= 2, we achieve an accuracy of 86.53% on
CIFAR-10 dataset and an accuracy of 61.41% on CIFAR-100 data set with 1 time-steps. When the
quantization steps L= 1, we cannot train the source ANN.
A.6 C OMPARISON WITH STATE -OF-THE-ART SUPERVISED TRAINING METHODS ON
CIFAR-10 DATASET
Notably, our ultra-low latency performance is comparable w ith other state-of-the-art supervised
training methods. Table S3 reports the results of hybrid tra ining and backpropagation methods
on CIFAR-10. The backpropagation methods require sufï¬cien t time-steps to convey discriminate
information. Thus, the list methods need at least 5 time-ste ps to achieveâˆ¼91% accuracy. On the
contrary, our method can achieve 94.73% accuracy with 4 time -steps. Besides, the hybrid training
method requires 200 time-steps to obtain 92.02% accuracy be cause of further training with STDB,
whereas our method achieves 93.96% accuracy with 4 time-ste ps.
A.7 C OMPARISON ON CIFAR-100 DATASET
Table S4 reports the results on CIFAR-100, our method also ou tperforms the others both in terms of
high accuracy and ultra-low latency. For VGG-16, the accura cy of the proposed method is 3.46%
higher than SNNC-AP and 69.37% higher than RTS when T= 32 . When the time-steps is only 4,
we can still achieve an accuracy of 69.62%. These results dem onstrate that our method outperforms
the previous conversion methods.
17 Published as a conference paper at ICLR 2022
Table S2: Inï¬‚uence of different quantization steps.
quantization
steps T=1 T=2 T=4 T=8 T=16 T=32 T=64 T=128
VGG-16 on CIFAR-10
L=2 86.53% 91.98% 93.00% 93.95% 94.18% 94.22% 94.18% 94.14%
L=4 88.41% 91.18% 93.96% 94.95% 95.40% 95.54% 95.55% 95.59%
L=8 62.89% 83.93% 91.77% 94.45% 95.22% 95.56% 95.74% 95.79%
L=16 61.48% 76.76% 89.61% 93.03% 93.95% 94.24% 94.25% 94.22 %
L=32 13.05% 73.33% 89.67% 94.13% 95.31% 95.66% 95.73% 95.77 %
ResNet-20 on CIFAR-10
L=2 77.54% 82.12% 85.77% 88.04% 88.64% 88.79% 88.85% 88.76%
L=4 62.43% 73.2% 83.75% 89.55% 91.62% 92.24% 92.35% 92.35%
L=8 46.19% 58.67% 75.70% 87.79% 92.14% 93.04% 93.34% 93.24%
L=16 30.96% 39.87% 57.04% 79.5% 90.87% 93.25% 93.44% 93.48%
L=32 22.15% 27.83% 43.56% 70.15% 88.81% 92.97% 93.48% 93.48 %
VGG-16 on CIFAR-100
L=2 61.41% 64.96% 68.0% 70.72% 71.87% 72.28% 72.35% 72.4%
L=4 57.5% 63.79% 69.62% 73.96% 76.24% 77.01% 77.1% 77.05%
L=8 44.98% 52.46% 62.09% 70.71% 74.83% 76.41% 76.73% 76.73%
L=16 33.12% 41.71% 53.38% 65.76% 72.80% 75.6% 76.37% 76.36%
L=32 15.18% 21.41% 32.21% 50.46% 67.32% 74.6% 76.18% 76.24%
ResNet-20 on CIFAR-100
L=2 38.65% 47.35% 55.23% 59.69% 61.29% 61.5% 61.03% 60.81%
L=4 25.62% 36.33% 51.55% 63.14% 66.70% 67.47% 67.47% 67.41%
L=8 13.19% 19.96% 34.14% 55.37% 67.33% 69.82% 70.49% 70.55%
L=16 6.09% 9.25% 17.48% 38.22% 60.92% 68.70% 70.15% 70.20%
L=32 5.44% 7.41% 13.36% 31.66% 58.68% 68.12% 70.12% 70.27%
A.8 E NERGY CONSUMPTION ANALYSIS
We evaluate the energy consumption of our method and the comp ared methods (Li et al., 2021;
Deng & Gu, 2020) on CIFAR-100 datasets. Here we use the same ne twork structure of VGG-16.
Following the analysis in Merolla et al. (2014), we use synap tic operation (SOP) for SNN to rep-
resent the required basic operation numbers to classify one image. We utilize 77fJ/SOP for SNN
and 12.5pJ/FLOP for ANN as the power consumption baseline, w hich is reported from the ROLLS
neuromorphic processor (Qiao et al., 2015). Note that we do n ot consider the memory access energy
in our study because it depends on the hardware. As shown in Ta ble S5, when the time-steps is the
same, the energy consumption of our method is about two times of SNNC-AP. However, to achieve
the same accuracy of 73.55%, our method requires less energy consumption.
A.9 PSEUDO -CODE FOR OVERALL CONVERSION ALGORITHM
In this section, we summarize the entire conversion process in Algorithm 1, including training ANNs
from scratch and converting ANNs to SNNs. The QCFS in the pseu do-code represents the proposed
quantization clip-ï¬‚oor-shift function.
18 Published as a conference paper at ICLR 2022
Table S3: Compare with state-of-the-art supervised traini ng methods on CIFAR-10 dataset
Model Method Architecture SNN Accuracy Timesteps
CIFAR-10
HC Hybrid VGG-16 92.02 200
STBP Backprop CIFARNet 90.53 12
DT Backprop CIFARNet 90.98 8
TSSL Backprop CIFARNet 91.41 5
DThIR1ANN-SNN cNet 77.10 256
Ours ANN-SNN VGG-16 93.96 4
Ours ANN-SNN CIFARNet294.73 4
1Implemented on Loihi neuromorphic processor
2For CIFARNet, we use the same architecture as Wu et al. (2018) .
Table S4: Comparison between the proposed method and previo us works on CIFAR-100 dataset.
Architecture Method ANN T=2 T=4 T=8 T=16 T=32 T=64 T â‰¥512
VGG-16RMP 71.22% - - - - - - 70.93%
TSC 71.22% - - - - - - 70.97%
RTS 77.89% - - - - 7.64% 21.84% 77.71%
SNNC-AP 77.89% - - - - 73.55% 76.64% 77.87%
Ours 76.28% 63.79% 69.62% 73.96% 76.24% 77.01% 77.10% 77.08%
ResNet-20RMP 68.72% - - - - 27.64% 46.91% 67.82%
TSC 68.72% - - - - - - 68.18%
Ours 69.94% 19.96% 34.14% 55.37% 67.33% 69.82% 70.49% 70.50%
ResNet-18RTS 77.16% - - - - 51.27% 70.12% 77.19%
SNNC-AP 77.16% - - - - 76.32% 77.29% 77.25%
Ours 78.80% 70.79% 75.67% 78.48% 79.48% 79.62% 79.54% 79.61%
1RTS and SNNC-AP use altered ResNet-18, while ours use standa rd ResNet-18.
Table S5: Comparison of the energy consumption with previou s works
Method ANN T=2 T=4 T=8 T=16 T=32 T=64
RTSAccuracy 77.89% - - - - 7.64% 21.84%
OP (GFLOP/GSOP) 0.628 - - - - 0.508 0.681
Energy (mJ) 7.85 - - - - 0.039 0.052
SNNC-APAccuracy 77.89% - - - - 73.55% 76.64%
OP (GFLOP/GSOP) 0.628 - - - - 0.857 1.22
Energy (mJ) 7.85 - - - - 0.660 0.094
OursAccuracy 76.28% 63.79% 69.62% 73.96% 76.24% 77.01% 77.10%
OP (GFLOP/GSOP) 0.628 0.094 0.185 0.364 0.724 1.444 2.884
Energy (mJ) 7.85 0.007 0.014 0.028 0.056 0.111 0.222
19 Published as a conference paper at ICLR 2022
Algorithm 1 Algorithm for ANN-SNN conversion.
Input : ANN model MANN(x;W)with initial weight W; Dataset D; Quantization step L; Initial
dynamic thresholds Î»; Learning rate Ç«.
Output :MSNN(x;Ë†W)
1:forl= 1toMANN.layers do
2: ifis ReLU activation then
3: Replace ReLU (x)by QCFS (x;L,Î»l)
4: end if
5: ifis MaxPooling layer then
6: Replace MaxPooling layer by AvgPooling layer
7: end if
8:end for
9:fore= 1to epochs do
10: forlength of Dataset Ddo
11: Sample minibatch (x0,y)fromD
12: forl= 1toMANN.layers do
13: xl=QCFS(Wlxlâˆ’1;L,Î»l)
14: end for
15: Loss = CrossEntropy (xl,y)
16: forl= 1toMANN.layers do
17: Wlâ†Wlâˆ’Ç«âˆ‚Loss
âˆ‚Wl
18: Î»lâ†Î»lâˆ’Ç«âˆ‚Loss
âˆ‚Î»l
19: end for
20: end for
21:end for
22:forl= 1toMANN.layers do
23:MSNN.Ë†Wlâ†MANN.Wl
24:MSNN.Î¸lâ†MANN.Î»l
25:MSNN.vl(0)â†MSNN.Î¸l/2
26:end for
27:returnMSNN
20"," This paper presents a method for converting an Artificial Neural Network (ANN) to a Spiking Neural Network (SNN) with high accuracy and ultra-low latency. It introduces a quantization clip-floor-shift activation function to replace the ReLU activation function in source ANNs, and evaluates the proposed method on CIFAR-10, CIFAR-100, and ImageNet datasets. Results show that the proposed method outperforms state-of-the-art ANN-SNN conversion methods in terms of accuracy and time-steps. Additionally, the paper discusses the use of uni-codes to represent various characters and symbols, and the use of a shift term to overcome the performance degradation problem when the time-steps and the quantization steps are not matched."
6," Evolutionary Reinforcement Learning: A Survey
Hui Bai1, Ran Cheng1, and Yaochu Jin2,3
1Department of Computer Science and Engineering, Southern University of Science
and Technology, Shenzhen, China.
2Faculty of Technology, Bielefeld University, 33615 Bielefeld, Germany.
3Department of Computer Science, University of Surrey, Guildford, Surrey GU2
7XH, U.K.
Abstract
Reinforcement learning (RL) is a machine learning approach that trains agents to maximize
cumulative rewards through interactions with environments. The integration of RL with deep
learning has recently resulted in impressive achievements in a wide range of challenging tasks,
including board games, arcade games, and robot control. Despite these successes, there remain
several crucial challenges, including brittle convergence properties caused by sensitive hyperpa-
rameters, diculties in temporal credit assignment with long time horizons and sparse rewards,
a lack of diverse exploration, especially in continuous search space scenarios, diculties in credit
assignment in multi-agent reinforcement learning, and conicting objectives for rewards. Evolu-
tionary computation (EC), which maintains a population of learning agents, has demonstrated
promising performance in addressing these limitations. This article presents a comprehensive
survey of state-of-the-art methods for integrating EC into RL, referred to as evolutionary rein-
forcement learning (EvoRL). We categorize EvoRL methods according to key research elds in
RL, including hyperparameter optimization, policy search, exploration, reward shaping, meta-
RL, and multi-objective RL. We then discuss future research directions in terms of ecient
methods, benchmarks, and scalable platforms. This survey serves as a resource for researchers
and practitioners interested in the eld of EvoRL, highlighting the important challenges and
opportunities for future research. With the help of this survey, researchers and practitioners
can develop more ecient methods and tailored benchmarks for EvoRL, further advancing this
promising cross-disciplinary research eld.
1 Introduction
Reinforcement learning (RL) has achieved remarkable success in recent years, particularly with the
integration of deep learning (DL), in solving complex sequential decision-making problems [1, 2].
Despite these advancements, RL still faces several challenges, such as sensitivity to hyperparameters
[3], diculties in credit assignment in tasks with long time horizons, sparse rewards, and multiple
1arXiv:2303.04150v1  [cs.NE]  7 Mar 2023 agents [4, 5], limited diverse exploration in tasks with deceptive rewards or continuous state and
action spaces [6], and conicting objectives for rewards [7].
To address these challenges, the eld of evolutionary reinforcement learning (EvoRL) has emerged
by integrating RL with evolutionary computation (EC) [8, 9]. EvoRL involves maintaining a popula-
tion of agents, which oers several benets, such as provision of redundant information for improved
robustness [9], enabling diverse exploration [10], ability to evaluate agents using an episodic tness
metric [9], and the ease of generating trade-o solutions through multi-objective EC algorithms [11].
EvoRL has a rich history, dating back to early work in neuroevolution, which used EC algorithms
to generate the weights and/or topology of articial neural networks (ANNs) for agent policies
[12, 13]. Since the proposal of OpenAI ES [8], EvoRL has gained increasing attention in both EC
and RL communities. While there have been some surveys focusing on various aspects of EvoRL,
such as neuroevolution [14], multi-objective RL [7, 15], automated RL [16], and derivative-free RL
[17], they either focus on a narrow research eld within RL or lack a comprehensive overview of EC
methods as applied to RL.
To bridge the gap between EC and RL communities, this article provides a comprehensive survey
of EvoRL, elaborating on six key research elds of RL, as shown in Figure 1. The EvoRL methods
are introduced and discussed separately for each eld, focusing on their advantages and limitations.
Finally, the article discusses potential improvement approaches for future research, including ecient
methods in terms of EvoRL processes, tailored benchmarks, and scalable platforms.
2 Background
2.1 Reinforcement Learning
Reinforcement learning (RL) is a powerful tool for decision-making in complex and stochastic en-
vironments. In RL, an agent interacts with its environment by taking a sequence of actions and
receiving a sequence of rewards over time. The objective of the agent is to maximize the expected
cumulative reward. This problem can be modeled as a Markov Decision Process (MDP), which is
dened as< S;A;T;R; 0; > , with a state space S, an action space A, a stochastic transition
functionT:SA!P(S) that represents the probability distribution over possible next states, a
reward function R:SA!R, an initial state distribution 0:S!R2[0;1], and a discount factor
2[0;1).
The agent's behavior is determined by its policy, which is denoted by :S!P(A), withP(A)
being the set of probability measures on Aand2Rnbeing a vector of nparameters. The agent
updates its policy over time to maximize the expected cumulative discounted reward, as given by
J() =E0;;T""1X
t=0trt#
; (1)
wheres00(s0),at(st),st+1T(jst;at), andrt=R(st;at).
RL algorithms can be divided into two categories: model-based and model-free. While model-
based algorithms establish a complete MDP by estimating the transition function and reward func-
2 Darwinian evolutionary approaches
Lamarckian evolutionary approaches
Evolution strategies based methods
Genetic algorithms based methodsHybrid approaches
Evolutionary 
reinforcement learningHyperparameter
 optimization
Policy search
Exploration
Reward shaping
Meta-RL
Multi-objective RLGenetic programming based methods
Diversity encouragement methods
Evolution of reward functions
Hyperparameter optimization methodsEvolution-guided exploration methods
Parameters initialization
Loss learning
Environment synthesis
Algorithms generation
Multi-objective evolutionary algorithms
Multi-objectivizationPopulation based training
Natural evolution strategies
Canonical evolution strategies
CMA-ES
Algorithmic frameworks
Indirect encoding
Variation operators
Representations
Evolution of direct controllers
Symbolic regression
Feature Discovery
Novelty search
Quality diversity
Surprise search
Evolvability search
Evolvability search
Use of diverse experiences
Use of gradient informationFigure 1: Key research elds of evolutionary reinforcement learning. Hyperparameter optimization
is a universal method for algorithms in the other ve research elds to realize end-to-end learning
and improve performance simultaneously. Policy search seeks to identify a policy that maximizes
the cumulative reward for a given task. Exploration encourages agents to explore more states and
actions and trains robust agents to better respond to dynamic changes in environments. Reward
shaping is aimed at enhancing the original reward with additional shaping rewards for tasks with
sparse rewards. Meta-RL seeks to develop a general-purpose learning algorithm that can adapt
to dierent tasks. Multi-objective RL aims to obtain trade-o agents in tasks with a number of
conicting objectives.
3 tion, by contrast, model-free algorithms are data-driven and optimize the policy by using a large
number of samples, without the need to know the transition function and reward function. Due to
the diculties of establishing a complete MDP and the success of neural networks (NNs) in repre-
senting policies, model-free RL has become the main focus of research in recent years [18]. In this
survey, we focus on model-free RL methods.
More specically, model-free RL methods can further be divided into two categories: policy-based
and value-based methods. In policy-based methods, the parameters of the policy are adjusted in
the direction of the performance gradient, according to the Policy Gradients Theorem [1]. Some
of the state-of-the-art policy-based algorithms include TRPO [19], PPO [20], A3C [21], DDPG
[22], TD3 [23], and SAC [24]. In value-based methods, a parameterized Q-function is optimized to
estimate the value of a state-action pair. One of the state-of-the-art value-based methods is DQN
[25], which updates the parameters of the Q-function by minimizing the Temporal Dierence (TD)
loss using a batch of samples. Techniques such as experience replay [26] and double Q-network [27]
have been proposed to improve the sample eciency and exploration of DQN.
2.2 Evolutionary Computation
Evolutionary computation (EC) refer to a family of stochastic search algorithms that have been
developed based on the principle of natural evolution. The primary objective of EC is to approximate
global optima of optimization problems by iteratively performing a range of mechanisms, such as
variation (i.e., crossover and mutation), evaluation, and selection. Among various EC paradigms, the
Evolution Strategies (ESs) [28] are the mostly adopted in EvoRL, together with the classic Genetic
Algorithm (GAs) [29] and the Genetic Programming (GP) [30].
ESs primarily tackle continuous black-box optimization problems where the search space lies
within the continuous domain. Therefore, it is predominantly applied to weight optimization of pol-
icy search in RL. ESs for RL are typically categorized into three main classes, which are Canonical
ES [31], Covariance Matrix Adaptation ES (CMA-ES) [32], and Natural ES (NES) [33]. Canonical
ES is aimed at obtaining nal solutions with high tness values while using a small number of tness
evaluations through conducting an iterative process involving variation, evaluation, and selection.
Here, we illustrate the canonical ( ,)-ES algorithm. Following the initialization of policy param-
etersx2Rnand a set of hyperparameters, the algorithm generates ospringx1;:::;xfrom a
search distribution with mean xand variance 2C. Subsequently, all ospring are evaluated using
a tness evaluation function. Following this, a new population mean is generated by moving the old
population mean towards the best ospring. Then, is optionally updated, and an adaptive 
can improve ESs performance. CMA-ES shares the same procedure with Canonical ES but is more
eective since its mutation step size and covariance matrix Care updated adaptively, enabling
the capture of the anisotropy properties of general optimization problems. NES also shares the same
iteration with Canonical ES. However, it updates a search distribution iteratively by estimating a
search gradient (i.e., the second-order gradient) on the distribution parameters towards higher ex-
pected tness values. The distribution parameters are updated through estimating a natural gradient
that can nd a parameterization-independent ascent direction compared to a plain search gradient
4 EnvironmentGiven current state ğ‘ âˆˆğ‘†
Take action ğ‘âˆˆğ´
Get reward ğ‘Ÿ
Next state ğ‘ â€²âˆˆğ‘†Agent Policy
Offspring 
generationMating selectionPopulation
Environmental selectionEvaluationFigure 2: A simple and general framework of EvoRL. The framework consists of two loops: the
outer loop shows the evolution process of EC, while the inner loop illustrates the agent-environment
interaction process in RL. Initially, a population of parent candidate solutions is randomly initialized,
and then the ospring candidate solutions are generated from the parents via variation. Each
ospring is evaluated using an RL task to obtain its tness value, and a new population is selected
for the next iteration by combining all parents and ospring.
[34]. The natural gradient erJis formulated as F"," This article provides an overview of Evolutionary Reinforcement Learning (EvoRL), a field that has emerged to address challenges in tasks with deceptive rewards or continuous state and action spaces. It discusses six key research fields of RL, including hyperparameter optimization, policy search, exploration, reward shaping, meta-RL, and multi-objective RL, and elaborates on the use of Evolutionary Computation (EC) algorithms. It also examines the use of evolutionary algorithms and reinforcement learning for optimizing machine learning models, as well as the application of these strategies to reinforcement learning, large-scale black-box optimization, unstable systems, and strategic decision-making problems."
7," RADAM: T EXTURE RECOGNITION THROUGH RANDOMIZED
AGGREGATED ENCODING OF DEEPACTIVATION MAPS
Leonardo Scabini1,2, Kallil M. Zielinski1, Lucas C. Ribas3, Wesley N. GonÃ§alves4, Bernard De Baets2, and Odemir M.
Bruno1
1SÃ£o Carlos Institute of Physics, University of SÃ£o Paulo, postal code 13560-970, SÃ£o Carlos - SP, Brazil
2KERMIT, Department of Data Analysis and Mathematical Modelling, Ghent University, Coupure links 653, postal code 9000,
Ghent, Belgium
3Institute of Biosciences, Humanities and Exact Sciences, SÃ£o Paulo State University, postal code 15054-000, SÃ£o JosÃ© do Rio Preto -
SP, Brazil
4Faculty of Computing, Federal University of Mato Grosso do Sul, postal code 79070-900, Campo Grande - MS, Brazil
ABSTRACT
Texture analysis is a classical yet challenging task in computer vision for which deep neural networks
are actively being applied. Most approaches are based on building feature aggregation modules
around a pre-trained backbone and then ï¬ne-tuning the new architecture on speciï¬c texture recogni-
tion tasks. Here we propose a new method named Random encoding of Aggregated DeepActivation
Maps (RADAM) which extracts rich texture representations without ever changing the backbone.
The technique consists of encoding the output at different depths of a pre-trained deep convolutional
network using a Randomized Autoencoder (RAE). The RAE is trained locally to each image using a
closed-form solution, and its decoder weights are used to compose a 1-dimensional texture represen-
tation that is fed into a linear SVM. This means that no ï¬ne-tuning or backpropagation is needed. We
explore RADAM on several texture benchmarks and achieve state-of-the-art results with different
computational budgets. Our results suggest that pre-trained backbones may not require additional
ï¬ne-tuning for texture recognition if their learned representations are better encoded.
1 Introduction
For several decades, texture has been studied in Computer Vision as a fundamental visual cue for image recognition in
several applications. Despite lacking a widely accepted theoretical deï¬nition, we all have developed an intuition for
textures by analyzing the world around us from material surfaces in our daily life, through microscopic images, and
even through macroscopic images from telescopes and remote sensing. In digital images, one abstract deï¬nition is
that texture elements emerge from the local intensity constancy and/or variations of pixels producing spatial patterns
roughly independently at different scales [39].
The classical approaches to texture recognition focus on the mathematical description of the textural patterns, considering
properties such as statistics [10, 15, 24], frequency [1, 12], complexity/fractality [2, 38], and others [52]. Many such
aspects of texture are challenging to model even in controlled imaging scenarios. Moreover, the wild nature of digital
images also results in additional variability, making the task even more complex in real-world applications.
Recently, the power of deep neural networks has been extended to texture analysis by taking advantage of models
pre-trained on big natural image datasets [4 â€“6, 22, 46 â€“51]. These transfer-learning approaches combine the general
vision capabilities of pre-trained models with dedicated techniques to capture additional texture information, achieving
state-of-the-art performance on several texture recognition tasks. Therefore, most of the recent works on deep texture
recognition propose to build new modules around a pre-trained deep network (backbone) and to retrain the new
architecture for a speciï¬c texture analysis task. However, even if the new modules are relatively cheap in terms of
computational complexity, resulting in good inference efï¬ciency, the retraining of the backbone itself is usually costly.
Going in a different direction, Randomized Neural Networks [13,25,26,40] proposes a closed-form solution for training Going in a different direction, Randomized Neural Networks [13,25,26,40] proposes a closed-form solution for training
neural networks, instead of the common backpropagation, with various potential applications. For instance, the training
time of randomization-based models was analyzed [17] on datasets such as MNIST, resulting in gains up to 150 times.
These gains can be expressive when hundreds of thousands of images are used to train a model.arXiv:2303.04554v1  [cs.CV]  8 Mar 2023 In this work, we propose a new module for texture feature extraction from pre-trained deep convolutional neural
networks (DCNNs). The method, called Random encoding of Aggregated DeepActivation Maps (RADAM), goes
in a different direction than recent literature on deep texture recognition. Instead of increasing the complexity of
the backbone and then retraining everything, we propose a simple codiï¬cation of the backbone features using a new
randomized module. The method is based on aggregating deep activation maps from different depths of a pre-trained
convolutional network, and then training Randomized Autoencoders (RAEs) in a pixel-wise fashion for each image,
using a closed-form solution. This module outputs the decoder weights from the learned RAEs, which are used as a
1-dimensional feature representation of the input image. This approach is simple and does not require hyperparameter
tuning or backpropagation training. Instead, we propose to attach a linear SVM at the top of our features, which can be
simply used with standard parameters. Our code is open and is available in a public repository1. In summary, our main
contributions are:
(i)We propose the RADAM texture feature encoding technique applied over a pre-trained DCNN backbone and
coupled with a simple linear SVM. The model achieves impressive classiï¬cation performance without needing
to ï¬ne-tune the backbone, in contrast to what has been proposed in previous works.
(ii)Bigger backbones and better pre-training improve the performance of RADAM considerably, suggesting that
our approach scales well.
2 Background
We start by conducting a literature review on texture analysis with deep learning and randomized neural networks. The
methods covered here are also considered for comparison in our experiments.
2.1 Texture Analysis with Deep Neural Networks
In this work, we focus on transfer-learning-based texture analysis by taking advantage of pre-trained deep neural
networks. For a more comprehensive review of different approaches to texture analysis, the reader may consult [19].
There have been numerous studies involving deep learning for texture recognition, and here we review them according
to two approaches: feature extraction or end-to-end ï¬ne-tuning. Some studies explore CNNs only for texture feature
extraction and use a dedicated classiï¬er apart from the model architecture. Cimpoi et al. [6] was one of the ï¬rst works
on the subject, where the authors compare the efï¬ciency of two different CNN architectures for feature extraction:
FC-CNN, which uses a fully connected (FC) layer, and FV-CNN, which uses a Fisher vector (FV) [5] as a pooling
method. They demonstrated that, in general, FC features are not that efï¬cient because their output is highly correlated
with the spatial order of the pixels. Later on, Condori and Bruno [22] developed a model, called RankGP-3M-CNN,
which performs multi-layer feature aggregation employing Global Average Pooling (GAP) to extract the feature vectors
of activation maps at different depths of three combined CNNs (VGG-19, Inception-V3, and ResNet50). They propose
a ranking technique to select the best activation maps given a training dataset, achieving promising results in some
cases but at the cost of increased computational load, since three backbones are needed. Lyra et al. [21] also proposes
feature aggregation from multiple convolutional layers, but pooling is performed using an FV-based approach.
Numerous studies propose end-to-end architectures that enable ï¬ne-tuning of the backbone for texture recognition.
Zhang et al. [51] proposed an orderless encoding layer on top of a DCNN, called Deep Texture Encoding Network
(Deep-TEN), which allows images of arbitrary size. Xue et al. [46] introduces a Deep Encoding Pooling Network
(DEPNet), which combines features from the texture encoding layer from Deep-TEN and a global average pooling (DEPNet), which combines features from the texture encoding layer from Deep-TEN and a global average pooling
(GAP) to explore both the local appearance and global context of the images. These features are further processed by
a bilinear pooling layer [18]. In another work, Xue et al. [47] also combined features from differential images with
the features of DEPNet into a new architecture. Using a different approach, Zhai et al. [50] proposed the Multiple-
Attribute-Perceived Network (MAP-Net), which incorporated visual texture attributes in a multi-branch architecture that
aggregates features of different layers. Later on [49], they explored the spatial dependency among texture primitives for
capturing structural information of the images by using a model called Deep Structure-Revealed Network (DSRNet).
Chen et al. [4] introduced the Cross-Layer Aggregation of a Statistical Self-similarity Network (CLASSNet). This CNN
feature aggregation module uses a differential box-counting pooling layer that characterizes the statistical self-similarity
of texture images. More recently, Yang et al. [48] proposed DFAEN (Double-order Knowledge Fusion and Attentional
Encoding Network), which takes advantage of attention mechanisms to aggregate ï¬rst- and second-order information
for encoding texture features. Fine-tuning is employed in these methods to adapt the backbone to the new architecture
along with the new classiï¬cation head.
1https://github.com/scabini/RADAM
2 As an alternative to CNNs, Vision Transformers (ViTs) [8] are emerging in the visual recognition literature. Some works
have brieï¬‚y explored their potential for texture analysis through the Describable Textures Dataset (DTD) achieving state-
of-the-art results. Firstly, ViTs achieve competitive results compared to CNNs, but the lack of the typical convolutional
inductive bias usually results in the need for more training data. To overcome this issue, a promising alternative is
to use attention mechanisms to learn directly from text descriptions about images, e.g.using Contrastive Language
Image Pre-training (CLIP) [31]. There have also been proposed bigger datasets for the pre-training of ViTs, such as
Bamboo [53], showing that these models scale well. Another approach is to optimize the construction of multitask
large-scale ViTs such as proposed by Gesmundo [9] with the 2Net+ method.
2.2 Randomized Neural Networks for Texture Analysis
A Randomized Neural Network [13, 25, 26, 40], in its simplest form, is a single-hidden-layer feed-forward neural
network whose input weights are random, while the weights of the output layer are learned by a closed-form solution,
in contrast to gradient-descent-based learning. Recently, several works have investigated RNNs to learn texture features
for image analysis. SÃ¡ Junior et al. [35] used small local regions of one image as inputs to an RNN, and the central
pixel of the region as the target. The trained weights of the output layer for each image are then used as a texture
representation. Ribas et al. [33] improved the previous approach with the incorporation of graph theory to model the
texture image. Other works [16, 32] have also extended these concepts to video texture analysis (dynamic texture).
The training of 1-layer RNNs as employed in previous works is a least-squares solution at the output layer. First,
considerX2Rnzas the input matrix with ntraining samples and zfeatures, and g=(XW)as the forward pass of
the hidden layer with a sigmoid nonlinearity, where W2Rzqrepresents the random input weights for qneurons.
Given the desired output labels Y, the output weights fare obtained as the least-squares solution of a system of linear
equations:
f=YgT(ggT)"," This paper proposes a new method called Random encoding of Aggregated DeepActivation Maps (RADAM) for texture recognition. It uses a pre-trained deep convolutional network and a Randomized Autoencoder (RAE) to extract rich texture representations without changing the backbone. Experiments show that RADAM outperforms Global Average Pooling (GAP) and other state-of-the-art methods on five challenging texture recognition datasets. The paper also compares the performance and cost of RADAM with ConvNeXt-T, B, L, and XL to ResNet18 and ResNet50, and provides code for the RADAM module and its internal mechanisms."
8," A Computer Vision Enabled damage detection model with
improved YOLOv5 based on Transformer Prediction Head
Arunabha M. Roy1and Jayabrata Bhaduri2
1Aerospace Engineering Department, University of Michigan, Ann Arbor, MI
48109, USA
2Capacloud AI, Deep Learning &Data Science Division, Kolkata, WB 711103,
India.
Abstract
Objective. Computer vision-based up-to-date accurate damage classification and localization
are of decisive importance for infrastructure monitoring, safety, and the serviceability of civil
infrastructure. Current state-of-the-art deep learning (DL)-based damage detection models,
however, often lack superior feature extraction capability in complex and noisy environments,
limiting the development of accurate and reliable object distinction. Method. To this end,
we present DenseSPH-YOLOv5, a real-time DL-based high-performance damage detection
model where DenseNet blocks have been integrated with the backbone to improve in preserving
and reusing critical feature information. Additionally, convolutional block attention modules
(CBAM) have been implemented to improve attention performance mechanisms for strong and
discriminating deep spatial feature extraction that results in superior detection under various
challenging environments. Moreover, an additional feature fusion layers and a Swin-Transformer
Prediction Head (SPH) have been added leveraging advanced self-attention mechanism for more
efficient detection of multiscale object sizes and simultaneously reducing the computational
complexity. Results. Evaluating the model performance in large-scale Road Damage Dataset
1arXiv:2303.04275v1  [cs.CV]  7 Mar 2023 2
(RDD-2018), at a detection rate of 62.4 FPS, DenseSPH-YOLOv5 obtains a mean average
precision (mAP) value of 85 :25%, F1-score of 81 :18%, and precision (P) value of 89 :51%
outperforming current state-of-the-art models. Significance. The present research provides
an effective and efficient damage localization model addressing the shortcoming of existing
DL-based damage detection models by providing highly accurate localized bounding box
prediction. Current work constitutes a step towards an accurate and robust automated damage
detection system in real-time in-field applications.
Keywords: Automated damage detection; You Only Look Once (YOLOv5) algorithm; Swin
Transformer Object Detection (OD); Computer vision; Deep Learning (DL)
1. Introduction :
In recent years, automated damage detection plays an important role in various industrial
applications including product quality assessment (Agarwal and Singh, 2015; Hanzaei et al.,
2017), infrastructure monitoring (Eisenbach et al., 2017; Gopalakrishnan, 2018), safety and
the serviceability of civil infrastructure (Koch et al., 2015; Hartmann and Trappey, 2020).
Early-stage accurate crack detection is critical for pavement damage rating and subsequent
sealing or rehabilitation activities (Chen et al., 2021; Chen and Cho, 2022). Therefore, it
is important for roadway infrastructure engineers to detect pavement cracks accurately so
that the best cost-effective plans of maintenance and rehabilitation could be employed (Ni
et al., 2022; Dong et al., 2021). While traditional damage detection techniques mainly include
visual inspection, however, such labor-intensive methods have disadvantages due to their low
efficiency, high cost, and individual biases (Xu et al., 2022; Shang et al., 2023). Additionally, it
is also limited in reproducibility, reliability, and objectivity due to the requirement of qualified
personnel for domain-specific experience, knowledge, and skill sets (Fang et al., 2020). To
circumvent such issues, more recently, various automatic and semi-automatic crack detection
algorithms have gained significant attraction (Gopalakrishnan, 2018).
For the last three decades, image-based crack detection (Mohan and Poobal, 2018; Koch
et al., 2015) that include various image processing approaches, such as edge detection (Zhao 3
et al., 2010; Hanzaei et al., 2017; Li et al., 2022), dynamic thresholding (Oliveira and Correia,
2009; Wang et al., 2021b), and different morphological operations (Anitha et al., 2021; Li
and Zhao, 2021) have been the central focus for detecting damage in challenging real-world
scenarios. However, the aforementioned methods are quite sensitive to noise and varying
illumination intensities, and hence, not suitable in real-world complex conditions (Koch et al.,
2015). To circumvent such issues, later, conventional machine learning (ML) approaches
have been introduced for damage detection (Mohan and Poobal, 2018; Koch et al., 2015). In
general, such methods utilize a trained classifier such as a Support Vector Machine (SVM)
on local feature descriptors that can be either Local Binary Patterns (LBP) (Varadharajan
et al., 2014; Quintana et al., 2015) or Histogram of Oriented Gradient (HOG) (Kapela et al.,
2015). Although, compared to conventional image processing approaches, ML-based models
significantly improve the accuracy and efficiency of the damage detection, however, due to large
errors in classification performances remains a serious bottleneck for deploying such models in
real-world applications (Fang et al., 2020).
More recently, deep learning (DL) characterized by multilayer neural networks (NN) (LeCun
et al., 2015) has shown remarkable breakthroughs in pattern recognition for various fields
including image classification (Rawat and Wang, 2017; Jamil et al., 2022; Khan et al., 2022b,a),
computer vision (Voulodimos et al., 2018; Roy and Bhaduri, 2021; Roy et al., 2022c; Roy and
Bhaduri, 2022; Roy et al., 2022a), object detection (Zhao et al., 2019a; Chandio et al., 2022;
Roy et al., 2022b; Singh et al., 2023a), brain-computer interfaces (Roy, 2022b,a,c; Singh et al.,
2023b), signal classification (Jamil and Roy, 2023, 2022) and across diverse scientific disciplines
(Bose and Roy, 2022; Roy and Bose, 2023b; Roy and Guha, 2022; Roy and Bose, 2023a; Roy
and Guha, 2023). Following the success, there is an increasing thrust of research works geared
towards damage classification tasks employing DL techniques, mostly convolutional neural
networks (CNN), such as ResNet (Bang et al., 2018), AlexNet (Dorafshan et al., 2018; Li
et al., 2018), VGG-net (Gopalakrishnan et al., 2017; Silva and Lucena, 2018) and various
others (Chow et al., 2020; Nath et al., 2022; Li et al., 2021). Particularly in object localization,
DL methods have demonstrated superior accuracy (Han et al., 2018) that can be categorized
into two classes: two-stage and one-stage detector (Lin et al., 2017a). Two-stage detectors
including Region Convolution Neural Network (R-CNN) (Girshick, 2015), faster R-CNN (Ren 4
et al., 2016), mask R-CNN (He et al., 2017) etc that have shown a significant improvement
in accuracy in object localization. In recent times, You Only Look Once (YOLO) variants
(Redmon et al., 2016; Redmon and Farhadi, 2017, 2018; Bochkovskiy et al., 2020) have been
proposed that unify target classification and localization. In (Roy et al., 2022c; Roy and
Bhaduri, 2022, 2021), DenseNet (Huang et al., 2017) blocks attaching Spatial Pyramid Pooling
(SPP) (He et al., 2015) with an improved modified Path Aggregation Network (PANet) (Liu
et al., 2018) has been integrated to enhance the representation of receptive fields and extraction
of important contextual features in the original YOLOv4 leading to significant improvement in
the detection speed and accuracy. In order to enhance gradient performance and reduce the
computational cost, YOLOv4 (Bochkovskiy et al., 2020) designs a cross-stage partial (CSP)
network. To further improve detection accuracy, YOLOv4 implements Mish activation (Misra,
2020) and CIoU loss (Zheng et al., 2020). Recently, Scaled-YOLOv4 (Wang et al., 2021a)
demonstrated its superior performance in detecting the vast range of linearly scaled objects for
various applications. As the latest generation of the YOLO series, the YOLOv5 (Jocher et al.,
2021) has been rated top among state-of-the-art object detection models which inherit all the
above advantages. Thus, in the present work, YOLOv5 has been considered a benchmark model
for multiclass damage detection. More recently, improved YOLOv5 Based on Transformer
Prediction Head (TPH-YOLOv5) (Zhu et al., 2021) has been proposed integrating convolutional
block attention module (CBAM) (Woo et al., 2018) for closely packed object detection and
Swin Transformer-enabled YOLOv5 (SPH-YOLOv5) (Gong et al., 2022) has been designed
incorporating Normalization-based Attention Modules (NAM) that demonstrate significant
improvement in accuracy while simultaneously reducing the computational complexity of the
model which are the main motivations for the network architectural development of the current
work.
1.1 Related Works :
In this section, some recent and relevant DL works have been highlighted in the field of road
damage detection. In recent years, multiple studies have adopted various ML and DL-based
approaches for automated road surface damage classification and detection (Zhang et al., 2017a; 5
Stricker et al., 2019; Bi cici and Zeybek, 2021) For instance, a smartphone-based supervised deep
convolutional neural network (D-CNN) has been proposed for pavement damage classification
(Zhang et al., 2016). Along a similar line, deep neural network (DNN) architecture has been
employed for detecting cracks and potholes (Anand et al., 2018; Silva and Lucena, 2018) as well
as pavement condition assessment (Fan et al., 2018). In Nhat-Duc et al. (2018), the superiority
of the DCNN-based approach has been demonstrated over edge-detection-based approaches for
pavement crack detection. In Maeda et al. (2018), a real-time road damage detection model
based on SDD has been proposed that has been trained on a publicly available large-scale
road damage dataset (RDD-2018) for eight different categories of road damages. Due to the
popularity of the dataset, various attempts have been made, notably using YOLO (Alfarrarjeh
et al., 2018), Faster R-CNN (Kluger et al., 2018), Faster R-CNN with ResNet-152 (Wang et al.,
2018a), Ensemble models with Faster R-CNN and SSD (Wang et al., 2018b), and RetinaNet
(Angulo et al., 2019) to further improve the detection performance. In addition, RetinaNet
(Angulo et al., 2019) has been used on a modified RDD-2018 dataset which demonstrates
significant performance improvement. Following the work of Maeda et al. (2018), progressive
growing- generative adversarial networks (PG-GANs) (Maeda et al., 2021) with Poisson blending
have been used to generate new training data (RDD-2019) in order to improve the accuracy of
road damage detection. More recently, transfer learning (TL)-based road damage detection
model (Arya et al., 2021a) has been proposed introducing large-scale open-source dataset
RDD2020 (Arya et al., 2020, 2021b) considering multiple countries. In Naddaf-Sh et al. (2020),
EfficientDet-D7 has been employed for the detection of asphalt pavement distress. Whereas,
YOLO CSPDarknet53 (Mandal et al., 2020) has been used for road damage detection. Similarly,
the YOLO network has been used for detecting pavement distress from high-resolution images
(Du et al., 2021). In Majidifard et al. (2020), YOLOv2 model has been utilized for pavement
distress classification from Google street view images. Along a similar line, a CNN-based
predictive model trained in Google API images has been employed for detecting potholes
in Patra et al. (2021). In a separate work in Guan et al. (2021), a stereo-vision integrated
segmentation-based DL model with modified depth-wise separable convolution U-net has
been deployed for crack and pothole detection where multi-feature image datasets have been
used to train the model. More recently, a semi-supervised DL-based pixel-level segmentation 6
model (Karaaslan et al., 2021) has been proposed utilizing attention guidance for cracks and
spalls localization that reduces computational cost significantly. In separate work, an improved
YOLOv5 road damage detection algorithm (Guo and Zhang, 2022) has been proposed leveraging
MobileNetV3 as a backbone feature extractor. In Hacefendio glu and Ba sa ga (2022), Faster
R-CNN has been employed for concrete pavement crack detection under various illumination and
weather conditions. Although, there exist several state-of-the-art works for damage detection
including multi-class damage localization models, however, they often suffer from low accuracy,
missed detection, and relatively large computational overhead (Cao et al., 2020; Azimi et al.,
2020; Naddaf-Sh et al., 2020).
1.2 Motivations :
Despite illustrating outstanding performance in damage detection, current state-of-the-art
DL algorithms still require further improvement due to their insufficient fine-grain contextual
feature extraction capability leading to missed detection and false object predictions for various
damages/cracks which possess a wide range of textures, shapes, sizes, and colors (Cao et al.,
2020; Azimi et al., 2020; Naddaf-Sh et al., 2020). Between various damage classes, accurate
detection and localization tasks can be challenging due to significant variability of lightening
conditions, low visibility, the coexistence of multi-object classes with various aspect ratios, and
other morphological characteristics (Azimi et al., 2020; Naddaf-Sh et al., 2020). Additionally,
visual similarities, complex backgrounds, and various other critical factors offer additional
difficulties for the state-of-the-art damage detection models (Naddaf-Sh et al., 2020). To
this end, the current works aim to develop an efficient and robust damage classification and
accurate damage localization model simultaneously productive in terms of training time and
computational cost which is currently lacking in the recent state-of-the-art endeavors.
1.3 Contributions :
To address the aforementioned shortcomings, in the current study, we present DenseSPH-YOLOv5
based on an improved version of the state-of-art YOLOv5 detection model for accurate real-time 7
damage detection. The major contributions of the present research work can be summarized as
follows:
â€¢In Dense-SPH-YOLOv5, we have attached DenseNet blocks with CSP modules in the
CSPDarknet53 to preserve critical feature maps and efficiently reuse the discriminating
feature information.
â€¢Secondly, we have introduced an additional detection head specifically for detecting tiny
objects in the head part of the proposed DenseSPH-YOLOv5 network.
â€¢In addition, the convolutional block attention module (CBAM) has been implemented for
the construction of progressive feature attention with large coverage along both channel
and spatial dimensions for strong and discriminating deep spatial feature extraction during
object detection.
â€¢Furthermore, the regular CNN prediction heads (CPH) in YOLOv5 have been upgraded
with Swin transformer Prediction Heads (SPHs) employing Swin transformer (STR)
encoder block leveraging advanced self-attention mechanisms for efficient detection of
multi-scale object sizes and simultaneously reducing the computational complexity.
â€¢Spatial Pyramid Pooling (SPP) has been tightly attached to the backbone to enhance
the representation of receptive fields and extraction of important contextual features.
â€¢Finally, an improved modified Path Aggregation Network (PANet) has been utilized
to efficiently preserve fine-grain localized information by feature fusion in a multi-scale
feature pyramid map.
With the aforementioned modifications, the detection accuracy of the model has been
significantly enhanced for multi-scale object detection. An extensive ablation study has been
performed for different combinations of backbone-neck architecture in order to optimize both
accuracies of detection and detection speed. The proposed DenseSPH-YOLOv5 has been
employed to detect distinct eight different damage classes that provide superior and accurate
detection under various complex and challenging environments. The present work effectively
addresses the shortcoming of existing DL-based crack detection models and illustrates its 8
Figure 1: Sample images from RDD-2018 dataset (Maeda et al., 2018): (a) to (g) correspond
to each of the eight categories with the legends.
superior potential in real-time in-field applications. The rest of the paper is organized as follows:
description of the dataset has been described in Section 2; Section 3 introduces the proposed
methodology for damage detection; the relevant finding and discussion of the proposed model
have been discussed in Sections 4 and 5, respectively. Finally, the conclusions of the present
work have been discussed in section 6.
2. Road Damage Dataset :
In the current study, large-scale Road Damage Dataset (RDD-2018) (Maeda et al., 2018)
has been used that consists of 9,053 labeled road damage images of resolution 600 600 pixels
containing a total number of 15,435 annotated bounding boxes for eight different types of
road damage. To avoid biases, the images have been photographed in various weather and
illumination conditions from different regions of Japan including Chiba, Muroran, Ichihara,
Sumida, Nagakute, and Numazu. During annotation, professional road damage expertise
has been employed to verify various damage classes that ensure the reliability of the dataset.
Various damage types and corresponding class identifiers have been listed in Table. 1. Each 9
Table 1: Various road damage types and corresponding class identifiers in RDD-2018 dataset
(Maeda et al., 2018).
Class
IdentifierDamage
typeAlignment Details
D00 Linear Crack Longitudinal Wheel-marked part
D01 Linear Crack Longitudinal Construction joint part
D10 Linear Crack Lateral Equal interval
D11 Linear Crack Lateral Construction joint part
D20 Alligator Crack - Partial pavement, overall pavement
D40 Other Crack - Pothole, rutting, separation
D43 Other Crack - White line blur
D44 Other Crack - Cross walk blur
type of damages have been illustrated in Fig. 1. Primarily, the damage has been classified into
cracks or different corruptions. Then, the cracks have been divided into linear and alligator
cracks. Whereas, other corruptions include both potholes and rutting as well as other road
damage classes such as blurring of white lines.
3. Proposed Methodology for damage detection:
In object detection, target object classification and localization are performed simultaneously
where the target class has been categorized and separated from the background. The purpose
of object localization is to locate objects by drawing bounding boxes (BBs) on input images
containing the entire object. This is particularly useful for counting endangered species for
accurate surveying. To this end, the main goal of the current work is to develop an efficient and
robust damage classification and accurate damage localization model. In this regard, different
variants of YOLO (Redmon et al., 2016; Redmon and Farhadi, 2017, 2018; Bochkovskiy et al.,
2020) are some of the best high-precision one-stage object detection models. More recently, 10
 
Î· 
d 
wp 
hp 
wgt 
hgt 
(a) (b) Damage  detection  
Input  N Ã—N  grids  
BBs+ confidence  score  
Class probability   
 
 
 
Figure 2: Schematic of (a) YOLO object localization process for damage localization; (b)
Schematic of CIoU offset regression for target BBs predictions.
YOLOv5 (Jocher et al., 2021) has been introduced that currently achieves the best detection
performance and has four different model variants including YOLOv5s, YOLOv5m, YOLOv5l,
and YOLOv5x depend on different model widths and depths. In general, the overall architecture
of YOLOv5 consists of the following parts: a backbone for deep feature extraction, followed by
the neck for gathered semantic feature fusion, and finally head network for object classification
and localization. The original version of YOLOv5 utilizes CSPDarknet53 (Wang et al., 2020;
Bochkovskiy et al., 2020) with SPP and PANet (Liu et al., 2018) as backbone and neck,
respectively. Whereas, YOLO detection head (Redmon et al., 2016) has been employed in
the detection head. The YOLO model transforms the object detection task into a regression
problem by generating BBs coordinates and probabilities for each class as shown in Fig. 2.
During the process, the inputted image size has been uniformly divided into NNgrids where
Bpredictive BBs have been generated. Subsequently, a confidence score has been assigned if
the target object falls inside that particular grid. It detects the target object for a particular
class when the center of the ground truth lies inside a specified grid. During detection, each
grid predicts NBnumbers of BBs with the confidence value  Bas:
B=Pr(obj)IoUt
p_P r(obj)20;1 (1) 11
wherePr(obj) infers the accuracy of BB prediction, i.e., Pr(obj) = 1 indicates that the target
class falls inside the grid, otherwise, Pr(obj) = 0. The degree of overlap between ground truth
and the predicted BB has been described by the scale-invariant evaluation metric intersection
over union (IoU) which can be expressed as
IoU =Bp\Bgt
Bp[Bgt(2)
where BgtandBpare the ground truth and predicted BBs, respectively.
3.1 Loss in BBs regression :
To further improve BBs regression and gradient disappearance, generalized IoU (GIoU)
(Rezatofighi et al., 2019) and distance-IoU (DIoU) (Zheng et al., 2020) as been introduced
considering aspect ratios and orientation of the overlapping BBs. More recently, complete IoU
(CIoU) (Zheng et al., 2020) has been proposed for improved accuracy and faster convergence
speed in BB prediction which can be expressed as
LCIoU= 1 ++2(bp;bgt)
2"," This paper presents a novel deep learning-based damage detection model, DenseSPH-YOLOv5, which integrates DenseNet blocks and convolutional block attention modules (CBAM) to improve feature extraction in complex and noisy environments. The model outperforms existing deep learning-based damage detection models in terms of accuracy and speed, achieving a detection rate of 62.4 FPS and a mean average precision (mAP) value of 85:25%, F1-score of 81:18%, and precision (P) value of 89:51%. It covers topics such as deep convolutional neural networks, Transformers for image recognition, YOLO networks, structured prediction, variational U-nets, and performance measures for classification."
9," Patch of Invisibility:
Naturalistic Black-Box Adversarial Attacks on Object Detectors
Raz Lapid
Dept. of Computer Science, Ben-Gurion University
Beer-Sheva 84105, Israel
razla@post.bgu.ac.il
and
DeepKeep, Tel-Aviv, Israel
Moshe Sipper
Dept. of Computer Science, Ben-Gurion University
Beer-Sheva 84105, Israel
sipper@bgu.ac.il
Abstract
Adversarial attacks on deep-learning models have been
receiving increased attention in recent years. Work in this
area has mostly focused on gradient-based techniques, so-
called â€œwhite-boxâ€ attacks, wherein the attacker has access
to the targeted modelâ€™s internal parameters; such an as-
sumption is usually unrealistic in the real world. Some at-
tacks additionally use the entire pixel space to fool a given
model, which is neither practical nor physical (i.e., real-
world). On the contrary, we propose herein a gradient-free
method that uses the learned image manifold of a pretrained
generative adversarial network (GAN) to generate natural-
istic physical adversarial patches for object detectors. We
show that our proposed method works both digitally and
physically.
1. Introduction
Deep Neural Networks (DNNs) are increasingly de-
ployed in safety-critical applications, many involving some
form of identifying humans. The risk of facing deceptive
imagesâ€”so called adversarial instancesâ€”grows with the
use of DNN models. In order to trick the DNN into cate-
gorizing the input image differently than a human would,
an adversarial sample is employed. As ï¬rst demonstrated
in [28], neural networks are susceptible to such adversity.
The methods used to generate adversarial instances
based on minimal input perturbations were enhanced by
subsequent works [4, 20, 25]. Instead of modifying existingimages, [29] generated unconstrained adversarial instances
using generative adversarial networks (GANs). While many
methods concentrate on digital, white-box attacks, where
the attacker has access to the model, it is crucial to investi-
gate and comprehend potential realistic physical attacks in
more depth, i.e., attacks that occur in the physical world.
Figure 1. An adversarial patch evolved by our novel gradient-free
algorithm, which conceals people from an object detector.
Adversarial attacks are a type of cybersecurity threat
that aims to deceive deep learning (DL) systems by inject-
ing carefully crafted inputs that are designed to fool them.
These attacks exploit vulnerabilities in DL models and take
advantage of their tendency to make mistakes when pro-
cessing data. Adversarial attacks can be used for manipula-
tion in a wide range of applications, including image recog-
nition, natural language processing, autonomous vehicles,
and medical diagnosis [20, 30].
The implications of adversarial attacks can be far-arXiv:2303.04238v2  [cs.CV]  9 Mar 2023 reaching, as they can compromise the security and accu-
racy of systems that rely on DL. For instance, an adversar-
ial attack on a vehicle-mounted, image-recognition system
could cause it to misidentify a stop sign as a speed-limit
sign [8], potentially causing the vehicle to crash. As DL be-
comes increasingly ubiquitous, the need to mitigate adver-
sarial attacks becomes more pressing. Therefore, research
into adversarial attacks and defenses is a rapidly growing
area, with researchers working on developing robust and se-
cure models that are less susceptible to such attacks.
In this work we focus on fooling surveillance cameras
(both indoor and outdoor), because of their ubiquity and
susceptibility to attack, by creating adversarial patches (Fig-
ure 1). The next section presents previous work. Our
method is described in Section 3, followed by experimental
results in Section 4. We discuss our ï¬ndings in Section 5,
ending with concluding remarks in Section 6.
2. Previous work
This section offers some background and discusses rele-
vant literature on adversarial attacks. We begin with digital
adversarial attacks in classiï¬cation tasks, followed by digi-
tal attacks on object detectors, ending with physical attacks.
In general, attacks can be divided into three categories:
white box, black box, and gray box.
â€¢White-box threat models assume that the attacker has
complete knowledge of the system being attacked.
This includes knowledge of the systemâ€™s architecture,
implementation details, and even access to the source
code. In a white-box threat model, the attacker can in-
spect the systemâ€™s internals and use this knowledge to
launch targeted attacks.
â€¢Black-box threat models assume that the attacker has
no prior knowledge or access to the system being
attackedâ€”no knowledge of the systemâ€™s architecture
or implementation details. This means that the attacker
is only able to observe the systemâ€™s behavior from the
outside, without any ability to inspect the internals of
the system.
â€¢Gray-box threat models are a mix of both black-box
and white-box models, where the attacker has some
knowledge of the system being attackedâ€”but not com-
plete knowledge.
Herein we focus on black-box threat models because we
only assume access to the modelsâ€™ output.
Convolutional Neural Networks (CNNs) have been of
particular focus in the domain of adversarial attacks, due
to their popularity and success in imaging tasks [9, 19, 20,
27, 34].
Digital adversarial attacks on classiï¬cation models
are a type of attack on learning models that includes addinga minimal perturbation to the input data, with the goal of
causing the model to predict an incorrect class. There has
been a plethora of studies over the past several years on
creating and enhancing adversarial attacks on classiï¬cation
models.
The Fast Gradient Sign Method (FGSM) [11], ï¬rst pre-
sented in 2015, is one of the earliest and most well-known
adversarial attacks. The FGSM is a straightforward and ef-
fective white-box technique for generating adversarial at-
tacks. It works by computing the gradient of the loss func-
tion with respect to the input data and perturbing the input
data according to the gradientâ€™s sign. FGSM has received
much attention since its introduction, and has been proven
quite successful.
Projected Gradient Descent (PGD) [23], a white-box at-
tack introduced in 2017, executes several small steps along
the gradientâ€™s direction and projects the perturbed image
back onto a sphere centered around the original image.
PGD has been shown to outperform FGSM when applied
to models with robust defenses against adversarial attacks.
The Carlini and Wagner (C&W) white-box attack [4],
which was presented in 2016 as an optimization-based
method for generating adversarial instances, is another
well-known adversarial attack. In C&W, an optimization
problem is solved to identify the smallest perturbation (in
terms ofkk ) that leads to a misclassiï¬cation. A wide well-known adversarial attack. In C&W, an optimization
problem is solved to identify the smallest perturbation (in
terms ofkk ) that leads to a misclassiï¬cation. A wide
variety of learning modelsâ€”some with advanced defenses
against adversarial attacksâ€”have been demonstrated to be
susceptible to C&W.
Overall, a signiï¬cant amount of work has been done on
generating and enhancing adversarial attacks on classiï¬ca-
tion models (mostly in a white-box setting), and over the
past several years many efï¬cient methods have been devel-
oped. In order to protect the integrity and dependability of
models deployed in an increasing number of applications it
is crucial to continually seek out their weaknesses and cre-
ate strong defenses against adversarial attacks.
Digital adversarial attacks on object-detection mod-
els, which are used in a variety of systems, from surveil-
lance devices to autonomous cars, have become an increas-
ing concern. These attacks involve intentionally malicious
inputs to fool the model into generating bad predictions,
and they can have severe effects, including inaccurate ob-
ject identiï¬cation or failing to detect.
One of the most commonly used object-detection models
is You Only Look Once (YOLO) [26], which is based on a
single convolutional neural network (CNN) that simultane-
ously predicts the class and location of objects in an image.
Several studies have shown that YOLO is vulnerable to ad-
versarial attacks [13, 15, 22, 29]. For example, targeted per-
turbation attacks can be used to modify an input image in a
way that causes YOLO to misidentify or fail to detect cer-
tain objects. An untargeted attack, on the other hand, seeks to create adversarial examples that cause general disruption
to the modelâ€™s performance. Adversarial attacks can have a
signiï¬cant inï¬‚uence on object-detection models. Most prior
research regarding such attacks on object-detection mod-
els focus on white-box, gradient-based attacks, which is, by
and large, a non-real-world scenario.
Physical adversarial attacks pose an even greater threat
than digital ones. Most digital adversarial attacks need ac-
cess to the actual model in order to fool it. Further, many at-
tacks use global perturbation over pixel spaceâ€”e.g., chang-
ing the skyâ€™s pixelsâ€”thus rendering it less realistic. Phys-
ical adversarial attacks can be engendered in a variety of
ways, including covering an object with paint or some other
material [3, 31], applying stickers [8, 18] or camouï¬‚age
[7, 31], or changing the objectâ€™s shape or texture [14, 33].
Such changes are intended to alter how the object appears
to the model while maintaining it recognizable to humans.
Interestingly, the attack often looks identical to the naked
eyeâ€”but notto the model (as we shall also show below).
Physical adversarial attacks can have serious effects,
e.g., when an autonomous carâ€™s failed detection results in a
crash. Physical attacks can also be intentionally used to get
past security systems or enter restricted areas without au-
thorization. Again, most prior research on physical attacks
has been done using gradients, in a white-box setting.
Contrarily, we create adversarial patches in a black-
box manner , i.e., without the use of gradients, leveraging
thelearned image manifold of GANs [10].
Generative Adversarial Networks (GANs) : The qual-
ity of generative models used for image generation has im-
proved signiï¬cantly with the advent of GANs [10] and Dif-
fusion Models [12]. Herein, we focus on GANs, due to their
relatively small latent-space dimension and their fast image
generation. GANs utilize a learnable loss function, where
a separate discriminator network is used to distinguish be-
tween real and fake images, and the image generator net-
work is trained to synthesize images that are indistinguish-
able from real ones. Despite their visually appealing results,
GANs often face issues such as instability, vanishing gradi-
ents, and mode collapse. Researchers have suggested many
different GANs to address these issues [1, 16, 24]. Herein
we chose to use BigGAN2.
3. Method
Our objective is to generate physically plausible adver-
sarial patches, which are performant and appear realistic â€”
without the use of gradients . An adversarial patch is a spe-
ciï¬c type of attack, where an image is modiï¬ed by adding
a small, local pattern that engenders missclassiï¬cation. The
goal of such an attack is to intentionally mislead a model
into making an incorrect prediction or decision.
By â€œphysically plausibleâ€ we mean patches that not
only work digitally, but also in the physical world, e.g.,when printedâ€”and used. The space of possible adversarial
patches is huge, and with the aim of reducing it to afford a
successful search process, we chose to use pretrained GAN
generators.
Given a pretrained generator, we seek an input latent
vector , corresponding to a generated image that leads the
object detector to err. We leverage the latent spaceâ€™s (rela-
tively) small dimension, approximating the gradients using
an Evolution Strategy algorithm [32], repeatedly updating
the input latent vector by querying the target object detector
until an appropriate adversarial patch is discovered.
Figure 2 depicts a general view of our approach. We
search for an input latent vector that, given a pretrained gen-
erator, corresponds to a generated image that causes the ob-
ject detector to mistakenly detect that image as a person.
Algorithm 1 shows the pseudocode of the evolution strat-
egy. In each iteration t, we sample nGaussian noise values,
1;2;:::; n(there is one latent vector per noise value).
Then, we scale them using , add them to the latent vector egy. In each iteration t, we sample nGaussian noise values,
1;2;:::; n(there is one latent vector per noise value).
Then, we scale them using , add them to the latent vector
zt, and feed to the model F. The latent vector zt+1is then
updated using the weighted sum of the loss values Fifor
eachi;i2f1;2;:::ng. This step can be done using any
arbitrary optimizerâ€”herein we used Adam [17].
Algorithm 1: Evolution Strategy
Input: learning rate , noise standard deviation , initial
latent vectorz0, number of iterations T,
population size n
fort= 1;:::;T do
Sample1;2;:::;nN (0;I)
Compute ï¬tness Fi=F(zt+i)fori= 1;:::;n
Setzt+1 1
nPn
i=1Fii
end
3.1. Generating adversarial patches
Previous research optimized adversarial patches in pixel
space . We, on the other hand, focus on a GAN generatorâ€™s
latent space . Our resultant adversarial patch will be closer
to the manifold of natural pictures and hence appear more
realistic (because GANs learn a latent space that roughly
approximates the manifold of natural images). We employ
a generatorGthat has been previously trained on ImageNet
using a GAN framework, and we search the space of learned
natural image manifold using an evolution strategy.
The evolution strategy algorithm begins by using an
isotropic standard multivariate distribution, N(=0;=
Id), which parameterizes the evolved population with and
. We begin with an initial latent vector z0. We then ran-
domly sample nnoises1;2;:::; n2Rdusing the stan-
dard multivariate distribution, scale them by and add them
to the initial latent vector z0resulting with Z2Rdnâ€”
which then are fed to the generatior to create the population Figure 2. Naturalistic Black-Box Adversarial Attack: Overview of framework. The system creates patches for object detectors by using
the learned image manifold of a pretrained GAN ( G) on real-world images (as is often the case, we use the GANâ€™s generator, but do not
need the discriminator). We use a pretrained classiï¬er ( C) to force the optimizer to ï¬nd a patch that resembles a speciï¬c class, the TV
component in order to make the images as smooth as possible, and the detector ( D) for the actual detection loss. Efï¬cient sampling of the
GAN images via an iterative evolution strategy ultimately generates the ï¬nal patch.
of patchesP=G(Z)2Rn3HWâ€“ wherenstands for
the population size, 3 is the number of channels (RGB), H
is the patchâ€™s height, and Wis the patchâ€™s width.
Then, using gradient approximation through an evolu-
tion strategy, we repeatedly search the latent vector zthat
best achieves our objective function, which is:
Ltotal=Ldet+tvLtv+clsLcls; (1)
where:
â€¢Ldet: detection loss of object detector of the speciï¬c
class.
â€¢Ltv: total variation loss, to promote smoothness of
generated patch.
â€¢Lcls: classiï¬cation loss, to promote more-realistic
patch generation.
â€¢tvandclsare regularization weights.
We expound upon the these terms in below.
3.2. Adversarial gradient estimation
In order to generate patches that may deceive the target
object detector, the generator uses adversarial gradient esti-
mations as its primary navigation tool. We initially add thepatch onto a given image. In order to compute an adversar-
ial loss for the detection of bounding boxes (BBs), we feed
the image to the object detector.
Adversarial detection loss . Detection can be arbitrarily
produced by object detectors like YOLO [26]. We are in-
terested in minimizing two terms for the patch detection i:
its objectness probability Di
obj, which speciï¬es the modelâ€™s
conï¬dence regarding whether there is an object or not, and
the class probability Di
cls, which speciï¬es the modelâ€™s con-
ï¬dence of a speciï¬c class. In this paper we focused on gen-
erating patches that conceal humans. Thus, we want to min-
imize both the objectness Di
objand class probabilities Di
cls
for our generated patch with respect to the person class, i.e.,
minimizing the term:
Ldet=1
nnX
i=1detX
j=1Dj
obj(xi)Dj
cls(xi); (2)
wherenis the population size and detis the number of
human detections by the model. By minimizing Ldet, we
achieve a patch that minimizes the objectness and class
probabilities of the target class.
Physical transformations . We have no inï¬‚uence over
the adversarial patchâ€™s viewpoint, position, or size, with re-
spect to the images. In order to enhance the robustness of
our adversarial patch, we overlay it onto a human and gen- erate a variety of settings with distinct conï¬gurations. Fur-
thermore, we subject our created adversarial patch Pto var-
ious transformations, including rotation, brightness change,
and resizing, to mimic the different visual appearances it
may adopt in real-world situations. The transformations are
applied by the Patch Transformer (Figure 2).
Smoothness . To promote smoothness in the generated
image we apply the term Ltv, which represents the total
variation loss. The calculation of Ltvfrom a patch Pis
done as follows:
Ltv(P) =X
i;jq
(Pi+1;j"," This paper proposes a gradient-free method to generate naturalistic physical adversarial patches for object detectors using a pretrained generative adversarial network (GAN). The method works both digitally and physically and can be used to deceive deep learning systems by injecting carefully crafted inputs. Experiments were conducted using the Adam optimizer, BigGAN2, and two different object detectors (Tiny-YOLOv3 and Tiny-YOLOv4). Results showed that the patches generated by the proposed method were able to fool the object detectors, with a mean false negative rate of 21.9% and 40.4% for Tiny-YOLOv3 and Tiny-YOLOv4 respectively. This paper discusses various methods of adversarial attacks on deep learning visual classifiers, such as Wasserstein Generative Adversarial Networks (GANs), Adversarial Patch, Adversarial Camouflage, Robust Physical-World Attacks, Meta-Attack, Generative Adversarial Networks (GANs), Explaining and Harnessing Adversarial Examples, Denoising Diffusion Probabilistic Models, Naturalistic Physical Adversarial Patch, Adversarial Texture, Adversarial Attack and Defense of YOLO Detectors, A Style-"
10," MAP-Elites with Descriptor-Conditioned Gradients and
Archive Distillation into a Single Policy
Maxence Faldor
m.faldor22@imperial.ac.uk
Imperial College London
London, United KingdomFÃ©lix Chalumeau
f.chalumeau@instadeep.com
InstaDeep
Cape Town, South Africa
Manon Flageat
manon.flageat18@imperial.ac.uk
Imperial College London
London, United KingdomAntoine Cully
a.cully@imperial.ac.uk
Imperial College London
London, United Kingdom
ABSTRACT
Quality-Diversity algorithms, such as MAP-Elites, are a branch of
Evolutionary Computation generating collections of diverse and
high-performing solutions, that have been successfully applied
to a variety of domains and particularly in evolutionary robotics.
However, MAP-Elites performs a divergent search based on random
mutations originating from Genetic Algorithms, and thus, is limited
to evolving populations of low-dimensional solutions. PGA-MAP-
Elites overcomes this limitation by integrating a gradient-based
variation operator inspired by Deep Reinforcement Learning which
enables the evolution of large neural networks. Although high-
performing in many environments, PGA-MAP-Elites fails on several
tasks where the convergent search of the gradient-based operator
does not direct mutations towards archive-improving solutions. In
this work, we present two contributions: (1) we enhance the Policy
Gradient variation operator with a descriptor-conditioned critic
that improves the archive across the entire descriptor space, (2) we
exploit the actor-critic training to learn a descriptor-conditioned
policy at no additional cost, distilling the knowledge of the archive
into one single versatile policy that can execute the entire range
of behaviors contained in the archive. Our algorithm, DCG-MAP-
Elites improves the QD score over PGA-MAP-Elites by 82% on
average, on a set of challenging locomotion tasks.
1 INTRODUCTION
A fascinating aspect of evolution is its ability to generate a large
variety of different species, each being adapted to their ecological
niche. Inspired by this idea, Quality-Diversity (QD) optimization is
a family of evolutionary algorithms that aims to generate a set of
both diverse and high-performing solutions to a problem [ 3,7,32].
Contrary to traditional optimization methods that return a single
high-performing solution, the goal of QD algorithms is to illuminate
a search space of interest called descriptor space [27]. Producing
a large collection of diverse and effective solutions enables to get
multiple alternatives to solve a single problem which is useful
in robotics to improve robustness, recover from damage [ 6] or
reduce the reality gap [ 4]. Furthermore, conventional optimization
methods are prone to get stuck in local optima whereas keeping
diverse solutions to a problem can help to find stepping stones that
lead to globally better solutions [ 27,28]. Another benefit of diversity
Figure 1: DCG-MAP-Elites performs a standard MAP-Elites
loop of selection, variation, evaluation and addition. Two
complementary variation operators are applied: (1) a stan-
dard Genetic Algorithm (GA) variation operator for explo-
ration, (2) a Descriptor-Conditioned Policy Gradient (PG)
variation operator for fitness improvement. Concurrently to
the criticâ€™s training, the knowledge of the archive is distilled
in the descriptor-conditioned actor as by-product.
search is efficient exploration in problems where the reward signal
is sparse or deceptive [2, 8, 31].
MAP-Elites [ 27] is a conceptually simple but effective QD opti-
mization algorithm that has shown competitive results in a variety
of applications, to generate large collections of diverse skills. How-
ever, MAP-Elites relies on random variations that can cause slow
convergence in large search space [ 5,28,31], making it inadequate
to evolve neural networks with a large number of parameters.
In contrast, Deep Reinforcement Learning (DRL) [ 25,26] algo-
rithms combine reinforcement learning with the directed search to evolve neural networks with a large number of parameters.
In contrast, Deep Reinforcement Learning (DRL) [ 25,26] algo-
rithms combine reinforcement learning with the directed search
power of gradient-based methods in order to learn a single solu-
tion. DRL can surpass human performance at video games [ 40],
beat world champions in board games [ 35] and control complex
robots in continuous action spaces [ 17], which is a long-standing
challenge in artificial intelligence. Policy Gradient methods have
shown state-of-the-art results to learn large neural network policies
with thousands of parameters in high-dimensional state space and
continuous action space [18, 24, 36].
PGA-MAP-Elites [ 28] is an extension of MAP-Elites that inte-
grates the sample efficiency of DRL using the TD3 algorithm [ 15].arXiv:2303.03832v1  [cs.NE]  7 Mar 2023 This algorithm uses a Policy Gradient (PG) variation operator for
efficient fitness improvement, coupled with the usual Genetic Algo-
rithm (GA) variation operator. The PG variation operator leverages
gradients derived from DRL to improve fitness and drive mutations
towards the global optimum and is supported by the divergent
search of the GA variation operator for both exploration and opti-
mization [ 10]. Other recent works have also introduced methods to
combine the strength of QD algorithms with reinforcement learn-
ing [31, 38] on complex robotics tasks.
PGA-MAP-Elites achieves state-of-the-art performances in most
of the environments considered so far in the literature [ 28,31,38].
However, the PG variation operator becomes ineffective in tasks
where the global optimum is in an area of the search space that is
not likely to produce offspring that are added to the archive. For
example, consider a locomotion task where the fitness is the oppo-
site of the energy consumption and the descriptor is defined as the
final position of the robot. The global optimum for the fitness is the
solution that does not move in order to minimize energy consump-
tion. Thus, the PG variation operator will encourage solutions to
stay motionless, collapsing their descriptors to a single point, the
descriptor of the global optimum. Consequently, the PG variation
operator generates offspring that are discarded and no interesting
stepping stone is found, thereby hindering diversity.
In this work, we introduce Descriptor-Conditioned Gradients
MAP-Elites (DCG-MAP-Elites) that builds upon PGA-MAP-Elites
algorithm by enhancing the PG variation operator with a descriptor-
conditioned critic that provides gradients depending on a target de-
scriptor. The descriptor-conditioned critic takes as input a state and
a descriptor to evaluate actions. With such a descriptor-conditioned
critic, the PG variation operator can mutate solutions to produce
offspring with higher fitness while targeting a desired descriptor,
thereby avoiding to collapse the descriptor to a single point.
Furthermore, TD3 which is the DRL algorithm used by the PG
variation operator, requires to train an actor and a critic in parallel.
We take advantage of this intertwined actor-critic training to make
the actor descriptor-conditioned as well, allowing it to take actions
based on the current state and on an input descriptor we want to
achieve. Thus, instead of taking actions that maximize the fitness
globally, the actor now takes actions that maximize the fitness
while achieving a desired descriptor. At the end of training, we
can condition the actor on a desired descriptor to execute a policy
that takes actions that achieve the desired descriptor. On half of
the tasks, we observe that the descriptor-conditioned actor can
achieve the entire range of descriptors contained in the archive
with a similar QD-score, negating the burden of dealing with a
collection of thousands of solutions.
In summary, we present two contributions: (1) we enhance the
PG variation operator with a descriptor-conditioned critic, (2) we
distill the knowledge of the archive into one single versatile policy
at no additional cost. We compare our algorithm to four state-of-the-
art QD algorithms on four high-dimensional robotics locomotion
tasks. The results demonstrate that DCG-MAP-Elites has a QD-
score 82% higher than PGA-MAP-Elites on average.2 BACKGROUND
2.1 Problem Statement
We consider an agent sequentially interacting with an environment
at discrete time steps ğ‘¡for an episode of length ğ‘‡. At each time step
ğ‘¡, the agent observes a state ğ‘ ğ‘¡, takes an action ğ‘ğ‘¡and receives a
scalar reward ğ‘Ÿğ‘¡. We model it as a Markov Decision Process (MDP)
which comprises a state spaceS, a continuous action spaceA, a
stationary transition dynamics distribution ğ‘(ğ‘ ğ‘¡+1|ğ‘ ğ‘¡,ğ‘ğ‘¡)and a
reward function ğ‘Ÿ:SÃ—Aâ†’ R. In this work, a policy (also called
solution ) is a deterministic neural network parameterized by ğœ™âˆˆÎ¦, stationary transition dynamics distribution ğ‘(ğ‘ ğ‘¡+1|ğ‘ ğ‘¡,ğ‘ğ‘¡)and a
reward function ğ‘Ÿ:SÃ—Aâ†’ R. In this work, a policy (also called
solution ) is a deterministic neural network parameterized by ğœ™âˆˆÎ¦,
and denoted ğœ‹ğœ™:Sâ†’A . The agent uses its policy to select actions
and interact with the environment to give a trajectory of states,
actions and rewards. The fitness of a solution is given by ğ¹:Î¦â†’R,
defined as the expected discounted return Eğœ‹ğœ™Ãğ‘‡âˆ’1
ğ‘¡=0ğ›¾ğ‘¡ğ‘Ÿğ‘¡
.
The objective of QD algorithms in this MDP setting is to find
the highest-fitness solutions in each point of the descriptor space
D. The descriptor function ğ·:Î¦â†’D is generally defined by the
user and characterize solutions in a meaningful way for the type of
diversity desired. With this notation, our objective is to evolve a
population of solutions that are both high-performing with respect
toğ¹and diverse with respect to ğ·.
2.2 MAP-Elites
Multi-dimensional Archive of Phenotypic Elites (MAP-Elites) [ 27]
is a simple yet effective QD algorithm that discretizes the descriptor
spaceDinto a multi-dimensional grid of cells called archive Xand
searches for the best solution in each cell, see Alg. 4. The goal of the
algorithm is to return an archive that is filled as much as possible
with high-fitness solutions. MAP-Elites starts by generating ran-
dom solutions and adding them to the archive. The algorithm then
repeats the following steps until a budget of ğ¼solutions have been
evaluated: (1) a batch of solutions from the archive are uniformly
selected and modified through mutations and/or crossovers to pro-
duce offspring, (2) the fitnesses and descriptors of the offspring are
evaluated, and each offspring is placed in its corresponding cell if
and only if the cell is empty or if the offspring has a better fitness
than the current solution in that cell, in which case the current
solution is replaced. As most evolutionary methods, MAP-Elites
relies on undirected updates that are agnostic to the fitness objec-
tive. With a Genetic Algorithm (GA) variation operator, MAP-Elites
performs a divergent search that may cause slow convergence in
high-dimensional problems due to a lack of directed search power,
and thus, is performing best on low-dimensional search space [ 28].
2.3 Deep Reinforcement Learning
Deep Reinforcement Learning (DRL) [ 25,26] combines the rein-
forcement learning framework with the function approximation
capabilities of deep neural networks to represent policies and value
functions in high-dimensional state and action spaces. In opposition
to black-box optimization methods like evolutionary algorithms,
DRL leverages the structure of the MDP in the form of the Bellman
equation to achieve better sample efficiency. The objective is to
find an optimal policy ğœ‹ğœ™, which maximizes the expected return or
fitnessğ¹(ğœ‹ğœ™). In reinforcement learning, many approaches try to
estimate the action-value function ğ‘„ğœ‹(ğ‘ ,ğ‘)=Eğœ‹Ãğ‘‡âˆ’1
ğ‘¡=0ğ›¾ğ‘¡ğ‘Ÿğ‘¡|ğ‘ ,ğ‘
2 defined as the expected discounted return starting from state ğ‘ ,
taking action ğ‘and thereafter following policy ğœ‹.
The Twin Delayed Deep Deterministic Policy Gradient (TD3)
algorithm [ 15] is an actor-critic, off-policy reinforcement learn-
ing method that achieves state-of-the-art results in environments
with large and continuous action space. TD3 indirectly learns a
policyğœ‹ğœ™via maximization of the action-value function ğ‘„ğœƒ(ğ‘ ,ğ‘).
The approach is closely connected to Q-learning [ 15] and tries
to approximate the optimal action-value function ğ‘„âˆ—(ğ‘ ,ğ‘)in or-
der to find the optimal action ğ‘âˆ—(ğ‘ )=arg maxğ‘ğ‘„âˆ—(ğ‘ ,ğ‘). How-
ever, computing the maximum over action in maxğ‘ğ‘„ğœƒ(ğ‘ ,ğ‘)is in-
tractable in continuous action space, so it is approximated using
maxğ‘ğ‘„ğœƒ(ğ‘ ,ğ‘)=ğ‘„ğœƒ(ğ‘ ,ğœ‹ğœ™(ğ‘ )). In TD3, the policy ğœ‹ğœ™takes actions
in the environment and the transitions are stored in a replay buffer.
The collected experience is then used to train a pair of critics ğ‘„ğœƒ1,
ğ‘„ğœƒ2using temporal difference and target networks ğ‘„ğœƒ1â€²,ğ‘„ğœƒ2â€²are
updated to slowly track the main networks. Both critics use a single
regression target ğ‘¦, calculated using whichever of the two critics
gives a smaller target value and using target policy smoothing by
sampling a noise ğœ–âˆ¼clip(N(0,ğœ),âˆ’ğ‘,ğ‘):
ğ‘¦=ğ‘Ÿ(ğ‘ ğ‘¡,ğ‘ğ‘¡)+ğ›¾min
ğ‘–=1,2ğ‘„ğœƒğ‘–â€²
ğ‘ ğ‘¡+1,ğœ‹ğœ™â€²(ğ‘ ğ‘¡+1)+ğœ–
(1)
Both critics are learned by regression to this target and the policy
is learned with a delay, only updated every Î”iterations simply by
maximizing ğ‘„ğœƒ1withmaxğœ™E
ğ‘„ğœƒ1(ğ‘ ,ğœ‹ğœ™(ğ‘ ))
. The actor is updated
using the deterministic policy gradient:
âˆ‡ğœ™ğ½(ğœ™)=Eh
âˆ‡ğ‘ğ‘„ğœƒ1(ğ‘ ,ğ‘)|ğ‘=ğœ‹ğœ™(ğ‘ )âˆ‡ğœ™ğœ‹ğœ™(ğ‘ )i
(2)
2.4 PGA-MAP-Elites
Policy Gradient Assisted MAP-Elites (PGA-MAP-Elites) [ 28] is an
extension of MAP-Elites that is designed to evolve deep neural
networks by combining the directed search power and sample effi-
ciency of DRL methods with the exploration capabilities of genetic
algorithms, see Alg. 5. The algorithm follows the usual MAP-Elites
loop of selection, variation, evaluation and addition for a budget of
ğ¼iterations, but uses two parallel variation operators: half of the
offspring are generated using a standard Genetic Algorithm (GA)
variation operator and half of the offspring are generated using
a Policy Gradient (PG) variation operator. During each iteration
of the loop, PGA-MAP-Elites stores the transitions from offspring
evaluation in a replay buffer Band uses it to train a pair of critics
based on the TD3 algorithm, described in Alg. 6. The trained critic
is then used in the PG variation operator to update the selected
solutions from the archive for ğ‘šgradient steps to select actions
that maximize the approximated action-value function, as described
in Alg. 7. At each iteration, the critics are trained for ğ‘›steps of
gradients descents towards the target described in Eq. 1 averaged
overğ‘transitions of experience sampled uniformly from the replay
bufferB. The actor (also named greedy actor [ 28]) learns with a
delay Î”via maximization of the critic according to Eq. 2.
3 RELATED WORK
3.1 Scaling QD to Neuroevolution
The challenge of evolving diverse solutions in a high-dimensional
search space has been an active research subject over the recentyears. ME-ES [ 5] scales MAP-Elites to high-dimensional solutions
parameterized by large neural networks. This algorithm leverages
Evolution Strategies to perform a directed search that is more effi-
cient than random mutations used in Genetic Algorithms. Fitness
gradients are estimated locally from many perturbed versions of
the parent solution to generate a new one. The population tends
towards regions of the parameter space with higher fitness but it
requires to sample and evaluate a large number of solutions, mak-
ing it particularly data inefficient. In order to use the time step
level information and hence improve data efficiency, methods that
combine MAP-Elites with Reinforcement Learning [ 28,30,31,38]
have emerged and proved to efficiently evolve populations of high- level information and hence improve data efficiency, methods that
combine MAP-Elites with Reinforcement Learning [ 28,30,31,38]
have emerged and proved to efficiently evolve populations of high-
performing and diverse neural network for complex tasks. PGA-
MAP-Elites [ 28] uses policy gradients for part of its mutations, see
section 2.4 for details. CMA-MEGA [ 38] estimates descriptor gradi-
ents with Evolution Strategies and combines the fitness gradient
and the descriptor gradients with a CMA-ES mechanism [ 12,19].
QD-PG [ 31] introduces a diversity reward based on the novelty of
the states visited and derives a policy gradient for the maximiza-
tion of those diversity rewards which helps exploration in settings
where the reward is sparse or deceptive. PBT-MAP-Elites [ 30] mixes
MAP-Elites with a population based training process [ 21] to opti-
mize hyper-parameters of diverse RL agents. Interestingly, recent
work [ 37] scales the algorithm CMA-MAE [ 13] to high-dimensional
policies on robotics tasks with pure Evolution Strategies while
showing comparable data efficiency to QD-RL approaches. It shows
competitiveness but is still outperformed by PGA-MAP-Elites.
3.2 Conditioning the critic
None of the above methods takes a descriptor into account when
deriving policy gradients used to mutate solutions. In other words,
they do not use descriptor-conditioned policies nor descriptor-
conditioned critics as our method DCG-MAP-Elites does. The con-
cept of descriptor-conditioned critic is related to the concept of
Universal Value Function Approximators [ 33] and the most related
field to Quality-Diversity that uses it is Skill Discovery Reinforce-
ment Learning [ 1]. In VIC, DIAYN, DADS, SMERL [ 9,16,23,34],
conditioned actor-critic are used but the condition is a sampled prior
and does not correspond to a real posterior like in DCG-MAP-Elites.
Furthermore, those methods use diversity at the step level and not
explicitly at the trajectory level like ours. Finally, they do not use an
archive to store their population, resulting in much smaller sets of
final policies. Ultimately, it has been shown that behaviors evolved
by QD methods are competitive with skills learned by this family of
methods [ 1], in regards to their use for adaptation and hierarchical
learning.
3.3 Archive distillation
Distilling the knowledge of an archive into a single neural model
is an alluring process that reduces the number of parameters out-
putted by the algorithm and enables generalization and interpo-
lation/extrapolation. Although distillation is usually referring to
policy distillation â€” learning the observation/action mapping from
a teacher policy â€” we present archive distillation as a general term
referring to any kind of knowledge transfer from an archive to
3 another model, should it be the policies, transitions experienced in
the environment, full trajectories or discovered descriptors.
To the best of our knowledge, two QD-related works use the
concept of archive distillation. Go-Explore [ 8] stores an archive of
reached states and trains a goal-conditioned policy to reproduce the
trajectory of the policy that reached that state. Another interesting
approach to archive distillation is to learn a generative policy net-
work [ 22] over the policy contained in the archive. Our approach
DCG-MAP-Elites distills the experience of the archive into a single
versatile policy.
4 DCG-MAP-ELITES
Our new method Descriptor-Conditioned Gradients MAP-Elites
(DCG-MAP-Elites) overcomes limitations of PGA-MAP-Elites by
leveraging a descriptor-conditioned critic to improve the PG varia-
tion operator and concurrently distills the knowledge of the archive
in a single versatile policy as a by-product of the actor-critic train-
ing. The pseudocode is provided in Alg. 1. The algorithm follows
the usual MAP-Elites loop of selection, variation, evaluation and
addition for a budget of ğ¼iterations. Two complementary and inde-
pendent variation operators are used in parallel: 1) a standard GA
operator 2) a descriptor-conditioned PG operator. At each iteration,
the transitions from the evaluation step are stored in a replay buffer
and used to train an actor-critic pair based on TD3.
Contrary to PGA-MAP-Elites, the actor-critic pair is descriptor-
conditioned. In addition to the state ğ‘ and actionğ‘, the criticğ‘„ğœƒ(ğ‘ ,ğ‘|
ğ‘‘)also depends on the descriptor ğ‘‘and estimates the expected dis-
counted return starting from state ğ‘ , taking action ğ‘and thereafter
following policy ğœ‹andachieving descriptor ğ‘‘. Achieving descrip-
torğ‘‘means that the descriptor of the trajectory generated by the
policyğœ‹should have descriptor ğ‘‘. In addition to the state ğ‘ , the
actorğœ‹ğœ™(ğ‘ |ğ‘‘)also depends on the descriptor ğ‘‘and maximizes the
expected discounted return conditioned on achieving descriptor ğ‘‘.
Thus, the goal of the descriptor-conditioned actor is to achieve the
input descriptor ğ‘‘while maximizing fitness.
4.1 Descriptor-Conditioned Critic
Instead of estimating the action-value function with ğ‘„ğœƒ(ğ‘ ,ğ‘), we
want to estimate the descriptor-conditioned action-value function
withğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘). When a policy ğœ‹interacts with the environment
for an episode of length T, it generates a trajectory ğœ, which is a
sequence of transitions:
(ğ‘ 0,ğ‘0,ğ‘Ÿ0,ğ‘ 1),...,(ğ‘ ğ‘‡âˆ’1,ğ‘ğ‘‡âˆ’1,ğ‘Ÿğ‘‡âˆ’1,ğ‘ ğ‘‡)
with descriptor ğ·(ğœ‹)=ğ‘‘. We extend the definition of a transition
(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²)to include the descriptor ğ‘‘of the policy(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘).
Thus, a trajectory ğœwith descriptor ğ‘‘gives a sequence of transitions:
(ğ‘ 0,ğ‘0,ğ‘Ÿ0,ğ‘ 1,ğ‘‘),...,(ğ‘ ğ‘‡âˆ’1,ğ‘ğ‘‡âˆ’1,ğ‘Ÿğ‘‡âˆ’1,ğ‘ ğ‘‡,ğ‘‘)
However, the descriptor is only available at the end of the episode,
therefore the transitions can only be augmented with the descriptor
after the episode is done. In all the tasks we consider, the reward
function is positive ğ‘Ÿ:SÃ—Aâ†’ R+and hence, the fitness function
ğ¹and action-value function are positive as well. Thus, for any
sampled descriptor ğ‘‘â€²âˆˆD, we define the descriptor-conditioned
critic as equal to the normal action-value function when the policy
achieves the sampled descriptor ğ‘‘â€²and as equal to zero when theAlgorithm 1 DCG-MAP-Elites
Input: batch sizeğ‘, number of GA variations ğ‘”â‰¤ğ‘
Initialize archiveXwithğ‘random solutions and replay buffer B
Initialize critic networks ğ‘„ğœƒ1,ğ‘„ğœƒ2and actor network ğœ‹ğœ™
ğ‘–â†0
whileğ‘–<ğ¼do
train_actor_critic (ğ‘„ğœƒ1,ğ‘„ğœƒ2,ğœ‹ğœ™,B)
ğœ‹ğœ“1,...,ğœ‹ ğœ“ğ‘â†selection(X)
ğœ‹bğœ“1,...,ğœ‹ bğœ“ğ‘”â†variation_ga(ğœ‹ğœ“1,...,ğœ‹ ğœ“ğ‘”)
ğœ‹bğœ“ğ‘”+1,...,ğœ‹ bğœ“ğ‘â†variation_pg(ğœ‹ğœ“ğ‘”+1,...,ğœ‹ ğœ“ğ‘,ğ‘„ğœƒ1,B)
addition(ğœ‹bğœ“1,...,ğœ‹ bğœ“ğ‘,X,B)
ğ‘–â†ğ‘–+ğ‘
function addition (X,B,ğœ‹ğœ™,ğœ‹bğœ“...)
forğ‘‘â€²âˆˆD sampled from ğ‘solutions inXdo
(ğ‘“,transitions)â†ğ¹(ğœ‹ğœ™(.|ğ‘‘â€²))
insert(B,transitions)
forğœ‹bğœ“...do
(ğ‘“,transitions)â†ğ¹(ğœ‹bğœ“),ğ‘‘â†ğ·(ğœ‹bğœ“)
insert(B,transitions)
ifX(ğ‘‘)=âˆ…orğ¹(X(ğ‘‘))<ğ‘“then
X(ğ‘‘)â†ğœ‹bğœ“
policy does not achieve the sampled descriptor ğ‘‘â€². Given a transition
(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘), andğ‘‘â€²âˆˆD,
ğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘â€²)=(
ğ‘„ğœƒ(ğ‘ ,ğ‘),ifğ‘‘=ğ‘‘â€²
0, ifğ‘‘â‰ ğ‘‘â€²(3) insert(B,transitions)
ifX(ğ‘‘)=âˆ…orğ¹(X(ğ‘‘))<ğ‘“then
X(ğ‘‘)â†ğœ‹bğœ“
policy does not achieve the sampled descriptor ğ‘‘â€². Given a transition
(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘), andğ‘‘â€²âˆˆD,
ğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘â€²)=(
ğ‘„ğœƒ(ğ‘ ,ğ‘),ifğ‘‘=ğ‘‘â€²
0, ifğ‘‘â‰ ğ‘‘â€²(3)
However, with this piecewise definition, the descriptor-conditioned
action-value function is not continuous and violates the universal
approximation theorem continuity hypothesis [ 20]. To address this
issue, we introduce a similarity function ğ‘†:D2â†’]0,1]defined
asğ‘†(ğ‘‘,ğ‘‘â€²)=ğ‘’âˆ’||ğ‘‘âˆ’ğ‘‘â€²||D
ğ‘™ to smooth the descriptor-conditioned critic
and relax Eq. 3 into:
ğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘â€²)=ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘„ğœƒ(ğ‘ ,ğ‘)=ğ‘†(ğ‘‘,ğ‘‘â€²)Eğœ‹""ğ‘‡âˆ’1âˆ‘ï¸
ğ‘¡=0ğ›¾ğ‘¡ğ‘Ÿğ‘¡ğ‘ ,ğ‘#
=Eğœ‹""ğ‘‡âˆ’1âˆ‘ï¸
ğ‘¡=0ğ›¾ğ‘¡ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿğ‘¡ğ‘ ,ğ‘#
(4)
With Eq. 4, we demonstrate that learning the descriptor-conditioned
critic is equivalent to scaling the reward by the similarity ğ‘†(ğ‘‘,ğ‘‘â€²)
between the descriptor of the trajectory ğ‘‘and the sampled descrip-
torğ‘‘â€². Therefore, the critic target in Eq. 1 is modified to include the
similarity scaling and the descriptor-conditioned actor:
ğ‘¦=ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿ(ğ‘ ğ‘¡,ğ‘ğ‘¡)+ğ›¾min
ğ‘–=1,2ğ‘„ğœƒğ‘–â€²
ğ‘ ğ‘¡+1,ğœ‹ğœ™â€²(ğ‘ ğ‘¡+1|ğ‘‘â€²)+ğœ–|ğ‘‘â€²
(5)
If the sampled descriptor ğ‘‘â€²is approximately equal to the observed
descriptorğ‘‘of the trajectory ğ‘‘â‰ˆğ‘‘â€²then we have ğ‘†(ğ‘‘,ğ‘‘â€²)â‰ˆ1so the
reward is unchanged. However, if the descriptor ğ‘‘â€²is very different
from the observed descriptor ğ‘‘then, the reward is scaled down to
ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿ(ğ‘ ğ‘¡,ğ‘ğ‘¡)â‰ˆ0. The scaling ensures that the magnitude of the
reward depends not only on the quality of the action ğ‘with regards
to the fitness function ğ¹, but also on achieving the descriptor ğ‘‘â€².
Given one transition (ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘), we can generate infinitely many
critic updates by sampling ğ‘‘â€²âˆˆD. This is leveraged in the new
4 actor-critic training introduced with DCG-MAP-Elites, which is
detailed in Alg. 2 and section 4.3.
Algorithm 2 Descriptor-conditioned Actor-Critic Training
function train_actor_critic (ğ‘„ğœƒ1,ğ‘„ğœƒ2,ğœ‹ğœ™,B)
forğ‘¡=1â†’ğ‘›do
Sampleğ‘transitions(ğ‘ ,ğ‘,ğ‘Ÿ(ğ‘ ,ğ‘),ğ‘ â€²,ğ‘‘,ğ‘‘â€²)fromB
Sample smoothing noise ğœ–
ğ‘¦â†ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿ(ğ‘ ,ğ‘)+ğ›¾min
ğ‘–=1,2ğ‘„ğœƒâ€²
ğ‘–"," This paper presents DCG-MAP-Elites, a new algorithm that combines Multi-dimensional Archive of Phenotypic Elites (MAP-Elites) and Deep Reinforcement Learning (DRL) to find the highest-fitness solutions in a given descriptor space. The algorithm uses two variation operators, a standard GA operator and a descriptor-conditioned PG operator, to distill the knowledge of an archive into a single versatile policy. Experiments show that DCG-MAP-Elites outperforms the baselines on all metrics and tasks, but there is still room for improvement. The paper also provides the hyperparameters used for each task."
11," Multiplexed gradient descent: Fast online training of
modern datasets on hardware neural networks without
backpropagation
A. N. McCaughan1, B. G. Oripov2, N. Ganesh1, S. W. Nam1,
A. Dienstfrey1, S. M. Buckley1
1National Institute of Standards and Technology, Boulder, CO 80305
2University Colorado Boulder, Boulder, CO 80309
Abstract
We present multiplexed gradient descent (MGD), a gradient descent framework
designed to easily train analog or digital neural networks in hardware. MGD utilizes
zero-order optimization techniques for online training of hardware neural networks. We
demonstrate its ability to train neural networks on modern machine learning datasets,
including CIFAR-10 and Fashion-MNIST, and compare its performance to backprop-
agation. Assuming realistic timescales and hardware parameters, our results indicate
that these optimization techniques can train a network on emerging hardware platforms
orders of magnitude faster than the wall-clock time of training via backpropagation on
a standard GPU, even in the presence of imperfect weight updates or device-to-device
variations in the hardware. We additionally describe how it can be applied to existing
hardware as part of chip-in-the-loop training, or integrated directly at the hardware
level. Crucially, the MGD framework is highly exible, and its gradient descent pro-
cess can be optimized to compensate for specic hardware limitations such as slow
parameter-update speeds or limited input bandwidth.
1arXiv:2303.03986v1  [cs.LG]  5 Mar 2023 1 Introduction
Machine learning has proven an invaluable tool for a variety of applications [1]. However,
machine learning on traditional digital hardware is inecient, leading to a signicant eort
towards building custom hardware that can perform machine learning tasks at high speeds
with lower energy costs [2]. A number of hardware platforms have emerged using analog [3],
digital [4, 5], or mixed-signal processing [6] that will potentially oer increased operational
speeds and/or reduced energy costs [7]. However, many of the most promising hardware
instantiations only perform the inference part of the machine learning algorithm. Meanwhile
the larger portion of the energy cost is spent training on datasets [8], usually via gradient
descent. Backpropagation is by far the most commonly used method of computing the gra-
dient for gradient descent, but has proved to be challenging to implement in novel hardware
platforms [9].
Though often conated, training via gradient descent does not require backpropagation
{ backpropagation is only used to calculate the gradient. Other methods for computing the
gradient in neural networks exist, but are much less ecient in software than backpropagation
and so are rarely used in today's machine learning applications. This is not generally true in
hardware, where backpropagation may not only be challenging to implement, but also may
not be the most ecient way to compute the gradient.
Of particular interest in hardware are model-free methods, in which we require no knowl-
edge of the internal structure of the network (e.g topology, activation function, derivatives,
etc), only the ability to perturb the network's parameters and measure the network's re-
sponse. The simplest example of such a method is nite-dierence [10], which has been
employed for chip-in-the-loop training [11]. However, nite-dierence has several other dis-
advantages that prevent its widespread implementation in hardware, including the require-
ments for extra memory at every synapse and global synchronization. Fortunately, there
are a variety of other model-free methods that overcome some of the issues associated with
nite-dierence [12, 13].
2 In this paper, we show that model-free perturbative methods can be used to eciently
train modern neural network architectures in a way that can be implemented natively within
emerging hardware. These methods were investigated for training VLSI neural networks
beginning in the 1990s [14, 15, 16, 17, 18, 19, 20, 21, 22, 23], and more recently on memristive
crossbars [24] and photonic hardware [25], but all these demonstrations have been very
limited in scale, comprising small datasets with only a few neurons. Below we describe a
framework for applying these techniques to existing hardware at much larger scales, with
an emphasis on creating simple, highly-localized circuits that could be implemented on-chip
if desired. The framework is also extensible to training existing hardware systems via a
chip-in-the-loop technique. We note that these methods have also been adapted in forward
gradient approaches using auto-dierentiation, which have attracted recent interest in the
machine learning literature [26, 27, 28].
We show that under realistic assumptions of the operating timescales of analog and digital
hardware neural networks, one can train hardware to solve modern datasets such as CIFAR-
10 faster than training a software network on a GPU, even in the presence of signal noise
and device-to-device variations in the hardware. A major advantage of this framework is
that it can be used to perform online training of hardware platforms originally designed only
for inference while making minimal hardware modications.
2 Multiplexed gradient descent
2.1 Computing the gradient with perturbations
We begin with the basic assumption that we have some hardware with programmable pa-
rameters (e.g. weights and biases) that can perform inference. Our goal is to augment the
hardware minimally such that it can also be trained via gradient descent. We will show
how to congure the hardware such that the network as a whole automatically performs
gradient descent, without backpropagation. As an example, assume we have a hardware
3 instantiation of a feedforward multi-layer neural network as shown in Fig. 1. The hardware
takes time-varying inputs x(t), training target ^ y(t), has variable parameters , outputs the
inferencey(t), and computes a cost C(y(t);^y(t)). To allow us to compute the gradient of
such a system, we rst add a small time-varying perturbation ~i(t) to each parameter base
valuei(Fig. 1a, inset). This perturbation will slightly modulate the cost C, and that mod-
ulation will be fed back to the parameters. This process will ultimately allow us to extract
the gradient of the system.
C
neuron
synapse
...
Êƒ
 update 
(a)
(c)(b)
...... x1
x2
x3sinusoidalt
sequential
code
Figure 1: (a) Schematic diagram showing the operation of the MGD framework in a feed-
forward neural network using example sinusoidal perturbations. (a, inset) Each parameter
iis modulated slightly from its base value iby the perturbation ~i. The result of these
perturbations causes a modulation in the cost ~C, which is globally broadcast back to all
the parameters. (b) A homodyne detection process is used to compute the partial gradient
approximations Gifrom the integrated product of iand ~C. This partial gradient is then
used to update iin the approximate direction of the gradient. (c) Example perturbation
types that can be used with this process.
Although the perturbations can take a variety of dierent forms, we will rst describe
this process by using sinusoidal perturbations as they are conceptually straightforward to
understand. In this scenario, each parameter iis slightly modulated at a unique frequency
!iand amplitude  , giving the perturbation ~i(t) = sin(!it). As each parameter is
4 modulated, it slightly changes y(t) which in turn changes the cost. Thus, if the parameters
are modulated by frequencies !1,!2,!3, etc, those same frequencies will necessarily appear
as small modulations in the cost ~C(t) on top of the baseline (unperturbed) cost value C0,
such that
C(t) =C0+~C(t) =C0+X
iCisin(!it) (1)
If we remove C0, we are left with a time varying signal ~C(t) =P
iCisin(!it) corre-
sponding only to the eects of our parameter perturbations. The amplitude  Ciis simply
the amplitude of change in the cost due to ~i(t), the perturbation of parameter i.
Since the gradient with respect to the cost dC=d is composed solely from the partial
gradientsdC=d = (@C=@ 1; @C=@ 2; :::), if we can extract  Cifor each parameter we
can produce an estimate of the complete gradient G= (C1=1;C2=2;:::). Now the
task becomes to extract individual  Ciout of the summed signal ~C(t). Fortunately, to
extract a given  Ci, all we need to do is integrate the product of the input perturbation
~i(t) with ~C(t). The integration takes the form of a homodyne detection, where unwanted
perturbations (frequencies) from other parameters are eliminated via integration:
Gi=1
2
i1
TZT
t=0X
kCksin(!kt)isin(!it)dt
=Ci
iasT!1(2)
where 1=2
iis a normalization constant.
The valueGiis the approximation for the partial gradient for parameter i.Gapproaches
the exact gradient when both T!1 and the amplitude of the perturbation  iapproaches
zero, and is only an approximation otherwise. Fortunately, even at realistic timescales and
amplitudes, Gcontains meaningful information and can be used to perform gradient de-
scent [12].
5 For illustrative purposes we have described the algorithm using sinusoidal parameter
perturbations. However, any collection of orthogonal, mean zero perturbations can be used
[13], including a variety of analog and discrete perturbations as shown in Fig. 1c. In general,
we will be integrating the product ei(t) = ~C(t)~i(t)=2
i, which we refer to as the error
signal, and Giwill be given by1
Gi=ZT
t=0~C(t)~i(t)
2
idt (3)
We discuss the eects of changing the perturbation type in Section 3.4. We also note that
although many of the quantities described here are time-varying, in the following sections
we will drop the explicit time dependence notation for the sake of brevity.
2.2 Gradient descent in the MGD framework
Here we describe the practical implementation of a model-free gradient descent framework
in hardware, which we term multiplexed gradient descent (MGD). To better understand
the algorithm from a hardware perspective, we will run through the same computation
previously described, but from the viewpoint of a single parameter (e.g. a synapse weight in
a hardware neural network). The process begins with the application of a local perturbation
~ithat slightly modies the base value of the parameter i(Fig. 1a, inset). As previously
described, this perturbation { and any other perturbations from other parameters { induce
a change in the cost ~Con top of the baseline cost C0such that the cost at the output is
C=C0+~C.~Cmay be extracted from Ceither by direct subtraction of C0or, in some
analog scenarios, by a simple highpass lter. The resulting ~Csignal is broadcast globally
to all parameters, so our parameter ihas access to it. (Note that although Fig. 1 shows a
wireless broadcast tower for purposes of clarity, in most hardware platforms this will be a
1Note that here and in the simulation results, Giis being accumulated with time and is not normalized by
1=T, unlike Eq. 2. As described later, this allows us to vary the integration time without greatly impacting
the rate of training{equivalently, one can integrate for a long time resulting in a large step down the gradient,
or one can take a series of shorter steps instead and travel approximately the same distance along the gradient.
6 wired connection). However, we must assume that parameters other than the ith are also
causing modulations in the cost as well. To our parameter i, these other modulations are
unwanted and must be ltered out. As shown in Fig. 1b, for the parameter ito extract only
its own eect on the cost, it can just integrate the product of its local perturbation ~iand
the global cost signal ~Cit receives. This has the eect of isolating the contribution from i
due to the pairwise orthogonality of the perturbation signals. From Eq. 3, this integration
produces the partial gradient approximation Gi/Ci=i. The parameter can then use
theGivalue to directly to reduce the cost by updating itself according to a gradient descent
step
i!i"," This paper presents the Multiplexed Gradient Descent (MGD) algorithm, a model-free perturbative technique that is orders of magnitude faster than backpropagation and can be used to train hardware platforms based on emerging technologies. It examines the use of perturbative techniques to train large and small hardware systems, such as photonic or memristive crossbar hardware, without redesigning the hardware. It also looks at various research papers on topics such as distributed learning for analog VLSI neural networks, FPGA implementations of pulse density neural networks, memristor-based neural networks, single chip photonic deep neural networks, and various learning rules and algorithms for spiking neural networks. This research was funded by NIST and University Colorado Boulder."
12," 1 Wang et al. Evolutionary Deep Nets for Non-Intrusive Load Monitoring Abstractâ€”Non-Intrusive Load Monitoring (NILM) is an energy efficiency technique to track electricity consumption of an individual appliance in a household by one aggregated single, such as building level meter readings. The goal of NILM is to disaggregate the appliance from the aggregated singles by computational method. In this work, deep learning approaches are implemented to operate the desegregations. Deep neural networks, convolutional neural networks, and recurrent neural networks are employed for this operation. Additionally, sparse evolutionary training is applied to accelerate training efficiency of each deep learning model. UK-Dale dataset is used for this work.   Index Termsâ€”deep learning, load disaggregation, non-intrusive load monitoring, sparse evolutionary training.    I. INTRODUCTION Non-Intrusive Load Monitoring (NILM, alternative to energy disaggregation) is a computational technique to track the electricity consumption at appliance level based on a single sensor at building level, instead of imbedding any sensor on an individual appliance [1]. This work concentrates NILM in aspect of residential electricity consumption. Significances of NILM for residential energy efficiency are summarized: as compared with intrusive monitoring, NILM performs without direct sensor network installation to individual appliance; consequently, NILM is an effective implementation to physical and computing cost, and a securable monitoring technology for privacy of the residential consumers [2]. As the benefits of NILM, first, the residential consumers receive energy saving services that enhance electricity billing with specific appliance level advice, mobile-application-based energy audits, and real time consumption information; second, utility provides service of energy trading and planning and regulatory incentives; third, home service sector delivers maintenance for Heating, Ventilation and Air Conditioning (HVAC) systems, retrofits, advertising and electricity security services [3].  A framework of NILM approach is given by Zoha et al. [4]. Accordingly, NILM undertakes three modules: first, data acquisition, feature engineering, and inference and learning. The data acquisition module collects global (or aggregated) data, such as voltage, current, and power at different frequencies in accordance of requirements. The feature engineering module extracts characteristics of the data which indicate the activations of the appliances. Furthermore, the features are classified in two types: steady-state (for example, Voltage-Current trajectory) and transient-sate (for example, start-up current waveforms). The residential appliances are categorized in four types: two-state (for example, lamp, which has on and off state), multi-state (for example, washing machine), continuously variable devices (CVD) (for example, power drill and dimmer light), and permanent devices (for example, smoker detector). The two types of feature are extracted to describe each type of appliance. The inference and learning module disaggregate induvial appliance data from the aggregated data and identifies the appliance in specific based on the features. Furthermore, ground truth data of each appliance are collected for the learning system training.  Common NILM learning methods are HMM-based methods. Hidden Markov Model (HMM) is applied when the concept of NILM is originally proposed by Hart [5]. Factorial Hidden Markov Model (FHMM) [6], which is employed for disaggregation in NILM commonly [7]. Additionally, other well-known learning methods, such as support vector machine (SVM) [8] [9], neural networks [10] [11], and Bayesian models [12] [13], are evaluated as outperformed approaches to NILM. Accordingly, first, based on steady and transient features, SVM appears efficiency to disaggregate four types of appliance, while neural networks appears efficiency to appliance type of two- and multi-state and CVD; second, HMM-based and Bayesian methods perform appears efficiency to disaggregate four types of appliance, while neural networks appears efficiency to appliance type of two- and multi-state and CVD; second, HMM-based and Bayesian methods perform disaggregation of two- and multi-state appliances by steady-state features. In summary, above-mentioned framework and learning methods are feature-based approaches. Deep learning methods are applied and evaluated as efficiency approach to NILM instead of feature engineering [1]. This work focuses on the deep learning approach.  The objective of this work is formed to improve disaggregation accuracy and computing efficiency of NILM by deep learning approach. Accordingly, by observing above-mentioned methods, even high accuracies (97%-99%) [4] are achieved, a general method to disaggregate all types of appliance is not defined. Two- and multi-state appliances are identified at a high accurate because steady-state features are sufficient to characterize such types of appliances with lower frequency samples; however, CVD and permanent devices challenge the disaggregation performance because high-frequency samples that describe detail significance of transient state to the consumption event is required to train the models. When high-frequency sample is employed, cost of data acquisition increases. Computing efficiency gets adverse impact on the high-frequency condition. Moreover, feature engineering requires human-labor involvement and additional extraction and selection model, which cause more computing Evolutionary Deep Nets for Non-Intrusive Load Monitoring Jinsong Wang, and Kenneth A. Loparo, Life Fellow Preprint DOI: 10.13140/RG.2.2.25983.28324 cost for large volume of data at high-frequency. Due to above issues, this work employs three deep learning models: deep neural networks (DNN) [14], convolutional neural networks (CNN) [15], and recurrent neural networks (RNN) [16], to NILM, instead of feature-based methods. Sparse evolutionary training (SET) [17] are applied to optimize the computing efficiency of each deep learning model.  II. DATA The UK-DALE [18], which is stand for United Kingdom domestic appliance-level electricity demand, dataset is used in this work. The dataset records active power (kilowatts or kW) which is collected at very 6 second for 5 years in file name by data acquisition channel number. Each channel dataset is the raw data of the electricity consumption of each appliance.  Channel datasets of dishwasher, washing machine, microwave and fridge selected for the NILM experiment in this work. They correspond to four types of appliance, respectively and conduct the ground truth of the disaggregation.  Training and testing dataset are a synthesis aggregated power dataset constructed by the selected appliance due to the issues that the power of ground truth aggregated data is much larger than the sum of the selected appliance power at one time step, which is large noise to the classification target appliance. The training and testing dataset are constructed in following steps: Step 1: within each individual appliance channel dataset, length of a time window is set up as 1 hour, in which 600 data points are included, and length of a forward moving step is setup as 5 minutes, in which 50 data points are included. Each time window conducts one data entry. Step 2: validity of data in the time windows is defined by following condition: if the appliance appears that active power consumption events add up to more than 10 minutes with an hour (one time window), the time window is a valid data entry. A single power measurement greater than zero indicates one active power consumption event.  Step 3: the validated data entries are combined into a matrix. Four appliance channels correspond to the matrixes, data_M1~4, respectively, and the number of the validated data entries of each matrix is calculated as num_1~4.  Step 4: a binary (0 or 1) variable ğ‘£ğ‘’ğ‘_01 and a numeric integer variable ğ‘£ğ‘’ğ‘_ğ‘–ğ‘› are initiated.  ğ‘£ğ‘’ğ‘_01 is a 4-dimensional vector, in which four binary values are random generated. ğ‘£ğ‘’ğ‘_ğ‘–ğ‘› is a 4-dimensional vector, in which four elements are randomly selected from the range of 0 to num_1~4, respectively. Each integer element represents a valid data entry in the corresponding matrix. The subjective of this step is to construct activation combination of the appliances randomly. Step 5: synthesis aggregated power data is generated. The synthesis aggregated power is sum of the power of four selected appliances. In one iteration, a single value in the data entries that has the corresponding representatives of valid data entries in ğ‘£ğ‘’ğ‘_ğ‘–ğ‘› associated with â€œ1â€ of the activation status in ğ‘£ğ‘’ğ‘_01 are summed. Having 10000 repetitions, randomly combined synthesis aggregated power data emeries are generated as the featured input dataset.  III. METHODS 1) Deep Neural Networks  Artificial neural networks (ANN) [19] takes inspiration of biological neural networks is a general name of the neural network family. It powerfully conducts all types of machine learning tasks: supervised learning [20], unsupervised learning [20], and reinforcement learning [21]. ANN is a mathematical model constructed by neurons connected by weights. The neurons only connect to the ones in immediate next consecutive layer. The single neuron composed by incoming and outcoming weights and an activation function. Neurons assemble in layers of ANN. If an ANN appears a fully-connected structure, the neurons in one layer are connected to every single neuron in the consecutive layer.  ANN models are built in various architectures according to their purposes. appears a fully-connected structure, the neurons in one layer are connected to every single neuron in the consecutive layer.  ANN models are built in various architectures according to their purposes. Multi-layer perceptron (MLP) [22] is a common ANN architecture that is a feed-forward training model mapping an input set to the targeted output sets, nonlinearly. â€œmulti-layerâ€ describes that the model is formed by an input and output layer and one or more hidden layer(s). The information flow (datasets or features) starts at the input layer, passes through the hidden layers towards the output layer. Thus in usage of supervised learning, MLP is evaluated as an universal estimator for regression and classification cases.  Convolutional neural networks (CNN) are constructed by a MLP in which a convolutional layer is added before the first hidden layer in. The convolutional layer filters the input information flow into a small group of receptive fields which are the down-sampled feature maps. A fully-connected layer are applied after the convolutional layer to train the input feature maps [14].  Recurrent neural network (RNN) trains the neural networks in cycle procedures that the output from previous neurons is assigned to the input to neuron at current time step. Hidden states are labeled in order that the history of outputs vector is computed, and the shared weights are across the procedures [14]. 3 Wang et al. Evolutionary Deep Nets for Non-Intrusive Load Monitoring In recent years, rapidly developed processing power enables even hundred-layer-depth of hidden layers in neural network, which is entitled as â€œdeep learningâ€. Such MLP is named deep neural networks (DNN) in general [14]. A larger number of hidden layers achieves higher accuracy while results more computing cost and complexity for a fully-connected DNN; therefore, SET is applied to improve the computing efficiency.   2) Sparse Evolutionary Training (SET) Sparse Evolutionary Training (SET) give expressions to three straightforward significances: the nets have relatively few connections, few hubs and short paths. Applying SET to the deep learning models is motivated by its efficiency to simplify fully-connected networks to adaptive sparse connected networks and optimize training time with limit computing resource [17]. The general training procedure of SET is that:  First, having initialized a fully-connected ANN model, each fully-connected layer (hidden layer) is replaced by a sparse connected layer. The neurons in the fully-connected layer randomly connect to next layer by Erdod-Renyi topology [23]. Each Then the connection weights are represented in a sparse matrix. The matrix is assigned a coefficient that indicates sparse level. Additionally, each weight is assigned a fraction that indicates the validity of the weight. The fractions are computed and updated at each epoch.  Second, for each epoch during the training phase, first, a feed-forward training with weights update is processed; then, in the sparse weight matrix, the weights with smallest positive and the largest negative fraction are removed and replace by new weights. Then the training is process again with the updated weigh matrix.    IV. EXPERIMENT 1) Set Up  Three deep learning methods: deep-MLP (or DNN), CNN, and RNN are implemented for NILM models. DNN is composed by one input layer, two hidden layers, and one, output layer. CNN contains a one-dimension convolution layer in addition to DNN. Batch normalization function [24] is used to normalize data after the convolution function in order to fit the data to next fully-connected layer. A maxpooling1d layer is added to reduce the complexity of the output and prevent overfitting of the data. 0.2 dropout layer is added, that randomly assigns 0 weights to the neurons in the network by a rate. With this operation, the network becomes less sensitive to react to smaller variations in the data. Furthermore, it increase accuracy on unseen datasets [25]. RNN is constructed by a simple recurrent type: ono-to-one. The input data is the synthesis aggregated power data, which is divided to 8:2 for training and testing, respectively. The output are the classification of the appliance. SET is applied to accelerate each deep learning models. Disaggregation performances of the standard DNN, CNN, and RNN are compared with SET boosted models: SET- DNN, SET-CNN, and SET-RNN, by their losses and accuracies plots. Evaluation matrixes of mean absolute error [14], precision [14], and recall [14] to compare the results.  2) Results and Discussions Having investigated the accuracy and loss plots, SET-CNN performs the best disaggregation operation. CNN achieves highly similar performance as SET-CNN. DNN appears unstable obvious shifts of the accuracy and loss curves in its disaggregation performance, graphically, for example, the accuracy and loss plots in cases of fridge and dishwasher.  As observed from the cases of microwave and washing machine, according to the type of deep learning model, convolution-based methods achieve similar accuracy among same model, and higher accuracy than the standard-MLP-based models (DNN and SET-DNN). Moreover, DNN and SET-DNN operate disaggregation in similar performance. The convolution layer filters the large input of active power data to small samples for the hidden layers in training procedures, that is the reason to the outperformances of the convolution-based models. Additionally, RNN and SET-RNN large input of active power data to small samples for the hidden layers in training procedures, that is the reason to the outperformances of the convolution-based models. Additionally, RNN and SET-RNN perform disaggregation operation below other model. RNN models have advantage to sequential data; however, this work apply time window which does not require time series.   Effect of SET is obviously presented in cases of fridge, in Fig. 1.  plots of loss and accuracy. Preprint DOI: 10.13140/RG.2.2.25983.28324 
which SET-accelerated learning models achieve better performance. Additionally, the cases of microwave and washing machine indicate a slight effect of SET on appliance consumption disaggregation. In case of dishwasher, SET performs the worst accuracy of disaggregation, which is even lower than the standard DNN. The reason of the unstable effect to the learning models is that the models are constructed at relative simple architectures. Two hidden layers does not indicate high density and complexity required optimization. Moreover, simple models is optimized with unsuitable sparse level; consequently, the network has less connected neuron and decrease training efficiency.  Furthermore, the plot of evaluation matrixes demonstrated above discussions and present graphical comparison of each models. Moreover, accordingly, type of appliance has impact on the disaggregation accuracy. Microwave and washing machine have significant and longer power consumption events, which make the model operate disaggregation efficiently.  V. CONCLUSION NILM models are implemented by DNN, CNN, and RNN. SET is used to accelerate the training efficiency. The highest disaggregation accuracy is 97.6%. CNN and SET-CNN outperforms other deep learning models. From the result investigations, first, model has significant effect to the disaggregation performance; second, SET has less effect to neural networks with relative simple architectures; appliance type and consumption behavior that indicate long and significant consumption event are efficient to disaggregate. Future work is required to improve the disaggregation accuracy, apply SET to complex neural network to demonstrate the efficiency acceleration, and applied SET-based deep 
Fig. 2.  plots of evaluation matrix. 5 Wang et al. Evolutionary Deep Nets for Non-Intrusive Load Monitoring learning to all types of appliances with real power data.     REFERENCES  [1]  J. Kelly and W. Knottenbelt, ""Neural NILM: Deep Neural Networks Applied to Energy Disaggregation,"" in ACM BuildSys, Seoul, 2015.  [2]  K. C. ARMEL, A. GUPTA, G. SHRIMALI and A. ALBERT, ""IS DISAGGREGATION THE HOLY GRAIL OF ENERGY EFFICIENCY? THE CASE OF ELECTRICITY,"" Precourt Energy Efficiency Center, Stanford, 2012. [3]  D. Christensen, L. Earle and B. Sparn, ""NILM Applications for the Energy-Efficient Home,"" National Renewable Energy Laboratory, Golden, 2012. [4]  A. Zoha, A. Gluhak, M. A. Imran and S. Rajasegarar, ""Non-Intrusive Load Monitoring Approaches for Disaggregated Energy Sensing: A Survey,"" Sensors, pp. 16838-16866, 2012.  [5]  G. Hart, ""Nonintrusive appliance load monitoring,"" IEEE Proc., vol. 80, p. 1870â€“1891, 1992.  [6]  Z. Ghahramani and M. I. Jordan, ""Factorial hidden markov models,"" Machine Learning , vol. 29, no. (2â€“3), p. 245â€“273, 1997.  [7]  H. Kim, M. Marwah, M. Arlitt, G. Lyon and J. Han, ""Unsupervised disaggregation of low frequency power measurements,"" in the SIAM Conference on Data Mining, 2011.  [8]  S. Patel, T. Robertson, J. Kientz, M. Reynolds and G. Abowd, ""At the Flick of a Switch: Detecting and Classifying Unique Electrical Events on the Residential Power Line,"" in the 9th International Conference on Ubiquitous Computing, Innsbruck, 2007.  [9]  M. Marceau and R. Zmeureanu, ""Nonintrusive load disaggregation computer program to estimate the energy consumption of major end uses in residential buildings,"" Energ. Convers. Manag, vol. 41, p. 1389â€“1403, 2000 .  [10]  D. Srinivasan, W. Ng and A. Liew, ""Neural-network-based signature recognition for harmonic source identification,"" IEEE Trans. Power Del., vol. 21, p. 398â€“405, 2006 .  [11]  A. Ruzzelli, C. Nicolas and A. Schoofs, ""Oâ€™Hare, G.M.P. Real-Time Recognition and Profiling of Appliances through a Single Electricity Sensor,"" in the 7th Annual IEEE Communications Society Conference on Sensor, Mesh and Ad Hoc Communications and Networks, Boston, 2010.  [12]  A. Marchiori, D. Hakkarinen, Q. Han and L. Earle, ""Circuit-level load monitoring for household energy management,"" IEEE Pervas. Comput, vol. 10, p. 40â€“48, 2011.  [13]  M. Zeifman, ""Disaggregation of home energy display data using probabilistic approach,"" IEEE Trans. Consum. Electron , vol. 58, pp. 23-31, 2012.  [14]  I. Goodfellow, Y. Bengio and A. Courville, Deep Learning, Amherst: MIT Press, 2016.  [15]  Y. B. L. B. Y. &. H. P. LeCun, ""Gradient-based learning applied to document recognition,"" Proc. IEEE , vol. 86, p. 2278â€“2324 , 1998.  [16]  A. e. a. Graves, ""A novel connectionist system for unconstrained handwriting recognition,"" IEEE Trans. Pattern Anal. Mach. Intell., vol. 31 , p. 855â€“868, 2009.  [17]  D. C. Mocanu, E. Mocanu, P. Stone, P. H. Nguyen, M. Gibescu and A. Liotta, ""Scalable training of artificial neural networks with adaptive sparse connectivity inspired by network science,"" NATURE COMMUNICATIONS, vol. 9, p. 2383, 2018.  [18]  J. Kelly and W. Knottenbelt1, ""The UK-DALE dataset, domestic appliance-level electricity demand and whole-house demand from five UK homes,"" SCIENTIFIC DATA, vol. 7, 2015.  [19]  C. M. Bishop, Pattern Recognition and Machine Learning, Secaucus: Springer-Verlag New York, 2006.  [20]  T. T. R. &. F. J. Hastie, The Elements of Statistical Learning, New York: Springer New York , 2001.  [21]  R. S. &. B. A. G. Sutton, Introduction to Reinforcement Learning, Cambridge: MIT Press, 1998.  [22]  F. Rosenblatt, Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms, Washington: Spartan , 1962.  [23]  P. &. R. A. ErdÃ¶s, ""On random graphs i,"" Publ. Math.-Debr, vol. 6 , p. 290â€“297, 1959.  [24]  S. Ioffe and C. Szegedy, ""Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift,"" 2 2015. [Online]. Available: https://arxiv.org/pdf/1502.03167.pdf. [25]  N. Srivastava, G. C. Szegedy, ""Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift,"" 2 2015. [Online]. Available: https://arxiv.org/pdf/1502.03167.pdf. [25]  N. Srivastava, G. Hinton, A. Krizhevsk, I. Sutskever and R. Salakhutdinov, ""Dropout: A Simple Way to Prevent Neural Networks from Overfitting,"" Journal of Machine Learning Research, no. 15, pp. 1929-1958, 2014.","

This paper presents a novel approach to non-intrusive load monitoring (NILM) using evolutionary deep nets. The proposed method uses a genetic algorithm to optimize the structure of a deep neural network, allowing for improved accuracy and efficiency in NILM. Batch Normalization and Dropout are also discussed as methods to improve the accuracy and speed of deep neural network training. The results of the experiments show that the proposed method outperforms existing NILM techniques."
13," SYMBOLIC SYNTHESIS OF NEURAL NETWORKS
Eli Whitehouse
New York, NY 10024
eliw55@gmail.com
ABSTRACT
Neural networks adapt very well to distributed and continuous representations, but struggle to learn
and generalize from small amounts of data. Symbolic systems commonly achieve data efï¬cient
generalization by exploiting modularity to beneï¬t from local and discrete features of a representation.
These features allow symbolic programs to be improved one module at a time and to experience
combinatorial growth in the values they can successfully process. However, it is difï¬cult to design
components that can be used to form symbolic abstractions and which are highly-overparametrized
like neural networks, as the adjustment of parameters makes the semantics of modules unstable.
I present Graph-based Symbolically Synthesized Neural Networks (G-SSNNs), a form of neural
network whose topology and parameters are informed by the output of a symbolic program. I
demonstrate that by developing symbolic abstractions at a population level, and applying gradient-
based optimization to such neural models at an individual level, I can elicit reliable patterns of
improved generalization with small quantities of data known to contain local and discrete features.
The paradigm embodied by G-SSNNs offers a route towards the communal development of compact
and composable abstractions which can be ï¬‚exibly repurposed for a variety of tasks and high-
dimensional media. In future work, I hope to pursue these beneï¬ts by exploring more ambitious
G-SSNN designs based on more complex classes of symbolic programs. The code and data associated
with the reported results are available here.
Keywords neural networkssymbolic programs graph neural networks library learningdistributional program
search
1 Introduction
Most conventional modes of human communication naturally occur in a high-dimensional medium such as text, audio,
or images. When processing these media, slight errors can easily accrue across many dimensions of the input where
features are distributed. With adequate data, neural networks adapt effectively to these patterns by adjusting many
interdependent real-valued parameters. In their basic form, however, neural models are data inefï¬cient. In settings
where more data cannot be sourced, pretraining has arisen as the most general and data-driven answer to this challenge.
Pretraining allows practitioners to repurpose data that is not speciï¬cally suited to a task to enrich a representation or
initialize parameters of a neural model. While pretraining grants a model exposure to out-of-distribution data which
may be irrelevant or inappropriate to the task at hand, the beneï¬ts of this exposure can outweigh the costs.
In symbolic systems, modularity is often used to stimulate greater data efï¬ciency and generalization. By examining the
particular dimensions and values at which systems fail, developers can trace issues back to speciï¬c modules. When a
failure in one module is isolated and corrected, the system beneï¬ts from this across all combinations of values and
dimensions, witnessing potentially exponential growth in the number of inputs on which it succeeds. This approach
relies on the locality and discreteness of the representations associated with the task so that modular functionalities
can be developed and debugged. Unfortunately, it is difï¬cult to design a fundamental unit of a system that gains the
beneï¬ts of modularity and of neural networks, as it is difï¬cult to compose stable abstractions from components that
contain many adjustable parameters. Nonetheless, this is a more direct solution to the problem of data inefï¬ciency
and inadequate generalization in circumstances where high-dimensional data are known to exhibit both locality and
discreteness.arXiv:2303.03340v1  [cs.NE]  6 Mar 2023 Symbolic Synthesis of Neural Networks
In this work, I propose a technique for structuring modular neural networks that utilizes symbolic programs to
inform the networkâ€™s topology and to determine the values of some of its parameters. This allows the symbolic
programs themselves to be developed so as to exhibit increasing degrees of abstraction at a population level, while
allowing resulting individual networks to be trained and evaluated with standard techniques. I present Graph-based
Symbolically-Synthesized Neural Networks (G-SSNNs) and apply populations of G-SSNNs to a binary prediction task
over high-dimensional data containing many local and discrete features. I show that these populations exhibit reliable
patterns of improved generalization from small quantities of data compared to a population of baseline models which
are not structured according to the output of symbolic programs.
2 Related Work
2.1 Neural Architecture Search
Neural Architecture Search (NAS) is the process of using automated methods to explore the discrete space of neural
network topologies. Though varying in the design of their search space [Jin et al., 2022], search strategies [Real
et al., 2020], and model evaluation strategies [Abdelfattah et al., 2021], all approaches I reviewed assume that model
parameters learnable through gradient-based optimization will be learned in this fashion once search is complete. That
is, they serve to explore a (potentially hierarchical) space of hyperparameters in which topology often plays a central
role. This differs from G-SSNNs, in which symbolic programs play a role in determining both the topology and the
parameters of a model.
2.2 Embedding Spaces and Preprocessing
The act of adding ï¬xed transformations into a neural network that could otherwise be performed with the help of
learnable parameters seems more analogous to an act of preprocessing, as might be performed with word embeddings
[Mikolov et al., 2013] or positional encoding [Vaswani et al., 2017]. However, I found no works in which similar acts
of preprocessing were designed with the help of automated program synthesis.
2.3 Program Synthesis
The program synthesis apparatus used in this work is inspired by the DreamCoder system [Ellis et al., 2021] and uses
the same cycle of library learning and distributional program search between iterations of G-SSNN training, though I
utilize the more recent STITCH tool [Bowers et al., 2023] and heap search algorithm [Matricon et al., 2022] for these
respective functionalities. G-SSNNs have a deeper analogy with the DreamCoder system in that the process of training
a G-SSNN on a dataset generalizes the evaluation mechanisms for tasks and symbolic programs used in DreamCoderâ€™s
domains. The greater generality of G-SSNNs introduces concerns about performance on unseen data that are not
relevant when measuring the performance of purely symbolic programs, and must be addressed by separate mechanisms.
However, in principle, nothing prevents the multitask Bayesian program learning framework of DreamCoder from being
applied to the development of multiple, parallel populations of G-SSNNs.
In the broader neurosymbolic literature, I did not ï¬nd other examples of systems in which adjacent parametric and
nonparametric modules are separately optimized through gradient-based learning and the development of increasingly
hierarchical symbolic abstractions.
3 Methods
3.1 Evolutionary Framework
While the parameters of a G-SSNN may be optimized with ordinary training methods, we must utilize a separate
mechanism to optimize their symbolic structure. Since a G-SSNN is characterized by a single symbolic program, we
must retain a population of G-SSNNs in order to conduct program search. This search is guided in two respects: by the
structure of the DSL, and by the parameters of a distribution over programs. The structure of the DSL is determined by structure of the DSL, and by the parameters of a distribution over programs. The structure of the DSL is determined by
the results of library learning performed with STITCH [Bowers et al., 2023]. STITCHâ€™s library learning functionality
operates by extracting novel primitives from a corpus according to which provides the greatest degree of compression
(i.e. reduction in aggregate program size). A distribution over programs may also be inferred from such a corpus by
counting how many times n-grams of primitives from the DSL are used.1Thus, if we are able to select an approximately
optimal corpus of symbolic programs based on the training performance of a population of G-SSNNs, we may both
1In experiments, I utilize a unigram distribution.
2 Symbolic Synthesis of Neural Networks
bias compression towards the discovery of modules common to successful programs and bias program search towards
the discovery of increasingly complex programs which utilize those modules.
Because there is always the possibility that a G-SSNN performs differently on unseen data, there is no heuristic that is
unquestionably best for encouraging the greatest generalization. Perhaps the simplest and most generally agreeable,
however, are those based on discarding G-SSNNs with the Lowest Training Performance (LTP). I refer to the heuristic I
use in the experiments presented here as rank-LTP-50, which involves discarding the bottom half of G-SSNNs in terms
of the rank of their training performance among the population.
3.2 G-SSNNs
There are many ways that the output of a symbolic program could be incorporated into the topology and parameter
values of a neural network. However, the use of learned abstractions forces a consideration: how do we make symbolic
programs increasingly sophisticated without simply making their corresponding neural networks larger? In order that
our models donâ€™t become increasingly costly to train as the symbolic programs that structure them utilize increasingly
complex modules, the number of parameters optimized with gradient-based learning should remain ï¬xed regardless of
how the symbolic program ï¬xes their topology or values. This can be achieved by repurposing generic graph neural
networks (GNNs).
Lets2Skbe relational structures whose elements are accompanied by symbolic feature vectors v2Nk. let
e:NkRm!Rnbe an embedding function that maps each symbolic feature vector vand a vector x2Rmto
another real-valued feature vector. Lastly, let graph_map :SkRm!Gnbe the function that maps from relational
structures and input vectors to graphs with the corresponding real-valued features given by e(v; x)for each v2s. We
may then deï¬ne a G-SSNN as a model m:Rm!Rqconsisting of a GNN mg:Gn!Rq, a relational structure s,
and an embedding function e, for which
m(x) =mg(graph_map (e; x; s )):
Provided that eis differentiable with respect to x, a G-SSNN may function as a generic neural module.
There are many ways one could design the class of relational structures Skand the embedding function edepending on
the degree and forms of control we want to grant symbolic programs over the parameter space and topology of the
network. For the experiments conducted in this paper, I adopt a simple design: I utilize a subset of the class S2of
single-component undirected graphs with node and edge features. The natural numbers associated with each graph
element correspond to a unique ID and a neighborhood rank. IDs are 0-indexed and reï¬‚ect the order in which the
elements were created. I denote the number of unique IDs in a graph with d= 1+max v2sv2. The neighborhood ranks
are natural numbers in a limited range which distinguish the edges of a particular neighborhood. The neighborhood rank
of a node is 0, while the neighborhood rank of an edge ranges from 1 to a ï¬xed maximum degree. Since neighborhood
ranks function to distinguish edges, even if their endpoints are the same, this class of relational structures could be
understood as permitting multiple edges. I denote the number of distinct neighborhood ranks with r= 1 + max v2sv2.
To process these symbolic features, I utilize the embedding function
e(v; x) =tile_expand (xidx(v1):idx(v1+1)) +2d_pos (v1; v2)
where idx(w) = ( mmodl) +wlforl=bm=dc. The function tile_expand :Rt!Rnimplements the
differentiable operation of concatenating dn=tecopies of its input and truncating the result to a dimensionality of n,
and the function 2d_pos :N2!Rnproduces computes a vector b=2d_pos (d; r)such that2
bi=8
>><
>>:sin(reorder_1 (d; r)=10000imod ( n=4)) 1 < in=4
cos(reorder_1 (d; r)=10000imod ( n=4))n=4< i2n=4
sin(reorder_2 (d; r)=10000imod ( n=4)) 2n=4< i3n=4
cos(reorder_2 (d; r)=10000imod ( n=4)) 3n=4< in: cos(reorder_1 (d; r)=10000imod ( n=4))n=4< i2n=4
sin(reorder_2 (d; r)=10000imod ( n=4)) 2n=4< i3n=4
cos(reorder_2 (d; r)=10000imod ( n=4)) 3n=4< in:
This embedding function constructs node and edge features by selecting values from a subset of the dimensions of x
and adding them to a bias vector, where both the subset of dimensions and the value of the vector are chosen based
on the unique values of each graph elementâ€™s symbolic feature vector. This incentivizes greater modularity in mby
ensuring that the parameters of mgfunction differently when applied to the same values depending on the dimensions
2The functions reorder_1 andreorder_2 are an implementation detail due to mistaken indexing which did not affect the validity
of the experiment. These functions are deï¬ned as reorder_1 (d; r) = (dr+r) mod dandreorder_2 (d; r) =b(dr+r)=dc
where dandrare the maximal values of dandr. These functions may be replaced by f1(d; r) =dandf2(d; r) =rrespectively
to simplify the computation of 2d_pos .
3 Symbolic Synthesis of Neural Networks
ofxin which they appear. Similarly, this behavior incentivizes antecedent neural modules to exhibit greater modularity
by ensuring that their parameters function differently based on the dimensions of xthat they inï¬‚uence. These incentives
rely crucially on the bias term of e, which allows the symbolic program generating the relational structure sto inï¬‚uence
the parameter space of m. Without this term, the symbolic program would still inï¬‚uence the topology of mthrough the
structure of the graph convolutions applied by mgand the distribution of values from speciï¬c dimensions of xinto
speciï¬c node and edge features under e.3However, this alone would create no obligation for different parameters of
mgor antecedent neural modules to behave differently with regard to the various dimensions of x. In general, while
topology may allow or disallow particular parameters from inï¬‚uencing each other, it cannot guarantee that they behave
differently with respect to the output for the same input. This can only be achieved by systematically varying the values
different parameters may take.
3.3 Symbolic Programs
The symbolic programs used to generate the relational structures described above are of type S2!S2and are all
evaluated by application to the same initial relational structure. The primitive operations of the initial DSL are such that
symbolic programs may only make decisions based on the information contained in the relational structure. Since the
initial relational structure is uninformative, symbolic programs therefore only have access to information about their
own semantics as it manifests in the relational structure they construct. More detailed information on the operations of
the initial DSL is available in the documentation of the antireduce-graphs library.
During program search, symbolic programs are considered novel if they generate a relational structure that is unique
under isomorphism when symbolic features are not considered. Isomorphism testing is performed with the VF2++
algorithm [JÃ¼ttner and Madarasi, 2018].
4 Experiments
4.1 Setup & Hyperparameters
To facilitate comparison, I utilize a base model architecture consisting of a transformer with a convolutional stem [Xiao
et al., 2021]. I use subpixel convolution to perform downsampling from 128128to88[Shi et al., 2016], followed
by a pointwise convolution and three residual convolutional units. The patches are then ï¬‚attened and fed to a simpliï¬ed
Vision Transformer (ViT) [Beyer et al., 2022] with 2 transformer blocks. Each block has an MLP dimension of 512 and
4 128-dimensional attention heads. Global average pooling is then applied to produce an output of the target dimension
for baseline models, or with the dimensionality of a graph element for experimental models in which the output is fed
to a G-SSNN unit.
To construct G-SSNNs, I use the Graph Isomorphism Network with Edge features (GINE) of Hu et al. [2020] as
implemented in the DGL library [Wang et al., 2019]. I use 512-dimensional node and edge representations, which
are passed through three GINE units parametrized by an MLP layer with identical input and output dimensionalities.
Between GINE units, I apply 30% droput [Srivastava et al., 2014]. To produce the ï¬nal output, I apply average pooling
followed by another MLP layer which projects its input to the target output.
For both baseline and experimental models I use a batch size of 8, train each model for 16 epochs with the Adam
optimizer [Kingma and Ba, 2015], and reduce the learning rate by a factor of 1/2 when a new low in the loss has not
been experienced in the ï¬rst 50 batches, or in the most recent 65 batches since the learning rate was last reduced.
Across iterations of evolutionary selection, I retain a population of at most 50 and apply the rank-LTP-50 heuristic if
the size of the population is greater than or equal to 25. I run distributional program search for a 15 second period. In the size of the population is greater than or equal to 25. I run distributional program search for a 15 second period. In
the course of this run, I retain only the most likely 50"," This paper presents Graph-based Symbolically Synthesized Neural Networks (G-SSNNs), a new approach to neural networks that combines the advantages of neural networks and symbolic systems to improve data efficiency and generalization. G-SSNNs use symbolic programs to inform the topology and parameters of the neural network, allowing for the development of compact and composable abstractions that can be repurposed for a variety of tasks. Experiments are conducted on the Prediction of Constant Color Pattern (PCCP) task and image and video super-resolution using efficient sub-pixel convolutional neural networks and plain VIT baselines for ImageNet-1K. Results demonstrate that G-SSNNs produce reliable patterns of improved generalization on tasks involving local and discrete features across high-dimensional media."
14," Noname manuscript No.
(will be inserted by the editor)
Optimizing L1 Cache for Embedded Systems through
Grammatical Evolution
Josefa D az Alvarez J. Manuel Colmenar Jos e L. Risco-Mart n Juan
Lanchares Oscar Garnica
Received: date / Accepted: date
Abstract Nowadays, embedded systems are provided
with cache memories that are large enough to inuence
in both performance and energy consumption as never
occurred before in this kind of systems. In addition, the
cache memory system has been identied as a compo-
nent that improves those metrics by adapting its con-
guration according to the memory access patterns of
the applications being run. However, given that cache
memories have many parameters which may be set to
a high number of dierent values, designers face to a
wide and time-consuming exploration space.
In this paper we propose an optimization framework
based on Grammatical Evolution (GE) which is able
to eciently nd the best cache congurations for a
given set of benchmark applications. This metaheuris-
tic allows an important reduction of the optimization
runtime obtaining good results in a low number of gen-
erations. Besides, this reduction is also increased due
to the ecient storage of evaluated caches. Moreover,
we selected GE because the plasticity of the grammar
eases the creation of phenotypes that form the call to
Josefa D az Alvarez
Centro Universitario de M erida, Universidad de Ex-
tremadura, 06800 M erida, Spain
Tel.: +34-924-387268
E-mail: mjdiaz@unex.es
J. Manuel Colmenar
Dept. of Computer Science and Statistics, Universidad Rey
Juan Carlos, 28933 M ostoles, Spain
E-mail: josemanuel.colmenar@urjc.es
Jos e L. Risco-Mart n Juan LancharesOscar Garnica
Dept. of Computer Architecture and Automation, Universi-
dad Complutense de Madrid, 28040 Madrid, Spain
E-mail:fjlrisco,julandan,ogarnica g@dacya.ucm.esthe cache simulator required for the evaluation of the
dierent congurations.
Experimental results for the Mediabench suite show
that our proposal is able to nd cache congurations
that obtain an average improvement of 62% versus a
real world baseline conguration.
1 Introduction
Embedded computing systems have experienced a great
development in last decades, becoming one of the cru-
cial driving forces in technology. Portable devices such
as smartphones, digital cameras, GPS, etc. are con-
stantly incorporating new functionalities. Most of these
new features are devoted to support new services and
multimedia applications, despite that embedded sys-
tems have limited resources. Portable systems, for in-
stance, run on batteries, which are limited in capacity
and size, because of design constraints. Moreover, they
have a limited cooling ability and, hence, a low energy
consumption is a main requirement. Besides, portable
systems usually execute multimedia applications, which
require high performance and, therefore, are energy in-
tensive tasks. As a consequence, one of the main work-
forces of embedded systems designers is the search for
the right balance between increasing performance and
reducing energy consumption at a low cost.
Previous studies have identied on-chip cache mem-
ory as one of the most energy consuming components,
ranging between 20% and 30% of the total power of the
chip in embedded processors [31]. In addition, the de-
sign of the cache memory has a high inuence on energy
consumption and performance, because of the dierent
hardware complexity that it implies. For instance, a di-
rect mapped cache design presents the fastest hit times,arXiv:2303.03338v1  [cs.NE]  6 Mar 2023 2 Josefa D az Alvarez et al.
but requires higher cache size to obtain comparable per-
formance than an N-way set associative cache. On the
other hand, set associative caches present higher energy
consumption given that they access to a set of Ntags
on each operation [15].
The cache memory behavior is not only conditioned
by structural parameters (capacity, block size, associa-
tivity, etc.), but also by parameters such as algorithms
for search, prefetch and replacement, write policies, etc.
All these features form the so-called cache congura-
tion. Finding optimal values for these parameters will
bring us the best performance and energy consumption
and consequently, the best cache conguration.
Besides, applications have dierent behavior and hence
have distinct cache requirements to meet the specic
objectives of energy consumption and performance. Thus,
we need to take into account the behavior of the target
application in order to nd the best cache conguration
that improves performance or energy consumption.
In summary, an optimization scheme to determine
the best cache conguration should: (1) travel along the
design space of cache congurations, which is dened as
the set of all combinations of values for all cache param-
eters; (2) take into account the energy and performance
of target applications for each candidate cache congu-
ration, because of dierent memory access patterns.
The evaluation of a cache conguration requires a
cache simulator to process a trace of the cache accesses
from a previous execution of the target program. This
process will allow to calculate the execution time and
energy consumption for the application under study.
This is a slow process because program traces usually
record billions of memory operations, which spends tens
of seconds of simulator runtime. Hence an exhaustive
search on this design space will take an unaordable
amount of time given the high number of cache cong-
urations that can be dened.
On the other hand, heuristic techniques reduce the
number of evaluations while performing the search to-
wards the optimal and, therefore, t well in this kind
of problems. Therefore, we present in this paper an
optimization scheme based on Grammatical Evolution
(GE) [11] that obtains, using program traces, the op-
timized cache conguration in terms of execution time
and energy consumption for a given target application.
Compared with the exhaustive approach, the execution
time is highly reduced due to two reasons: (1) the meta-
heuristic algorithm converges even with a short number
of generations and population size; (2) we have added
a hashed map to store the objective values of each eval-
uated cache. In addition, the plasticity of the gram-
mar in GE help us to generate the parameters that the
cache simulator call requires for each evaluation, mak-ing more easy to communicate it with the optimization
algorithm.
In order to test our proposal, we have run experi-
ments that nd the best cache conguration for a set
of multimedia applications taken from the Mediabench
benchmarks [18], since they are representative for im-
age, audio and video processing, which are typical ap-
plications of embedded systems. We have assumed in
these experiments a hardware architecture based on the
ARM9 processors family [2], broadly used in multime-
dia embedded devices. As will be shown later, the av-
erage reduction of execution time and energy consump-
tion of the optimized cache congurations is 75% and
96% respectively in relation to a baseline cache. In ad-
dition, the optimization runtime is aordable and we
have estimated an average reduction of 94% in relation
to a GE implementation with no storage of evaluations.
The rest of the paper is organized as follows. Section
2 describes the main issues about cache design and de-
nes the search space of the problem. Section 3 reviews
the related work on the cache optimization techniques.
Section 4 describe both performance and energy models nes the search space of the problem. Section 3 reviews
the related work on the cache optimization techniques.
Section 4 describe both performance and energy models
adopted in this work to compute the goodness of the
candidate solutions. Section 5 describes the whole op-
timization framework, detailing the o-line processes as
well as the Grammatical Evolution we manage. Then,
Section 6 analyzes our experimental results. Finally,
Section 7 draws conclusions and future work.
2 Cache design and search space
In order to clarify the scope of the problem under study,
we devote this section to introduce some cache design
concepts and related issues to be addressed. These con-
cepts will also help us determine the size of the search
space.
Firstly, it must be noticed that there exist difer-
ent design features, also named design parameters, that
need to be tuned in order to decide a cache congura-
tion. The values given to those parameters inuence on
the cache behavior in both execution time and energy
consumption. However, those parameters may be dif-
ferent depending on the processor where the cache will
be included.
In this regard, we rst have to decide which type of
cache to select for this work. Taking into account that
we focus our approach on embedded systems, we have
selected the cache of the ARM9 processors family [2].
ARM processors, because of their low power con-
sumption and cost, have a prevalent position in the
market of portable devices and they are widespread on
multimedia embedded devices. In fact, the Apple A7, Optimizing L1 Cache for Embedded Systems through Grammatical Evolution 3
A8 and A8X processors included in the popular iPhone
5S, iPhone 6 and iPad Air 2 do implement the ARMv8-
A instruction set.
In addition, the ARM9 processors family is present
in devices such as game consoles (GP32, Nintendo DS),
calculators (HP 49/50), mobile phones (HTC TyTN, K
and W series of Sony Ericsson) and car GPS (Samsung
S3C2410), for example.
Processors belonging to this family allow the instal-
lation of a cache memory with sizes between 4 KB and
128 KB. For instance, the ARM920T, ARM922T and
ARM940T processors (ARM9TDMI family) implement
a separated 16KB, 8KB and 4KB instruction and data
cache, respectively. Although revisions on ARM9E fam-
ily allow sizes up to 1MB, such as the ARM946E-S pro-
cessor.
Given that the separation into data and instruction
caches is common in the more recent ARM9 processors,
we do consider this two-caches approach in our work.
Hence, the cache parameters that can be tuned in
the instruction and data caches of this processor are
the following: cache size, line size, replacement algo-
rithm, associativity and prefetch algorithm for both the
instruction and data caches, and also write policy for
data cache. Here, cache size is the memory cache capac-
ity in bytes, block size represents the amount of data
read or written in each cache access, replacement al-
gorithm is in charge of taking the decision to evict a
block from cache memory, and prefetch algorithm de-
cides how blocks are carried to the cache memory. Fi-
nally, the write policy decides when data stored in the
cache shall be written to main memory, and it only af-
fects the data cache.
In brief, the problem we address consists on select-
ing the values for the cache parameters that optimize
the execution time and energy consumption of a given
application. Therefore, the search space is formed by all
the combinations of dierent values for each one of the
cache parameters. Thus, in our target system, a cache
conguration is formed by 11 parameters: 5 for the in-
structions cache and 6 for the data cache. According to
the typical cache congurations of embedded systems,
we selected a range of permitted values for each param-
eter, which are shown in Fig. 1.
For instructions cache (I-Cache), memory size may
take 8 dierent values ranging between 512 bytes and 64
KB, block size can take 4 dierent values, 3 replacement
algorithms and 3 prefetch algorithms may be selected,
and 8 associativities are available. This results in 2304
possible congurations for instructions cache.
Data cache (D-Cache) have the same parameters
as instructions cache, but adding the 2 possible writepolicies. Hence, 4608 possible data cache congurations
can be selected.
I-Cache D-Cache 
Block Size
8   16   32   64
Prefetch
Algorithm
MISS  ON-DEMAND  ALWAYSAssociativity
  1   2   4  8  16 32  64 128
Replacement
Algorithm
  LRU  FIFO RANDOMSize
512 1K 2K 4K 8K 16K 32K 64KCache Memory
COPY-BACK   WRITE-TRGH.Write Policy
Fig. 1 Cache conguration parameters. Both instruction and
data caches must be customized with available values.
Thus, considering all the possible combinations of
both caches, the size of the search space is 2304 
4608 = 10616832 congurations. However, some of the
constraints are related to infeasible parameters combi-
nations. For example, a cache conguration of 512B,
64-ways set associative with 32 bytes block size is not
feasible. Then, if this combination is selected for in-
struction or data caches, it shall be invalidated by any
optimization algorithm.
3 Related work
It is well proven that the cache memory is a component
that plays a crucial role to improve performance and en-
ergy consumption. In recent decades, many researchers
have focused their work on improving dierent charac-
teristics of the cache memory. Several optimization ap-
proaches have been addressed to increase performance
and/or reduce energy consumption, develop simulation teristics of the cache memory. Several optimization ap-
proaches have been addressed to increase performance
and/or reduce energy consumption, develop simulation
and evaluation tools, etc. Next, we analyze some of the
works related to our proposal that we have separted
into two dierent cathegories: (1) works that deal with
cache reconguration, and (2) works based on evolu-
tionary techniques.
3.1 Cache reconguration
One of the main goals for years has been to cong-
ure the cache memory according to the running work- 4 Josefa D az Alvarez et al.
load, in order to mainly improve performance and/or
energy consumption. This requires both hardware sup-
port for cache reconguration, and algorithms to decide
the proper values of the parameters that obtain the best
performance taking into account the running applica-
tion. In this way, many research works have analyzed
cache memory parameters and proposed new recong-
uration techniques from dierent points of view.
Naz et al. [20] proposed a design with split data
caches for embedded systems. The data cache was split
in scalar and array caches aiming to take advantage of
temporal and spatial localities respectively. Their op-
timization was based on dealing with predened cache
congurations, where the values of the parameters were
xed before the optimization. Hence, the search space
in this case is small compared with a space where all
the parameter values are taken into account.
Chen and Zou [8] presented an ecient recongura-
tion management algorithm for embedded systems. The
cache conguration automatically changed after identi-
fying a phase change. The search space was composed
by these parameters: cache size, block size and associa-
tivity. From our point of view, this work do not consider
enough number of cache parameters.
Gordon-Ross et al. [14] applied a method with an
o-line phase classication and an on-line predictor phase.
Phase classication breaks applications execution into
xed size intervals grouped according to its similar be-
havior pattern. The phase predictor decides the cache
conguration for the next interval. Exploration space
was dened by cache size, block size and associativity,
which means that only three parameters were consid-
ered to dene the search space. In this case, given the
on-line prediction phase, a low number of parameters
was required.
Wang et al. [33] proposed dynamic cache recongu-
ration for real time embedded systems. They minimize
energy consumption performing a static analysis at run-
time. This proposal is based in previous works [32,34]
where they addressed an unied two-level cache hierar-
chy and multi-level cache hierarchy respectively. A com-
bination of static analysis and dynamic tuning of cache
parameters, without time overhead were performed in
both cases. However, a few number of parameters were
optimized: cache size (1, 2 or 4KB), line-size (16, 32 or
64 bytes) and associativity (1-way, 2-way or 4-way).
New hardware technologies and core-based proces-
sor technologies, such as those proposed, for example,
by ARM [3], allow changing the cache conguration for
each application. Changes aect the main parameters:
capacity, block size and associativity. However, an e-
cient algorithm is needed to determine optimal values
for each application.3.2 Evolutionary Techniques
Evolutionary techniques have been widely applied in
design optimization, both for hardware and software
optimization with dierent objectives.
The creators of the Grammatical Evolution tech-
nique published a work where a caching algorithm was
automatically generated [22]. However, they only con-
sidered the generation of the caching algorithm and
kept xed some other parameters like cache size, for
instance. Again, many parameters were missed.
Palesi and Givargis [25] presented a multi-objective
optimization approach to explore the design space of a
system-on-a-chip (SoC) architecture to nd the pareto
optimal congurations of the system. They performed
the optimization through a genetic algorithm where the
evaluation is done directly in the SoC. However, the
number of parameters they study is lower than ours,
and their approach is not escalable to current multime-
dia applications given the low performance of the SoC.
Filho et al. [30] presented an approach based on the
NSGA-II algorithm to evaluate cache congurations on
a second level cache in order to improve energy con-
sumption and performance, optimizing cache size, line NSGA-II algorithm to evaluate cache congurations on
a second level cache in order to improve energy con-
sumption and performance, optimizing cache size, line
size and associativity. However, again, the number of
parameters is lower than in our proposal and, there-
fore, the search space is smaller.
Dani et al. [9] applied a genetic algorithm to nd an
optimal cache conguration for a chip multiprocessor
(CMP) system. They deal with a complex system like
a CMP. However, they do not manage a higher num-
ber of cache parameters and, given that they encode
the conguration of both the chip and the cache into
a chromosome, the decodication process is complex.
This issue makes dicult the application of the same
method to a dierent microarchitecture.
Risco et al. [28] presented a framework based on
Grammatical Evolution to design custom dynamic mem-
ory managers for multimedia applications in embedded
systems. They optimized memory accesses, memory us-
age and energy consumption. However, they do not deal
with cache parameters but optimizing the operating
system memory manager instead of dealing with cache
design parameters.
Finally, performing a deep search in the literature,
and specially in one of the main hubs of Grammatical
Evolution publications [1], we have not found any recent
work which applied this technique to optimize the cache
design of a microarchitecture. Optimizing L1 Cache for Embedded Systems through Grammatical Evolution 5
3.3 Summary
As seen, the approaches that make use of recongura-
tion require extra hardware complexity in the design
of the memory subsystem. Also, in the majority of the
cases, this complexity adds an overhead in execution
time. In our work we propose a dierent approach fo-
cused on nding the best cache conguration after ex-
ploring the search space of cache designs. This strategy
avoids the cache reconguration which does not add
hardware complexity to the cache memory design.
In addition, previous works dene their design space
by cache size, block size and associativity of either in-
struction cache or data cache, but we have not found
any proposal that considers both caches at the same
time on embedded systems. Our motivation is dierent
since we consider the optimization of instruction and
data caches together, and we selected all the parameters
that can be tunned: cache size, block size, associativity,
replacement algorithm and prefetch algorithm for both
caches; and write policy for data cache. Therefore, we
explore a wider search space.
Moreover, to the best of our knowledge, none of the
previous works considers the optimization of as many
parameters as we tackle in our proposal. Regarding the
works using evolutionary techniques, most of the cited
papers have focused their space exploration on typi-
cal structural cache parameters such as cache size, line
size and associativity and, in addition, they usually deal
with short ranges for parameter values. One of the most
used technique in this kind of works, the genetic algo-
rithm, presents the drawback of the codication process
which has to be customized for every dierent cache
paradigm and simulator software.
On the other hand, the methodology we propose
can be applied to any kind of cache and processor ar-
chitectures. To this aim, the main and unique change
in our framework will be the cache simulator and the
grammar, as it will be shown later.
4 Performance and energy models
In this research work we consider the execution time
and energy consumption of a given cache conguration
when running a benchmark application. As explained
before, we deal with program traces that are processed
by a cache simulator that accounts for the number of
hits and misses of each execution, which represent the
cache behavior.
As stated before, we selected the ARM9 processors
family [2] as our target embedded system where cache
conguration will be optimized. Here, the L1 cache isTable 1 Main memory (DRAM) features.
Size 64 Mb
Access time 3:988910"," This paper presents an optimization framework based on Grammatical Evolution (GE) to efficiently find the best cache configurations for a given set of benchmark applications. Experiments on the Mediabench suite show that the proposed framework is able to improve performance by an average of 62% compared to a real-world baseline configuration, while reducing optimization runtime and efficiently storing evaluated caches. The framework is designed to optimize the cache memory of multimedia applications on the ARM9 processor family, and uses a performance and energy model to translate the number of hits and misses of benchmarks into execution times and energy consumption. The optimization process is based on a grammar to map a genotype to a cache configuration, and a fitness function to measure the performance and energy consumption of each individual configuration."
15," Using a Variational Autoencoder  to Learn Valid Search Spaces of 
Safely Monitored Autonomous Robots for Last-M ile Delivery 
Peter J. Bentley 
Department of Computer 
Science, UCL, Autodesk 
Research 
London, United Kingdom  
 p.bentley@cs.ucl.ac.u k Soo Ling Lim 
 Department of Computer 
Science, UCL  
 London, United 
Kingdom  
 s.lim@cs.ucl.ac.uk  Paolo Arcaini 
 National Institute of 
Informatics  
 Tokyo, Japan  
 arcaini@nii.ac.jp  Fuyuki Ishikawa 
National Institute of 
Informatics  
 Tokyo, Japan  
 f-ishikawa@nii.ac.jp  
ABSTRACT  
The use of autonomous robots for delivery of goods to customers 
is an exciting new way to provide a reliable and sustainable 
service. However, in the real world, autonomous robots still require human supervision for safety reasons. We tackle the real -
world problem of optimizing autonomous robot timings to maximize deliveries, while ensuring that there are never too m any 
robots running simultaneously  so that they can be monitored 
safely . We assess the use of a recent  hybrid machine- learning -
optimization approach COIL (constrained optimization in learned 
latent space) and compare it with a baseline  genetic algorithm for 
the purposes of exploring variations of this problem. We also investigate new methods for improving the speed and efficiency 
of COIL . We show that only COIL can find valid solutions where 
appropriate  numbers of robots run simultaneou sly for all problem 
variations tested. We also show that when COIL has learned its latent representation, it can optimize 10% faster than the GA, 
making it a good choice for daily re -optimization of robots where 
delivery requests for each day are allocated to robots while 
maintaining safe numbers of robots running at once.  
CCS CONCEPTS 
â€¢ Computing methodologies~Search methodologies  â€¢ Computing 
methodologies~Learning latent representations  â€¢ C omputing 
methodologies~Robotic planning  
KEYWORDS 
Variational autoencoder , autonomous robots, scheduling, learning 
latent representations , genetic algorithm  
 
  
 1 INTRODUCTION  
Home delivery of groceries and other goods is rapidly becoming a 
major new industry worldwide, accelerated by the COVID 
pandemic. The use of automobiles for last -mile delivery (from 
store to customer) caus es environmental concerns [1] and in 
countries such as Japan  where our problem originates, there may 
be a lack of labor. O ur industry partner , a major electronics 
corporation, is currently trialing their solution: an automatic 
delivery service performed by autonomous robots. Customers 
order goods which are then collected from a supermarket or drug 
store by a robot and delivered to the customer. The robots are 
autonomous but have human monitors that intervene should a 
problem occur, such as a potential collision with a pedestrian , 
Figure 1. The use of robots for this purpose is in the 
experimentation phase, with details such as number of robots and human monitors  still under consideration.  
 
  
Figure 1: Home delivery service using low speed robots with 
human operators performing safety monitoring.  Map shows 
section  of actual location. P. Bentley  et al.  
 
 
 In this real -world problem there is a clear conflict between 
fulfilling orders and maintaining  safety. More robots operating 
simultaneously will mean more orders could be fulfilled, yet too 
many robots operating at once would be dangerous as the human 
operators can only monitor a limited number of robots. The 
problem of how best to schedule  different numbers of robots such 
that maximum orders are delivered safely is therefore difficult.  It 
is also a problem that must be solved repeatedly for every new set of customer orders.  This problem is likely to become increasingly 
relevant as autonomous robot deliveries become more prevalent, 
yet safety is rarely considered in the literature.  
We address this problem by using a hybrid machine learning  
and evolutionary computation approach  [2, 3]. This method  uses a 
variational autoencoder to learn the valid  regions of the search 
space, i.e., the areas of the search space where safe numbers of robots are scheduled to work simultaneously. A genetic algorithm 
(GA) is then used to search in this learned latent space to find 
optimal timings for robots suc h that the maximum number of 
orders can be delivered safely. We compare this approach with a 
baseline  genetic algorithm optimizing robot timings  while solving 
the constraint, without the use of machine learning. We investigate how well both approaches  enable us to examine 
different design variations and we assess suitability for long term 
use once the design variables are determined . 
The contributions of this work can be summarized as follows:  
â€¢ The first study to explore real-world autonomous robot 
routing  while satisfying a safety monitoring requirement. 
â€¢ Adapting the hybrid ML -EA approach (COIL)  [2, 3] to a 
real-world problem for the first time.  
â€¢ Evaluation of COIL by comparing to  a baseline GA to 
explore problem variations,  showing better  solution 
quality and optimization speed for daily robot scheduling.  
â€¢ COIL performance is enhanced on th e problem through  
reduction of the training set and number of latent 
variables.  
The rest of the paper is organized  as follows: Section 2 
provides a literature review of relevant research, Section 3 describes the method, Section  4 describes the experiments , results  
and discusses findings for the problem . We conclude in Section 5. 
2 BACKGROUND  
2.1 Autonomous Robots for Home Delivery 
Autonomous delivery robots have the potential to significantly reduce energy consumption and CO
2 emissions in urban areas  [1]. 
There are several examples of solutions. Mercedes -Benz Vans 
partnered with Starship Technologies to propose the concept of 
autonomous del ivery robots launched from trucks [4]. The truck 
can replenish robots at decentralized depots to launch more  until 
all its customers are supplied. Boysen et al. [4] developed  
scheduling procedures which determine the truck route, such that 
the weighted number of late custom er deliveries is minimized.  
Yu et al. [5] considered a variant of this problem and  proposed 
an LV -SAV (large vehicle - small full y automated ground vehicles) model where multiple LVs cooperate with their 
associated SAVs. Safety was one of their concerns, and having 
slow moving SAVs is safer in urban delivery, and was considered 
to be safer than using drones in the HVDRP (hybrid vehi cle-drone 
routing problem) proposed by Karak and Abdelghany [6]. 
Chen et al. [7] introduced another variant called  a new vehicle 
routing problem with time windows and delivery robots (VRPTWDR). They showed that c onsiderable operational time 
savings can be achieved by dispatching delivery robots to serve 
nearby customers while a driver is also serving a customer . 
Since delivery robots share sidewalks with pedestrians, Bakach 
et al. investigated the option to ch oose paths for them that avoid 
zones with high pedestrian  density  [8]. They  considered  path Since delivery robots share sidewalks with pedestrians, Bakach 
et al. investigated the option to ch oose paths for them that avoid 
zones with high pedestrian  density  [8]. They  considered  path 
flexibility given the presence of zones with varying pedestrian 
level of service .  
The study of vehicle routing problems (VRP) continues to 
develop, with  many  variants includ ing real-life constraints and 
assumptions, which makes the models more realistic and the 
approaches more applicable in practice [9]. Autonomous delivery 
vehicles introduce  safety concerns  whilst driving autonomously 
on the public road networks and performance risk s while 
delivering  parcels (e.g., risk of malfunctioning of the technology) 
[10]. A study of  public perceptions and acceptance of autonomous 
vehicles found that people expressed high concerns around safety, 
cyber -security, legal liability, and regulat ion issues  [11]. 
In this work we focus on safety  and a key component of the 
solution created by our i ndustry collaborator. New to this field, f or 
our problem, human operators monitor the robots so that they can 
manually operate the m when unexpected obstacles are detected , 
or they can talk with the users.  Similar monitoring will be 
required for many other real -world examples, so methods to solve 
this problem are likely to be widely useful. 
2.2 Evolving Latent Variables  
Autoencoder s [12] are neural network s first used for 
dimensionality reduction . Since their inception they have become 
popular for  learning generative models of the data. An 
autoencoder co mprises  two parts - an encoder ğ‘, which maps the 
observations ğ‘¥ to a (lower dimensional) embedding space ğ‘§ and a 
decoder ğ‘, which  maps the embeddings back to the original 
observation space.  When trained, the autoencoder minimizes the 
error in reconstruction of output compared to input.  The 
variational autoencoder (VAE) is a probabilistic autoencoder [13, 
14]. Instead of encoding an observation as a single point, VAEs 
encode it as a distribution over the latent space.  
Recent work in the field of evolutionary computation makes 
use of VAE s to learn representations and then evolve using those 
representations, searching in the latent space  (LVE â€“ latent 
variable evolution). Game levels  [15], fingerprints to foil security 
systems [16], and program synthesis  [17] include some of the 
applications. Researchers also make use of quality -diversity 
approaches  [18] with LVE  to improve optimi zation in high 
dimensional problems, for example DDE -Elites  [19] which uses a 
combination of the direct encoding with a learned latent encoding to accelerate search. Learn ing Valid Search Spaces of Autonomous Robots   
 
 Most recently, COIL (constrained optimization in learned 
latent space) [2] and SOLVE (search space optimization with 
latent variable evolution) [3] present an LVE approach to learn a 
latent rep resentation that is biased towards solutions that satisfy a 
constraint or additional objective. This is very relevant to the real -
world problem we investigate in our work. However, while COIL  
[2] and SOLVE  [3] have been demonstrated on simple constraints 
and benchmark functions, the technique has not been tested on a 
real-world problem. In this work we app ly the concepts in COIL 
for the first time to the problem of scheduling a safe number of 
autonomous robots for home delivery of a maximum number of 
orders by customers .  
3 METHOD  
We base our approach on the system under development  by our 
industry partner. Their automated delivery service will enable 
customers to order goods from a local store which are delivered 
by autonomous robots. Customers submit requests through  an app. 
Each request is scheduled centrally with a robot allocate d to serve 
it. Robots are monitored by human operator s who can intervene if 
the robot encounters problems, helping to initiate the appropriate response in the robot or talk to users , Figure 1. 
We focus on  two stages to this problem: 
1. Investigate possible design variations, with different numbers of robots, human operators, request durations . 
2. On completion of the first stage, provide an efficient method for daily optimizatio n of robot timings.  
For the first stage,  we investigate optimization methods 
capable of exploring design variations . The algorithms must 
successfully  schedul e the robots to maximize delivery of requests 
while ensuring there are never too many robots run ning 
simultaneously, such that the human operators can safely monitor 
them. For the second stage , with the design variables now 
determined,  we investigate the fastest method of scheduling 
robots to meet the human operator constraint, daily , because  this 
decision- making process reoccurs every day with new customer 
requests.  
We formulate the problem as a constrained optimization 
problem.  Given a randomly generated set Reqs  comprising Rq 
customer requests, each with duration Rqdur: 
 Reqs  = {Rqdur
1, .., Rqdur Rq} 
 
where Rqdur j = random[ 60..dr] and given a set of robots Rbts 
comprising Rb pairs of robot starting time Rst and running time  
Rrt: 
 
Rbts = {Rst1, Rrt1, .., R stRb, RrtRb} 
 
allocate each request  Rqdur j in order from j = 1 to Rq (i.e., on a 
first-come, first -served basis) to the most appropriate robot using 
a simple scheduler created for this work , Algorithm 1. (Should 
this solution be commissioned for use on the real robots, this 
algorithm will be replaced with the industrial partnerâ€™s internal 
scheduler.)  Algorithm 1: First -come first -served scheduler used to 
allocate customer requests to robots. totalRm  count s the total 
number of requests met out of a maximum of Rq. 
totalRm  = 0 
for i = 1 to Rb 
    remaining_dur i = RrtiÃ—10 
endfor  
for j = 1 to Rq 
    if there exists a remaining_dur k such that  
        0 <= ( remaining_dur k  - Rqdur j ) < 10 and 
        there are no other  closer matches then 
            remaining_dur k  âˆ’= Rqdur j 
            totalRm  ++ 
            break 
    else find largest remaining_dur k such that  
        ( remaining_dur k  - Rqdur j ) > 0 then 
        remaining_dur k  âˆ’= Rqdur  
        totalRm  ++ 
            break  
endfor  
 The task is then to use an optimizer to find a suitable set of 
Rbts such that the number of requests fulfilled by the robots is 
maximized by efficiently fitting robot start times and running 
times to the set Reqs while ensuring that the number of robots 
running simultaneously at any point in time remains below the maximum robot threshold RT. 
We assume that robots operate 12 hours in a day (e.g., 7am to running simultaneously at any point in time remains below the maximum robot threshold RT. 
We assume that robots operate 12 hours in a day (e.g., 7am to 
7pm)  and they run at a fixed speed . The minimum running time 
for a robot is one hour. Robots only operate for a single period per day. We divide the 12 -hour period into 10 -minute time slots such 
that every start time and duration for each robot may be defined by an integer from 0 to 66, wh ere Rst
i = 0 corresponds to a robot 
start time of 7am and Rrti = 0 corresponds to the minimum 
duration of 1 hour. The set of requests Reqs is built from Rq 
random integers from 60 to 180 (i.e., customer requests take 
robots anything from 60 to 180 minutes  to fulfil). Customer 
requests must be fulfilled within the 7am to 7pm working period 
of robots and goods may be delivered at any point during that 
period for all requests . By default Rq = 120 to present a 
significant challenge for the robots; for experimen ts with shorter 
request durations we double Rq to 240.  
In this work we measure the success of solutions for the 
problem using the objective function  to be maximised : 
ğ‘“(ğ‘¥Ì…)=ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘…ğ‘š  
where totalRm  is the total number of requests from Reqs  allocated 
by the scheduler to the current set of robots Rbts. 
We use a single constraint:  
ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘…ğ‘ğ‘¡ğ‘  â‰¤ğ‘…ğ‘‡ 
where totalRbts  is the total number of robots working 
simultaneously in any one timeslot.  As a huma n operator must 
monitor each robot in this problem, RT directly correlates  with the 
number of human operators. Figure 2 illustrates the calculation of  
totalRbts. P. Bentley  et al.  
 
 
 Rbts  0-10 10-20 20-30 30-40 40-50 50-60 60-70 70-80 80-90 90-100 100-110 110-120 
1 0 0 0 1 1 1 1 0 0 0 0 0 
2 0 0 0 0 1 1 1 1 1 1 1 1 
3 1 1 1 1 1 0 0 0 0 0 0 0 
4 1 1 1 1 1 1 1 1 1 1 1 1 
+ 2 2 2 3 4 3 3 2 2 2 2 2 
Figure 2: Example calculation showing  totalRbts  = 4, for four 
robots in a two -hour period (ignoring the minimum duration 
of 60 for this example) . If the threshold RT = 2 then the 
constraint would not be met on 4 out of the 12 possible 
timeslots , marked in bold. When totalRbts <= RT  for every 
timeslot for all robots, the constraint is met fully. In this case 
the constraint score being minimized is 4 - 2 = 2.  With the 
constraint not satisfied, this is not a valid solution.  
3.1 Optimization with Genetic Algorithm 
Our baseline approach to address this problem is to use a genetic algorithm to evolve start times and durations for a set of robots 
such that the constraint is met and the objective is  maximized for 
a given set of customer requests Reqs . 
Our search variables 
ğ‘¥Ì… comprise:  
ğ‘¥Ì…=[ğ‘¥!""#,ğ‘¥$""#,..,ğ‘¥!""%&,ğ‘¥$""%&] 
where we map ğ‘¥!""',ğ‘¥$""' to Rsti, Rrti respectively  for every i. Should 
any i exist such that ğ‘¥!""'+ğ‘¥$""'>65 then the corresponding values 
of Rrti is corrected such that the robot ceases its shift at the end of 
the working day.  Values are corrected during this mapping stage 
rather than modifying  the evolving parameters as this has been 
shown to be more conducive to search [20]. During evolution the 
fitness and constraint is calculated as described above. This is the 
worst -case scenario for the constraint as it assumes that every 
robot will run for its maximum permitted time. In reality, after requests have been scheduled some robots may run for shorter 
durations depending on which requests were allocated. Thus , for 
accuracy, o ur reported results for all experiments first updates  
robot durations  according to the scheduler  in Algorithm 1 : 
âˆ€ğ‘–âˆˆ{1..ğ‘…ğ‘}	ğ‘…ğ‘Ÿğ‘¡'âˆ’=Eğ‘Ÿğ‘’ğ‘šğ‘ğ‘–ğ‘›ğ‘–ğ‘› ğ‘”($'/10K 
and then measure s the actual number of scheduled robots that ran 
simultaneously, as shown in Figure 2. 
We use a constrained optimization algorithm [21] using DEAP  
[22] with tournament fitness (see [2] for the algorithm) to enable 
the equal contribution of constraint and objective to evolution.  
This is a widely used approach in constraint -handling used by 
numerous other researchers [23]. In this method, fitness of each 
individual is the number of times its separate criteria win a series 
of tournaments held between randomly selected subgroups  of 3 
individuals. Within each tournament, the fitness  of an individual 
is increased if its solution is better (lower) for the number of times 
the constraint is not satisfied, and also when its solutio n is better 
(higher) for the objective  ğ‘“(ğ‘¥Ì…) compared to the others in the 
tournament.  We use a Gaussian  Integer creep mutation. 
   
Figure 3: Constrained optimization in learned latent space 
(COIL) applied to real -world autonomous robot scheduling 
problem.  
3.2 Optimization with COIL  
We are tackling a challenging constrained optimization problem, so our proposed approach to be compared with the baseline is 
COIL  [2] â€“ a new hybrid machine learning and optimization 
method  designed to learn valid regions of the search space and 
improve the ability of optimizers to find valid solutions. COIL has 
the advantage that , unlike other constrained optimizers, it does not 
rely on complex operators, weight -tuning, or specialized 
expertise. So far COIL has been tested only on simple test 
functions for constrained optimization ; this is the first research to 
apply this approach to a real -world problem.  
COIL operates using three steps  (Figure 3): 
1. Dataset generation from constraint  
2. Learning new latent represen tation from dataset 
3. Optimization using latent representation  using 
constraint and objective  
For the first step, we use a simple genetic algorithm (using 2. Learning new latent represen tation from dataset 
3. Optimization using latent representation  using 
constraint and objective  
For the first step, we use a simple genetic algorithm (using 
DEAP) with a population size of 200 for running for at most 200 
generations. Our search variables 
ğ‘¥Ì… are exactly as described for 
the baseline GA.  The objective function for this data- generation 
GA is minimization of the number of times the constraint  is not 
satisfied , with any solution that satisfies the constraint added to 
the dataset, and the GA restarting. The threshold RT, which 
determines how many robots may work simultaneously , is varied 
during experiments. Solutions that specify robot durations that 
finish beyo nd the 12- hour working period  are corrected as 
described in 3.1 before being normalized and added to the dataset.  
To encourage the dataset -generating GA not to â€œcheatâ€ and only 
provide solutions with minimal robot running times (the simplest 
way to satisfy  the constraint), we also add a selective pressure 
towards longer robot durations by adding 100 âˆ‘ ğ‘¥$""' )%
#â„  to the 
fitness term. We run this GA repeatedly until DS vectors  are 
generated. Each vector represents a valid set of robot start times 
and duration s such that the constraint is satisfied. The overall 
objective to find robot times and durations that enable the most 
customer requests is not used at this point.  
In the second step, we provide  the dataset to a simple 
variational autoencoder [2] with 4 linear layers , a prior  of N(0,I), 
KLD = 1, for 200 epochs using the Adam optimizer with a 
learning rate of 0.001. We run the VAE 10 times and choose the 
learned model with the lowest error. This is our learned latent 
representation , with latent variables:  
ğ‘§Ì…=[ğ‘§#,ğ‘§*,..,ğ‘§*Ã—,-./0] Learn ing Valid Search Spaces of Autonomous Robots   
 
 In the third step, we use the same GA as described in section 
3.1, to ensure a completely fair comparison. For this GA, the 
search variables ğ‘§Ì… are encoded as real -valued variables with 
ranges between -2.0 and 2.0, and a Gaussian creep mutation. We 
convert ğ‘§Ì… into ğ‘¥Ì… by using the learned VAE model  to express the 
values , and then  perform a scalar inverse transform, 
unnormalization, and conversion to intege r to convert the VAE 
output into the desired 0..66 range.  We then map ğ‘¥!""',ğ‘¥$""' to Rsti, 
Rrti respectively  for every i as described in section 3.1  with the 
same robot duration updates performed according to the scheduler  
and use the identical tournament fitness approach to measure 
fitness for the objective and constraint. 
4 EXPERIMENTS 
4.1 Experiments  
We perform experiments to investigate the following research 
questions, which reflect the two stages to this problem : 
 
RQ1: Does COIL help us explore valid design variations more 
effectively than the baseline GA?  
We explore this question in several experiments . 
E1.1: Can the baseline GA and  COIL help us explore valid 
solutions ? Before we can explore different design variations we 
need to check that we can solve this problem at all. Experiment 1 
tackles this by directly comparing the output of the baseline GA with COIL.  Following the training of the VAE within COIL, the 
same learn ed model is used in all repeated runs. We use a small 
population size of 20 for just 50 generations following  [2, 3]. Both 
GAs are run 100 times and mean results are shown.  A new set of 
requests Reqs  is randomly generated for every run.  
E1.2: Can the GA and COIL explore  valid solutions varying 
RT? In this experiment we explore variants  of the problem by 
varying RT to the values: 10, 15, 20. This explores solutions 
where we permit more robots to run simultaneously (at the cost of 
requiring more human monitoring.)  
E1.3: Can the GA and COIL explore  valid solutions varying 
Rb? In the second problem variant, we fix RT to 10 and vary the 
number of robots Rb to the values: 2 0, 25, 30.  This explores 
solutions where we have fewer robots overall, with at most 10 running simultaneously.  
E1.4: Can the GA and COIL explore  valid solutions varying 
dr? In our final set of problem variants, w e vary the duration of 
requests; instead of random from 60 to 180, we try 60 to dr, where 
dr 
âˆˆ {60, 80, ..,  360}.  
For all RQs, parameters other than those being varied remain 
unchanged. COIL is run 100 times for each setting, with a new set Reqs  of random requests each run.  
 
RQ2: Is COIL an efficient algorithm for daily optimization?  
Once the company decides on the number of robots and operators to use, we arrive at the second stage. Here we investigate the 
suitability of COIL for use as a daily optimizer, investigating 
whether the method can be tuned with this goal in mind.  E2.1: Can we use smaller  dataset size s for COIL without 
affect ing its ability to generate usef ul latent representations?  We 
need a fast way of optimizing robot schedules every day for the new set of requests, while always meeting the constraint. O ne 
drawback of COIL is the need to generate a dataset first  and train 
the VAE. Although this is a one -off, offline computation, it is still 
significant . This experiment  addresses this by varying the dataset 
size DS to four different values: 2500, 5000, 7500, 10000. All 
other parameters remain unchanged. COIL is run 100 times (with 
a new set Reqs  of random requests each run) and mean results are 
shown. We also measure the difference in data generation and 
training times and the error rate of the VAE.  
E2.2: Can we imp rove the performance of COIL by reducing 
the number of latent variables?  Here we investigate an idea for 
improving the performance of COIL.  While COIL was described E2.2: Can we imp rove the performance of COIL by reducing 
the number of latent variables?  Here we investigate an idea for 
improving the performance of COIL.  While COIL was described 
as a method to improve the search space while keeping the number of latent variables the sa me as the number of input 
variables, other work has shown that VAEs may be able to provide the additional benefit of reducing the search  space size 
[24]. We investigate this question with the number of robots Rb = 
30 (giving us 60 problem variables) by varying maxlv  to the 
values: 5, 10, 15, 20, 25, 30 (i.e., 10 to 60 latent variables) . All 
other parameters remain unchanged.  COIL is run 100 times for 
each setting, with a new set Reqs  of random requests each run.  
Table 1 summarizes the parameters investigated in each 
experiment. All processing was performed on a MacBook Air 
2020 M1 with 16Gb memory. All code was implemented in 
Python and is available
1. 
 
Table 1. Parameters for the experiments  
Exp DS maxlv  RT Rb dr 
E1.1 10000 30 10 30 180 
E1.2 10000 30 10,15,20  30 180 
E1.3  10000 30 10 20,25,30  180 
E1.4  10000 30 10 30 60..360  
E2.1 2500..10000  30 10 30 180 
E2.2  10000 5..30  10 30 180 
 
4.2 Results  and Analysis 
In this section we describe the results for  research question RQ1 
(experiments E1.1, E1.2, E1.3 and E1.4) and for RQ2 (experiments E2.1 and E2.2).  
 Table 2. E1. 1: COIL vs GA.  Better results in bold.  
 COIL  GA 
avg objective  (stdv) 66.43 (6.80) 93.6 (5.55)  
min objective 51 76 
max objective  77 107 
avg constraint  (stdv) 23.93 ( 8.43) 44.7 (3.89) 
min constraint  0 35 
max constraint  30 52 
 
1 GitHub link temporarily removed for purposes of paper anonymization. P. Bentley  et al.  
 
 
  
Figure 4: Example s ingle best run baseline GA. 
 
 
Figure 5: Example best run COIL . 
 
E1.1: Can the GA and COIL help us explore valid solutions ? 
In this experiment we compare the output of the baseline GA with 
COIL to check that both can find valid solutions for our default 
parameter values. Table 2 summarizes the results. The results 
show that only  COIL is able to provide valid solutions for this 
variant of the problem. COIL provides superior results in terms of constraint satisfaction, with the best results being a perfect zero, 
and average of 23.9, compared t o the baseline GA best of 35 
(worse than the worst score of COIL) and average of 44.7. The scores for the objective shows that GA allocates more tasks on 
average than COIL, managing 107 at best compared to COILâ€™s much lower 77. However, the scores are mean ingless when the 
constraint is broken â€“ the baseline GA cheats by not meeting the 
constraint in order to allocate more requests, and such solutions 
are not viable or useful.  
Examining a single best run for the baseline GA and COIL, 
Figure 4 and Figure 5 show the difference in evolution. The GA 
attempts to improve the constraint while keeping request 
allocation constant but never achieves a single valid solution â€“ 
showing a failure of this algorithm to tackle the problem effectively. In contrast COIL start s better and optimizes the 
constraint to zero very rapidly while keeping the number of requests allocated constant. To assess whether the GA could be 
coerced into focusing more on the constraint, we increased the 
weighting by 10 times in the tournament sel ection algorithm for the constraint; we also tried much larger population sizes and number of generations. The results were barely changed and the 
GA still failed to find any solutions that satisfied the constraint. Figure 4 and Figure 5 (grey line) also show how effectively 
ğ‘¥Ì… is 
being optimized, with both algorithms ensuring that  91% of the 
robotsâ€™ time is being used.  While COIL does not find perfect 
solutions every time for this difficult problem (unlike findings of [2, 3]) it is clear that its learned latent representation is biased 
towards solutions  that satisfy the constraint more, with Figure 6 
top left showing that the baseline GA results (orange cir cles) are 
all worse than the COIL results (blue circles).  
 
E1.2 : Number of simultaneously running robots  RT 
When we increase the value of RT, we make the constraint easier 
as more robots are permitted to run simultaneously. The results show that in all problem variants, COIL successfully finds valid 
solutions to the problem. However, as the optimization problem becomes easier, the baseline GA begins to function more usefully 
(Figure 6 top left). When RT = 10, COIL performs better than the 
baseline GA. When RT = 15, COIL is able to find more solutions 
that satisfy the constraints, while the baseline GA still finds none. But when RT = 20 (the problem is no longer diffic ult) there is no 
longer any significant difference between the GA and COIL, with COIL finding slightly more valid solutions, but the GA finding a 
few solutions that satisfy the constraint and fulfil the objective 
slightly better.  
 
E1.3 : Total n umber of robots  Rb 
Similar to the previous experiment, when we reduce the value of Rb, we make the constraint easier as fewer robots in total are 
running, so fewer are likely to run simultaneously. However, with RT fixed we do not see improvements in objective scores (keeping 
the number of simultaneously running robots constant, limits the number of requests that can be served). When reducing Rb from 
30 to 25, the baseline GA comes closer to finding valid solutions. When Rb = 20, the GA finds several valid solutions. H owever, for 
all values tested, COIL always finds valid solutions to the 
problem, becoming more consistent as the problem is easier 
(Figure 6 top right).  
 E1.4 : Changi ng request durations dr all values tested, COIL always finds valid solutions to the 
problem, becoming more consistent as the problem is easier 
(Figure 6 top right).  
 E1.4 : Changi ng request durations dr 
If we alter the request durations (increasing the number of requests from 120 to 240 to make up for smaller durations), we change the difficulty of the problem in a new way: shorter tasks 
are easier to allocate while longer tasks are more difficult. Figure 
7 shows how the average number of constraints broken slightly 
improves (lowers) as the request duration increases for COIL, 
suggesting that COIL scales better to gre ater problem difficulty. 
As expected, the number of requests that can be allocated falls as the task durations increase, with the baseline GA always allocating more (because it cheats by not satisfying the 
constraint). Figure 6: Best result at final generation for 100 runs  for each algorithm , plotted with objective score against constraint . Lower 
means constraint is better satisfied, more to the right means more tasks are allocated. Only solutions on y = 0 satisfy the c onstraint 
fully and thus are valid. Top left: E1.1 Comparing GA and COIL and E1.2 Varying RT. Top right: E. 1.3 Varying Rb. Bottom left: 
E2.1 Varying  COIL  DS. Bottom right: E2.2 Varying  COIL  maxlv . 
 
 
Figure 7: E1.4: Altering maximum random request durations.  
 
E2.1: Reducing dataset size DS 
The previous  experiments showed that COIL clearly outperforms 
the baseline GA for this real -world problem  â€“ only COIL has 
permitted us to explore valid solutions for all design variations 
tested . However, there is a difference in computation time 
required. When evolving the solutions for E1.1, the baseline GA 
took 1 .89 minutes to complete 100 runs. COIL took a slightly 
shorter 1.81  minutes â€“ despite the additional need to express the 
evolving latent variables into the problem variables using the VAE. However, COI L also required a one -off pre -computation to generate valid data and use the VAE to learn the latent 
representation. This computation was substantial, requiring 25.80 
hours  to generate 10,000 datapoints, and 8.95 minutes for the 
VAE to learn (running 10 ti mes and choosing the best learned 
model, which had loss of 0.9114).  These times reduced when the 
problem was easier, for example in E1.2, 10,000 valid points were generated in just 19.28 minutes when RT = 15, and just 8.08 
minutes when RT = 20.  
In the next experiment, we investigate the effects of the dataset 
size to see if COIL can still achieve acceptable results when the VAE is trained with smaller datasets.  We achieved this by simply 
running the data generator each time with DS = 2500, 5000, 7500, 
and 10000. The datasets were checked to see if they contained any redundancy through duplication; analysis revealed that every 
point in each dataset is unique and not repeated.  
Figure 8 shows the differences in computation time vs the 
VAE loss , indicating that the dataset of size 5000 has the smallest 
loss; detailed results from COIL for the constraint and objective 
for each dataset size  are provided in Supplementary Materials . 
While the best average constraint satisfaction is achieved using 
the largest dataset, performance is still relatively unaffected for 
even the smallest size. Figure 6 (bottom left) shows that valid 
solutions on y = 0 are generated by all dataset sizes, and all also 
have a similar trend in the solution space. P. Bentley  et al.  
 
 
  
E2.2 : Modifying num ber of  latent variables  maxlv  
Finally we investigate whether we can improve the performance 
of COIL in terms of the quality its solutions. Applying COIL with 
different numbers of latent variables shows an important effect on 
the distribution of solutions, Figure 6 (bottom right) and 
Supplementary Materials . Reducing the number of latent variables 
generally improves the ability of COIL to find solutions that satisfy the constraint.  Fewer latent vari ables mean faster training 
time for the VAE, and faster optimization for the GA using the smaller latent representations. But as the number of latent 
variables decreases to 10, the VAE loss becomes worse ( Figure 
9). The smaller search space also appears to impact the objective, 
with fewer tasks being allocated.  
In contrast, increasing to 50 or more latent variables appears to 
provide an unwelcome bias away from valid so lutions on y = 0. 
For this problem, there appears to be a â€œsweet spotâ€ between 
maxlv=15 and maxlv=25 (30 and 50 latent variables  respectively), 
where solutions with high number of request allocations and perfect constraint scores are generated ( Figure 6 bottom right). 
For our problem it appears that having fewer latent variables 
compared to problem variables is advantageous.  
 
 
Figure 8: Computation time and VAE loss  for E2.1 . Bar chart 
using left y-axis: Data generation (hours), VAE training 
(minutes), blue line using right y-axis: VAE loss. 
 
 
Figure 9: Computation time and VAE loss fo r E2.2 . Bar chart 
using left y-axis: VAE training (minutes), blue line using right 
y-axis: VAE loss. 
 4.3 Discussion of Findings Relating to Problem  
COIL has enabled a useful exploration of the design space for this 
real-world problem. Our findings indicated that the amount of 
available time spent by robots delivering requests rarely changes (usually at around 90%). This appears to be the best use of the 
robotsâ€™ time as determined by the scheduler , and both optimizers 
are always able to find appropriate start times and durations for 
the autonomous robots to reach this efficiency. However, results 
from the baseline GA were often unusable as the safety constraint 
was not met. COIL provided usable results for all setups. The experiments also showed that when customer requests were likely 
to take less time, more would be delivered successfully by the robots. The safety constraint was slightly more likely to be 
satisfied by COIL for longer duration requests; for the baseline 
GA there was no difference.  
Over all, COILâ€™s exploration of the problem space  indicate s 
that when we keep the total number of robots Rb constant but 
allow more to run simultaneously (i.e., more human monitors are employed), the number of customer requests tha t can be satisfied 
will increa se. In contrast, if we keep the number of simultaneously 
running robots RT constant and reduce the overall numbers of 
robots that are running, there is little change to the number of 
customer requests met. Thus, with the fixed relationship between 
the numb er of simultaneously running robots and the number of 
human monitors, there appears to be a direct correlation between the number of human monitors and customer satisfaction.   
5 CONCLUSIONS 
The problem of scheduling autonomous robots safely such that sufficient human monitors are available is challenging , and 
relatively  unexplored in the literature . Our work shows that a  
standard genetic algorithm using a well-established method  for 
constrained optimization (the baseline GA ) was unable to find 
solutions tha t satisfied the constraint except for variations where 
the problem was relatively easy. In contrast a new ML -EA hybrid 
approach (constrained optimization in learned latent space: COIL ) 
was able to find valid solutions for all problem variants, enabling 
us to perform a useful investigation of the effects of each approach (constrained optimization in learned latent space: COIL ) 
was able to find valid solutions for all problem variants, enabling 
us to perform a useful investigation of the effects of each 
parameter on solutions. This work has also shown for the first 
time that the data -generation and training stage of COIL can be 
improved by reducing the dataset size and number of latent 
variables. This means that once suitable parameters are selected, 
and the initial one -off training is performed  to learn the latent 
representation , COIL is able to optimize new schedules rapidly 
and reliably. Indeed, with these improvements, COIL is 10% 
faster to run than  the baseline GA. COIL is thus an ideal choice 
for an everyday optimizer for this problem.  
Future work will examine further problem variables of interest 
to our industrial partner such as robot speed and will integrate 
with other schedulers. Other  improvements to COIL will be 
examined, such as the use of more advanced VAEs and optimizers such as MAP -Elites for the data generation and optimization 
stages, to further improve speed and efficiency. Learn ing Valid Search Spaces of Autonomous Robots   
 
 REFERENCES 
[1] M. Figliozzi and D. Jennings, ""Autonomous delivery robots and their potential 
impacts on urban freight energy consumption and emissions,"" Transportation 
research procedia, vol. 46, pp. 21 -28, 2020. 
[2] P. J. Bentley, S. L. Lim, A. Gaier, and L. Tran, ""COIL: Constrained 
Optimi zation in Learned Latent Space --Learning Representations for Valid 
Solutions,"" in ACM Genetic and Evolutionary Computation Conference 
(GECCO'22) Companion , 2022, pp. 1870 â€“1877.  
[3] P. J. Bentley, S. L. Lim, A. Gaier, and L. Tran, ""Evolving through the look ing 
glass: Learning improved search spaces with variational autoencoders,"" in 
International Conference on Parallel Problem Solving from Nature (PPSN) , 
2022, pp. 371 -384. 
[4] N. Boysen, S. Schwerdfeger, and F. Weidinger, ""Scheduling last -mile deliveries 
with truck -based autonomous robots,"" European Journal of Operational 
Research, vol. 271, no. 3, pp. 1085 -1099, 2018.  
[5] S. Yu, J. Puchinger, and S. Sun, ""Two -echelon urban deli veries using 
autonomous vehicles,"" Transportation Research Part E: Logistics and 
Transportation Review, vol. 141, p. 102018, 2020.  
[6] A. Karak and K. Abdelghany, ""The hybrid vehicle -drone routing problem for 
pick-up and delivery services,"" Transportation Research Part C: Emerging 
Technologies, vol. 102, pp. 427 -449, 2019.  
[7] C. Chen, E. Demir, Y. Huang, and R. Qiu, ""The adoption of self -driving 
delivery robots in last mile logistics,"" Transportation research part E: logistics 
and transportation review, vol. 146, p. 102214, 2021.  
[8] I. Bakach, A. M. Campbell, and J. F. Ehmke, ""Robot -Based Last -Mile 
Deliveries With Pedestrian Zones,"" Frontiers in Future Transportation, p. 32, 
2022.  
[9] K. Braekers, K. Ramaekers, and I. Van Nieuwenhuyse, ""The vehicle routing  
problem: State of the art classification and review,"" Computers & industrial 
engineering, vol. 99, pp. 300 -313, 2016.  
[10] S. Kapser and M. Abdelrahman, ""Acceptance of autonomous delivery vehicles 
for last- mile delivery in Germany â€“Extending UTAUT2 with ri sk perceptions,"" 
Transportation Research Part C: Emerging Technologies, vol. 111, pp. 210 -
225, 2020.  
[11] H. Liu, R. Yang, L. Wang, and P. Liu, ""Evaluating initial public acceptance of highly and fully autonomous vehicles,"" International Journal of Human â€“
Computer Interaction, vol. 35, no. 11, pp. 919 -931, 2019.  
[12] G. E. Hinton and R. R. Salakhutdinov, ""Reducing the dimensionality of data 
with neural networks,"" Science, vol. 313, no. 5786, pp. 504 -507, 2006.  [13] D. P. Kingma and M. Welling, ""Auto -encoding  variational bayes,"" in 
Proceedings of the International Conference on Learning Representation (ICLR), 2014.  
[14] Ã–. Yeniay, ""Penalty function methods for constrained optimization with genetic 
algorithms,"" Mathematical and Computational Applications, vol. 10, no. 1, pp. 
45-56, 2005. 
[15] V. Volz, J. Schrum, J. Liu, S. M. Lucas, A. Smith, and S. Risi, ""Evolving Mario 
levels in the latent space of a deep convolutional generative adversarial 
network,"" in Proceedings of the Genetic and Evolutionary Computation 
Conference (GECCO) , 2018, pp. 221 -228. 
[16] P. Bontrager, A. Roy, J. Togelius, N. Memon, and A. Ross, ""Deepmasterp rints: 
Generating masterprints for dictionary attacks via latent variable evolution,"" in 
Proceedings of the 2018 IEEE 9th International Conference on Biometrics 
Theory, Applications and Systems (BTS) , 2018, pp. 1 -9. 
[17] P. Liskowski, K. Krawiec, N. E. Toklu, and J. Swan, ""Program synthesis as latent continuous optimization: Evolutionary search in neural embeddings,"" in 
Proceedings of the 2020 Genetic and Evolutionary Computation Conference , 
2020, pp. 359 -367. 
[18] J. K. Pugh, L. B. Soros, and K. O. Stanley , ""Quality diversity: a new frontier for 
evolutionary computation,"" Frontiers in Robotics and AI, vol. 3, p. 40, 2016. 2020, pp. 359 -367. 
[18] J. K. Pugh, L. B. Soros, and K. O. Stanley , ""Quality diversity: a new frontier for 
evolutionary computation,"" Frontiers in Robotics and AI, vol. 3, p. 40, 2016.  
[19] A. Gaier, A. Asteroth, and J. -B. Mouret, ""Discovering representations for 
black -box optimization,"" in Proceedings of the Genetic and  Evolutionary 
Computation Conference (GECCO) , 2020, pp. 103 -111. 
[20] T. Yu and P. Bentley, ""Methods to evolve legal phenotypes,"" in Proceedings of 
the International Conference on Parallel Problem Solving from Nature (PPSN) , 
1998, pp. 280 -291. 
[21] K. Deb,  ""An efficient constraint handling method for genetic algorithms,"" 
Computer Methods in Applied Mechanics and Engineering, vol. 186, no. 2 -4, 
pp. 311 -338, 2000.  
[22] F.-M. De Rainville, F. -A. Fortin, M. -A. Gardner, M. Parizeau, and C. GagnÃ©, 
""Deap: A python framework for evolutionary algorithms,"" in Proceedings of the 
14th annual conference companion on Genetic and evolutionary computation , 
2012, pp. 85 -92. 
[23] C. A. C. Coello, ""Theoretical and numerical constraint -handling techniques 
used with evolutionary  algorithms: a survey of the state of the art,"" Computer 
methods in applied mechanics and engineering, vol. 191, no. 11 -12, pp. 1245 -
1287, 2002.  
[24] X. Ding, Z. Zou, and C. L. Brooks III, ""Deciphering protein evolution and fitness landscapes with latent s pace models,"" Nature communications, vol. 10, 
no. 1, pp. 1 -13, 2019. SUPPLEMENTA RY MATERIA LS  
 
 
Table S1: E1.2 : Modifying RT:  number of simultaneously running robots , COIL . 
COIL 10 robots at once  15 robots at once  20 robots at once  
avg objective (stdv)  66.43 (6.80)  73.94 (3.99)  89.86 (3.14)  
min objective  51 63 83 
max objective  77 84 98 
avg constraint (stdv)  23.93 (8.43)  9.91 (10.78)  0.81 (2.86)  
min constraint  0 0 0 
max constraint  30 29 16 
 
Table S2: E1.2 : Modifying RT:  number of simultaneously running robots , GA. 
GA 10 robots at once  15 robots at once  20 robots at once  
avg objective (stdv)  93.6 (5.55)  91.09 (5.43)  92.24 (4.32)  
min objective  76 80 80 
max objective  107 108 103 
avg constraint (stdv)  44.7 (3.89)  26.69 (5.56)  0.8 (2.97)  
min constraint  35 10 0 
max constraint  32 41 17 
 Table S3: E1.3: Modifying Rb: total number of robots , COIL . 
COIL 20 total robots  25 total robots  30 total robots  
avg objective (stdv)  50.67 ( 3.63) 57.96 ( 7.59) 66.43 (6.80)  
min objective  44 47 51 
max objective  62 72 77 
avg constraint (stdv)  4.4 (8.4) 15.39 ( 13.13)  23.93 (8.43)  
min constraint  0 0 0 
max constraint  27 32 30 
 Table S4: E1.3: Modifying Rb: total number of robots , GA. 
GA 20 total robots  25 total robots  30 total robots  
avg objective (stdv)  63.47 ( 5.33) 81.01 ( 6.49)  93.6 (5.55)  
min objective  51 64 76 
max objective  75 102 107 
avg constraint (stdv)  23.71 ( 7.97) 38.35 ( 4.71) 44.7 (3.89)  
min constraint  0 26 35 
max constraint  41 48 32 
 
Table  S5: E2.1 : Modifying dataset size  DS 
 2500 data points  5000 data points  7500 data points  10000 data points  
avg objective (stdv)  66.75 (5.87)  68.2 (8.15)  65.45 (8.09)  66.43 (6.80)  
min objective  51 49 48 51 
max objective  81 82 80 77 
avg constraint (stdv)  26.52 (4.22)  25.66 (8.02)  23.28 (8.18)  23.93 (8.43)  
min constraint  0 0 0 0 
max constraint  31 33 31 30 
 
Table  S6: E2.2 : Modifying number of latent variables  maxlv  
 10 latent variables 20 latent variables 30 latent variables 40 latent variables 50 latent variables 60 latent variables 
avg objective (stdv)  50.1 (2.26)  52.08 (2.40)  53.19 (2.86)  53.26 (3.38)  53.47 (3.56)  66.43 (6.80)  
min objective  45 47 47 44 47 51 
max objective  56 59 61 63 70 77 
avg constraint (stdv)  9.25 (5.64)  1.96 (3.03)  4.69 (6.11)  4.41 (6.78)  6.69 (7.83)  23.93 (8.43)  
min constraint  0 0 0 0 0 0 
max constraint  19 13 24 25 32 30"," This paper explores the use of a hybrid machine-learning-optimization approach called COIL to optimize autonomous robot timings for last-mile delivery services. It compares COIL with a baseline genetic algorithm and investigates new methods for improving the speed and efficiency of COIL. Results show that COIL can find valid solutions where appropriate numbers of robots run simultaneously and that it can optimize 10% faster than the GA, making it a good choice for daily re-optimization of robots. The paper also reviews relevant research in autonomous robot routing and safety, and provides data comparing the performance of COIL and GA."
16," Vectorial Genetic Programming { Optimizing
Segments for Feature Extraction
Philipp Fleck1;2?[0000"," This paper presents Vectorial Genetic Programming (Vec-GP), an extension of Genetic Programming (GP) which allows vectors as input features. It introduces strategies for optimizing a window for aggregation functions, including random and guided sampling. Results indicate that the random sampling strategies perform better than the guided strategies, which can become stuck in local optima. The paper also compares the performance of random versus guided direction and range reduction for feature extraction, and suggests that simple random sampling is generally better than the guided strategies."
17," This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 Low -discrepancy S ampling  in the 
Expanded Dimensional Space: A n 
Acceleration Technique for Particle Swarm 
Optimization  
 
Feng Wu *, Yuelin Zhao , Jianhua Pang *, Jun Yan,  and Wanxie Zhong  
 
State Key Laboratory of Structural Analysis, Optimization and CAE Software for 
Industrial Equipment , Department  of Engineering Mechanics , Faculty of Vehicle 
Engineering and Mechanics, Dalian University of Technology, Dalian 116023, 
P.R.China ; Guangdong Ocean University, Zhanjiang 524088, China ; Shenz hen 
Institute of Guangdong Ocean University, Shenzhen 518120, China  
Email:,  wufeng_chn@163.com , zhaoyl9811@163.com , pangjianhua@gdou.edu.cn , 
yanjun@dlut.edu.cn, wxzhong @dlut.edu.cn  
 
 
Project supported by  the National Natural Science Foundation of China grants (Nos. 11472076, 
51609034 and U1906233), the National Key R&D program of  China (No. 2021YFA1003501), the 
Science Foundation of Liaoning Province of China (No. 2021 -MS-119), the Dalian Youth Science 
and Technology Star project (No. 2018RQ06), and the Fundamental Research Funds for the 
Central Universities grant (Nos. DUT20RC(5)009 and DUT20GJ216).  
 
 
*Corresponding author: wufeng_chn@163.com ; yanjun@dlut.edu.cn  
March 2023 This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 Abstract : Compared with random sampling,  low-discrepancy sampling  is more effective in 
covering the search space. However, the existing research cannot definitely state  whether the 
impact of a  low-discrepancy samp le on particle swarm optimization (PSO) is positive or negative.  
Using Niderreiter â€™s theorem, this study  completes an error analysis of PSO, which  reveals  that the 
error bound of PSO at each iteration depends on the dispersion  of the sample  set in an expanded 
dimensional space. Based on this error analysis , an acceleration technique  for PSO-type 
algorithms  is proposed with low-discrepancy sampling  in the expanded dimensional space.  The 
acceleration technique can generate  a low-discrepancy sample set with  a smaller dispersion, 
compared with  a random sampling, in the expanded dimensional space;  it also  reduce s the error at 
each iteration, and hence improve s the convergence speed. The acceleration technique is 
combined with the standard PSO and  the c omprehensive learning particle swarm optimization, 
and the performance of the improved algorithm is compared with the o riginal algorithm. The 
experimental results show that the two improved algorithms have significantly faster convergence 
speed under the same accuracy requirement.  
 
Keywords : Evolutionary algorithm; Low -discrepancy sample; Particle swarm optimization; 
Comprehensive learning particle swarm optimization; Swarm intelligence; Convergence speed  
1. Introduction  
article swarm optimization (PSO) is a population -based stochastic optimization technology. 
Since it was proposed by Kennedy and Eberhart in  1995 [1, 2] , it has attracted great attention.  
PSO is an excellent evolutionary algorithm that is easy to implement, can quickly converge to the 
optimal solution, and has been proven to perform well i n many fields, such as neural networks [3, 
4], photovoltaic system [5], feature selection [6, 7], operational research [8], etc. 
However, it is not easy for PSO to consider both the convergence speed and calculation 
accuracy when solving complex optimization problems. Many excellent PSO variants are 
committed to solving this problem, and can be divided based on three aspects. The fi rst aspect is 
to enhance the PSO by adjusting the parameter changes in the algorithm; Shi and Eberhart [9] 
introduce d the inertia weight, which can balance the local development and global search 
capabilities of PSO.  Clerc and Kennedy  [10] proposed  a set of coefficients to control the 
convergence trend of the system.  Zhan et al.  [11] developed an  adaptive PSO  and improved the 
search efficiency. There are also a sea of enhancement approaches for the PSO iteration formula . 
Liang et al.  [12] proposed a new comprehensive learning particle swarm optimizer  (CLPSO), This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 which introduces a learning strategy to update the particleâ€™s velocity that  significantly improves 
the performance of PSO. Lynn and Suganthan [13] proposed heterogeneous comprehensive 
learning particle swarm optimization  (HCLPSO) , which divides the population into two 
subpopulations, and each subpopulation only focuses on exploration or expl oitation to maintain 
the diversity of the population.  Zhan et al.  [14] proposed orthogonal learning particle swarm 
optimization, which  employs an orthogonal learning strategy  that can  guide particles t o fly in an 
optimal direction.  Liu et al. [15] proposed an improved quantum particle swarm optimization with 
LÃ© vy flight and straight flight, which is more suitable for high -dimensional situations.  Mendes et 
al. [16] and Zeng  et al.  [17] showed that replacing the best position among all the particles with 
the best position in some smaller number  of adjacent particles can also improve the search ability 
of PSO. The third aspect focuses on population initialization [18, 19] . In general, the population is 
generated by random samples [20, 21] . However, quite a few researchers believe that the 
uniformity of the initial population obviously impacts the search ability of PSO. Employing 
numerical experiments,  Richards and Ventura [22] concluded that  low-discrepancy sampling 
(LDS)  can be used to improve the calculation accuracy and the convergence  speed of PSO in high -
dimensional space.  Morrison  [23] verified,  based on numerical simulations , that the LDS 
initialization method can reduce the variation  of the search results without losing accuracy and 
performance.  Nevertheless, some studies stil l disagree with this view. Li  et al.  [24] showed 
through the numerical results that random initialization is most suitable for PSO.  Tharwat and 
Schenck [25] compared the effects of five famous population initialization methods and concluded 
that PSO is not sensitive to initialization methods under sufficient numbers of iterations.  
It can be said that the existing studies did not give a clear conclu sion on whether the 
uniformity of the initial sample set  has a positive or negative impact on the PSO algorithm and 
why this impact occurs. The author has also done experiments, and the result show that PSO is not 
sensitive to initialization methods. The a uthor has further verified the effect of using LDS directly 
in each iteration, and the result is worse . However, it is undeniable that many experiments observe 
that in the early iterations process , the population generated by  LDS  has a better convergence 
speed. Then, why canâ€™t the advantages of using an LDS initialization at the early iterations be 
preserved during the entire iteration of PSO? Furthermore, what is the relationship between the This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 error of the entire iteration process of PSO and the sample unifo rmity? These unclear conclusions 
and contradictions motivated us to investigate more deeply. First, we try to find the answers to 
these two questions from the existing theoretical analysis.  
Currently, the theoretical study of the PSO algorithm mainly focu ses on two aspects. One is 
the movement of the single particle or the particle swarm with time; Kennedy [26] simulated 
different particle trajectories by simplifying the particle evolution model. Ozcan  and Mohan [27] 
pointed out that particles move along a path defined by a sinusoidal wave in a simplified one -
dimensional PSO system . van den Bergh [28] developed a model that could describe the behavior 
of a single particle to investigate the local convergence properties of PSO. Liang et al.  [12] 
analyzed the particle swarm systemâ€™s search beha vior and concluded that the CLPSO algorithm 
can search a greater number of potential regions. Another aspect of theoretical analysis is studying 
PSOâ€™s stability and convergence.  Clerc and Kennedy [10] first analyzed the stability of PSO . 
Trelea [29], Emara and Fattah  [30] determined the parameter range that can ensure the stability or 
convergen ce of the algorithm through a similar analysis.  GarcÃ­ a -Gonzalo and FernÃ¡ ndez -MartÃ­ nez 
[31] provided an analytical expression for the upper bound of the second -order stable regions of 
the particle traje ctories. Kadirkamanathan et al.  [32] analyzed the stability of the particle 
dynamics under stochastic conditions using a Lyapunov stability analysis and the concept of 
passive systems.  
From the current  work, it is easy to see that although many studies have focused on a 
theoretical analysis of the PSO algorithm, an error analysis of PSO urgently needs research 
attention. Moreover, the existing theoretical analysis cannot explain the two questions raised  in the 
previous article. Therefore, this study attempts to answer these two questions. Using  Niderreiterâ€™s 
theorem, this study  analyzes the error of PSO and propose s a new acceleration technique. Some 
representative LDSs are selected for numerical validat ion. At present, there are many types  of 
LDSs. For example, there are sampling methods based on orthogonal experimental design , 
includ ing the Latin hypercube [33], orthogonal array [34], uniform experimental design [35] and 
so on. There are also sampling methods based on number theory, which often have relatively 
simple generation formats, such as the Hua -Wang sampl ing (HWS) [36-38], Halton sampling  (HS) 
[39], Sobol sampl ing (SS) [40] and so on. In addition, there are some other sampling methods, This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 such as Chaos sampling [41], Poisson disk sampling [42, 43] , optimized Halton sampling (OHS) 
[44], and dynamics evolution sampling (DES) [45]. The OHS uses an evolutiona ry algorithm to 
optimize HS, and the DES uses a dynamic evolutionary algorithm to optimize the existing 
samples.  Both methods generate a large number of samples, which can be downloaded directly on 
the internet.  We choose HWS, DES, SS and Halton  scramble  sampling  (HSS) [46], a modified 
version of the famous H S for numerical verification. The research contributions of this study are 
as follows:  
1) Based on Niderreiter â€™s theorem, an error analysis of PSO is given, and the influence of 
LDS initialization on the PSO calculation results is clarified. The relationship among sample 
uniformity, calculation error and the convergence rate is found, which provides a new theoretical 
basis for improving PSO.  
2) Based on th e theoretical derivation in 1), a new acceleration technique, LDS in the 
expanded dimensional space (LDSEDS), is given . According to different sample construction 
methods, two versions of LDSEDS are proposed . These two versions are combined with PSO to 
generate two more effective algorithms. In the simulation studies, several benchmark functions are 
performed, and the performances of the proposed algorithms are compared with the original PSO 
to demonstrat e the superiority of these two algorithms.  At the sam e time, the computational 
performance of these two algorithms is compared, and a more effective algorithm is selected for 
higher dimension promotion.  
3) The LDSEDS acceleration technique proposed in 2) continues to be extended to other 
PSO series algorithms. Considering that the theoretical derivation in 1) needs preconditions, 
CLPSO is ultimately selected for an improvement to form CLPSO -LDSEDS, and the superiority 
of CLPSO -LDSEDS is also verified.  
The rest of this paper is organized as follows. Section  2 briefly introduces the preliminaries. 
Section  3 gives the error analysis of PSO. Section 4 proposes a new acceleration technique 
LDSEDS to form two acceleration algorithms. In Section 5, the acceleration algorithms are 
verified numerically. In Section  6, this  acceleration technique is extended to CLPSO. Finally, 
Section 7 draws a conclusion and gives future work directions. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 2. Preliminaries  
2.1 Particle Swarm Optimization  
Without loss of generality, we assume a 
-D dimensional optimization problem to be 
expressed as  
 
() ( ) 12 min , , , D
i i if f x x x
a x b= ïƒ¬
ïƒ­ï‚£ï‚£ïƒ®x
 . (1) 
where 
()fx  is the cost  function, and 
ia  and 
ib  represent the boundary of the search space. To 
solve Eq. (1), we use PSO, which  simulates the swarming habits of animals such as birds [1]. The 
positions and velocities of all the particles at the 
-thg  iteration are expressed as  
 
ï› ï ï› ï ,1 ,2 , ,1 ,2 ,, , , , , , , g g g g N g g g g N==X x x x V v v v
 , (2) 
where 
N  is the number of particles. The position and velocity of the 
-thi particle  are updated 
using  
 
() ()( )() ()( )12
1, , 1 , 2 , , , ,
1, , 1,l gg i g i g i g i g i g i g i
g i g i g icc ï· +
++= + âˆ’ + âˆ’
=+vv Îµ px Îµ px
x x v
 , (3) 
where 
ï· , 
1c and 
2c  are coefficients that can be constants or change with iteration, 
  denotes the 
Hadamard product, 
()1
,giÎµ  and 
()2
,giÎµ  are two 
1Dï‚´  random vectors of numbers distributed between 0 
and 1, and  
 
()()()() ,, ,1 ,1 1arg min , arg minl gl i l i gii N l g l gff
ï‚£ ï‚£ ï‚£ ï‚£ ï‚£ ï‚£==p x p x . (4) 
2.2 Comprehensive Learning Particle Swarm Optimizer  
CLPSO is a variant of PSO  that uses a new learning strategy to update the particleâ€™s velocity 
[12]. The position and velocity in  CLPSO  are updated using  
 
( ) 1, , , , , 1, , 1, , g i g i g i g ij g i g i g i g i c ï· + + += + âˆ’ = + vv Îµ p x x x v
 , (5) 
where 
ï·  and 
c  are coefficients that can change with the iterations. 
,giÎµ  is a 
1Dï‚´  random 
vector of numbers distributed between 0 and 1. The 
,g ijp  is determined as follows: for each 
particle 
i , randomly select two other particles from the whole population, compare the fitness of 
the two particles and choose the better one 
,gjji ï‚¹pï¼Œ  as the candidate particle . CLPSO [12] This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 determines whether to learn the information of other particles by comparing the random number 
and the given probability 
,ciP . 
A random number 
ï¥  is ge nerated for each dimension and compared with its 
,ciP . If 
ï¥  
smaller than 
,ciP  value, the 
-thi  particle is guided by other particleâ€™s position 
,gjp . If 
ï¥ is larger 
than 
,ciP , the particle will follow its own 
,gip  for that dimension. Therefore, the 
,g ijp  is a new 
position where each dimension learns from several particlesâ€™ positions.  
We can see from the probability 
,ciP  in [12] that the random numbers are greater than 
,ciP  in 
most cases. That is, in the updated information of each particle, only a tiny part of the dimensional 
information comes from other particlesâ€™ historical best. I nteresting ly, although the particle in 
CLPSO updates its position with only a small amount  of information from other particles, the 
search capabilit y is significantly improved.  
2.3 Niderreiter  Theorem  
Let 
()hÎ¸  be a function with the argument 
EïƒÎ¸ ; the modulus of continuity of 
()hÎ¸  is 
defined by  
 
 
()
( )()()
12
1212
,
,sup h
E
dhh
ï¥ï·ï¥
ïƒ
ï‚£=âˆ’
Î¸Î¸
Î¸Î¸Î¸Î¸ ï¼Œ (6) 
where sup is the abbreviation of supremum, which represents the minimum upper bound in 
mathematics . 
For a sample set  
ï› ï 12, , , N =PÎ¸Î¸Î¸
  with 
iEïƒÎ¸  and 
1iNï‚£ï‚£ , the dispersion of 
P  is 
defined by  
 
() ( )
1sup min , NnnNEdd
ï‚£ï‚£ïƒ=
Î¸P Î¸Î¸  (7) 
where 
(),dïƒ—ïƒ—  denotes the euclidean  distance. The dispersion is a metric used to measure the 
uniformity of the sample set . The smaller the dispersion is, the better the uniformity. According to 
Niderreiterâ€™s theorem in [47], we have  
 
() ( ) ()( ) () ( )
10 min min i h Ni N Eh h d ï·
ï‚£ ï‚£ ïƒï‚£ âˆ’ ï‚£
Î¸Î¸ Î¸ P  (8) 
where 
() ( )
1min iiNh
ï‚£ï‚£Î¸  is the approximate value of best solution in space  
E, which corresponds 
to the fitness of the best solution in the field of evolutionary algorithm.  
()( ) min
Eh
ïƒÎ¸Î¸  corresponds to 
the true optimal solution. Therefore,
() ( ) ()( )
1min min ii N Ehh
ï‚£ ï‚£ ïƒâˆ’
Î¸Î¸ Î¸  represents the relative error between 
the fitness of the best solution and the true optimal solution. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 3. Effect of population initializers  on HCLPSO  
In order to explore the relationship between the error of the entire iteration process of PSO 
and the sample uniformity, this section presents the error analysis on PSO. The error of the result 
obtained by using PSO is defined by  
 
(),1min g g iiNfM
ï‚£ï‚£ï„ = âˆ’ x ï¼Œ (9) 
where 
M  denotes the exact global optimal fitness value, and 
(),1min giiNf
ï‚£ï‚£x  denotes the optima 
of all the particle fitness values at the 
-thg  iteration. In the error analysis, we assume that PSO 
can converge to 
M  with iteration.  
3.1 Error at the  initialize iteration  
Suppose the position and velocity of the 
-thi  particle at the first iteration are  
 
( ) ( ) 0, 1, 0, min 2, max min , i i i i= + âˆ’ = + âˆ’xa Îµ b a v v Îµ vv
 , (10) 
where  
 
( ) ( )
( )
( )TT
1 2 1 2
T
max max,1 max,2 max,
T
min min,1 min,2 min,, , , , , , ,
, , ,
, , ,DD
D
Da a a b b b
v v v
v v v==
=
=ab
v
v
 ï¼Œ (11) 
max, iv
 and 
min,iv  are the maximum and minimum velocities, respectively, and 
1,iÎµ  and 
2,iÎµ  are 
two random vectors in 
ï›ï : 0,1DE= .  
Considering  (10), 
() ( ) ( ) 0, 1,ii ff = + âˆ’xa Îµ ba
 , which means  the fitness value 
()0,i fx  is 
actually a function of 
1,iÎµ , denoted by 
() ( ) ( ) 0 1, 1, :ii hf = + âˆ’Îµ aÎµ ba
 . The 
1,iÎµ  of all the particles 
form a sample set  
ï› ï 0 1,1 1,2 1, , , , N =PÎµÎµÎµ
 . According to Niderreiterâ€™s theorem (8), the error at the 
first ite ration satisfies  
 
() () () ( )0
10 1, 0 01min min i h Ni N Eh h d ï·
ï‚£ ï‚£ ïƒâˆ’ï‚£
ÎµÎµ Îµ P ï¼Œ (12) 
 
() ( ) 0 1,1sup min , NnnNEdd
ï¥ï‚£ï‚£ïƒ=P ÎµÎµ ï¼Œ (13) 
where 
()0 NdP  is the dispersion of 
0P . As 
()
10 min
EhM
ïƒ=
ÎµÎµ , we have This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
  
() () () ( )0
10 0 1, 0 01min min i h Ni N Eh h d ï·
ï‚£ ï‚£ ïƒï„ = âˆ’ ï‚£
ÎµÎµ Îµ P  (14) 
Obviously, the better the uniformity of 
0P , the smaller the dispersion and the smaller the 
error. According to  (14), if a more uniformly distributed sample set  is used to generate the initial 
population, the error at the initialize iteration will be smaller.  
3.2 Error at the  first iteration  
According to  (3), we have 
 
( ) ï› ï
() ()( ) ( ) ï› ï1, min 2, max min
2 02 1,0,
1, 0, 1,ii
i i
i i icï·= + âˆ’ïƒ¬
ïƒ¯+ âˆ’ + âˆ’ïƒ­
ïƒ¯=+ïƒ®vv Îµvv
Îµ pa Îµba
x x v
 . (15) 
As shown in  (15), for all the particles, the parameters 
()0min max 1 2 , , , , , , , ccï· a b v v p  are the 
same, and the random vectors 
1,iÎµ , 
2,iÎµ  and 
()1
1,iÎµ  are different. For convenience of discussion, let 
()01 min max 1 2: { ; ; ; ; ; ; ; } ccï· =Î» a b v v p
, and 
() ()( )12
1, 2, 0, : ; ; ii i i =Î¸ÎµÎµÎµ . Therefore, the fitness value 
()1,i fx  
can be treated as a function of the random argument 
()1
iÎ¸ , denoted b y 
()()1
1 ihÎ¸ . For each particle 
i , 
there is a random argument 
()1
iÎ¸ , and all these random arguments form a sample set  
() () () 1 1 1
1 12: [ , , , ]N =PÎ¸Î¸Î¸
. Similarly, using Niderreiterâ€™s theorem yields the following error bound  
 
() ( ) ()
ï›ï()( ) 1
31
1 1 110, 1, sup min ,
Dh N N iiNd d dï·
ï‚£ï‚£ïƒï„ ï‚£ =
Î¸PP Î¸Î¸  (16) 
where 
()1 NdP  denotes the dispersion of 
1P . (16) gives the error bound at the second iteration. 
The better the uniformity of 
1P  is, the smaller 
()1 NdP  and the smaller the error. 
1P  contains three 
groups of sequences, in which 
ï»ï½1,iÎµ  and 
ï»ï½2,iÎµ  are the samples for the positions and velocities of 
the initial population, and  
()ï»ï½2
0,iÎµ  is required in the velocity updating at the second iteration. In 
previous studies, the initial population was  often  generated by using LDS, and hence , 
ï»ï½1,iÎµ  and 
ï»ï½2,iÎµ
 are of low -discrepancy, while 
()ï»ï½2
0,iÎµ  was still generated randomly, which reduces the 
uniformity of 
1P . If 
ï»ï½1,iÎµ , 
ï»ï½2,iÎµ  and 
()ï»ï½2
0,iÎµ  are all  generated b y using LDS, the dispersion 
()1 NdP  
and the error can be reduced. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 3.3 Error at the  g-th iteration  
According to  (3), we have  
 
() ()( )() ()( )12 12, 1, 1 1, 2 1, 1, 1, 1,
2, 1, 2,l
i i i i i i i
i i icc ï· ïƒ¬ = + âˆ’ + âˆ’ ïƒ¯ïƒ­=+ ïƒ¯ïƒ®vv Îµ px Îµ px
x x v
 , (17) 
which shows that the particle position 
2,ix  depends on 
ï· , 
1c, 
2c, 
()
1,l
ip , 
()1p , 
()1
1,iÎµ , 
()2
1,iÎµ , 
1,ix  and 
1,iv
. According to the updating formula  (15), 
()
1,l
ip , 
1,ix  and 
1,iv  depend on 
a , 
b, 
minv , 
maxv , 
ï·, 
1c
, 
2c, 
()0p , 
1,iÎµ, 
2,iÎµ  and 
()ï»ï½2
0,iÎµ . For all particles, 
a , 
b, 
minv , 
maxv , 
ï·, 
1c, 
2c, 
()0p , and 
()1p  are 
the same, and 
1,iÎµ , 
2,iÎµ , 
()ï»ï½2
0,iÎµ , 
()1
1,iÎµ  and 
()2
1,iÎµ  are different. Let 
() ()ï» ï½012 min max 1 2: ; ; ; ; ; ; ; ; ccï· =Î» a b v v p p
, and 
() ()()()( )2 2 1 2
1, 2, 0, 1, 1, : ; ; ; ; ii i i i i =Î¸ÎµÎµÎµÎµÎµ . Therefore the fitness 
value 
()2,i fx  is a function of the argument 
()2
iÎ¸ , denoted by 
()()2
2 ihÎ¸ . Similarly, using 
Niderreiter â€™s theorem yields the error bound at the third iteration  
 
() ( )2 22 hNdï· ï„ï‚£ P , (18) 
() () () 2 2 2
2 12, , ,N ïƒ©ïƒ¹=ïƒ«ïƒ»PÎ¸Î¸Î¸
 and 
()
ï›ï()( )
52
210, 1sup min ,
DN iiNdd
ï‚£ï‚£ïƒ=
Î¸P Î¸Î¸  is the dispersion of 
2P . The smaller 
()2 NdP
 is, the smaller 
2ï„  is. Using the same analysis process, the error bound at the 
-thg  
iteration can be expressed as  
 
() ( )
()
ï›ï( )()( )
21 10, 1sup min ,g
gDg h N g
g
Ng iiNd
ddï·
+ ï‚£ï‚£ïƒï„ï‚£
=
Î¸P
P Î¸Î¸ , (19) 
where 
 
() () ()
() ()()()()() () ()( )12
2 1 2 1 2 1 2
1, 2, 0, 1, 1, 2, 2, 1, 1,, , ,
; ; ; ; ; ; ; ; ;g g g
g N
g
ii i i i i i i g i g i âˆ’âˆ’ïƒ©ïƒ¹=ïƒ«ïƒ»
=PÎ¸Î¸Î¸
Î¸ÎµÎµÎµÎµÎµÎµÎµÎµÎµ
 . (20) 
(19) shows that the error bound 
gï„  depends on the dispersion of 
gP , which is a sample set in 
the 
( ) 21gD+ -dimensional space. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 4. PSO With Low -discrepancy S ampling  in the Expanded 
Dimensional Space  
In this s ection, a new acceleration technique, LDS in the expanded dimensional space 
(LDSEDS) is given. According to the different sample construction methods, two versions of 
LDSEDS are proposed. These two techniques are combined with PSO to generate two more 
effective algorithms.  
4.1 Inspiration from Error Analysis  
In the introduction, we raised two questions . The first being, why canâ€™t the advantages of 
using LDS initialization at the early iterations be preserved during the entire iteration s of the PSO? 
Furthermore, what is the relationship between the error of the entire iteration process of PSO and 
the samp le uniformity?  The error analysis in Section  3 explains the second question.  As shown in  
(19), the error bound of PSO at each iteration is dependent on the dispersion of the sample set 
gP . 
The answer to the first question is also revealed ; in the iterative process of PSO, it is necessary to 
sample dynamically in the space with increasing dimensions . Generating the initial populati on 
with LDS only ensures that the sample sets 
ï»ï½1,iÎµ  and 
ï»ï½2,iÎµ  in the first two dimension s of 
gP  are 
of low-discrepancy but ignore  the other dimensions. With  the increase in iterations, 
gP  contains an 
increasing number of  random numbers, becom ing a random sample set, and the advantages 
introduced by the low -discrepancy of 
ï»ï½1,iÎµ  and 
ï»ï½2,iÎµ  are completely destroye d.  
At the same time,  the error analysis in Section 3 also explain s why the effect of using LDS  in 
each iteration step is  worse . This is because the existing LDSs  are mostly deterministic point sets, 
so the uniformity of the whole iteration process is destroyed , so the calculation error of the 
algorithm increases,  resulting in  the worse calculation results .  
PSO requires  the sample set 
gP  in 
( ) 21gD+ -dimensional space . Suppose we use LDS 
instead of random samples to generate 
gP . In that case,  the dispersion of 
gP  will be reduced, the 
error of PSO at each iteration will be reduced and the convergence speed will be improved. This is 
the critical technique of the accelerated PSO proposed in this paper, which we name low -
discrepancy sampling  in the expanded dimensional space (LDSEDS). The PSO acceleration This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 algorithm combined with this technique is called PSO with LDS in the expan ded dimensional 
space (P SO-LDSEDS ). 
4.2 Low-discrepancy Sampling in Expanded Dimensional Space  
Based on Number Theory  
The LDSEDS based on number theory directly generates the low -discrepancy sample set  
GP 
in the ultrahigh dimension . The dimension of 
GP  is so high that some LDSs  based on optimization 
algorithm s, e.g., DE S and OH S, are unsuitable because of the enormous  computational cost 
required to generate the samples. Some LDSs based on number theory stand out in this case , such 
as HWS , SS and H SS. For such high -dimensional space, we used HS S, a modified version of the 
famous H S. By adding some perturbation to the or iginal H S, HSS alleviat es the strip distribution  
of the sample set  form which H S, as well as HW S and S S, suffers.  
Then, this technique  is combined  with PSO. If the maximum number of iterations is 
G , the 
iteration requires  
N samples 
() ()
1 : , ,GG
G N ïƒ©ïƒ¹=ïƒ«ïƒ»
PÎ¸Î¸  in 
( ) 21GD+ dimensional space. The first 
2D  
dimensional numbers in 
GP  are used for the generation of the initial positions  and velocities. The 
numbers in dimensions 
2g  and 
21g+  are used to generate 
()1
gÎµ  and 
()2
gÎµ , respectively. This 
improved PSO algorithm is called  PSO-LDSEDS  based on number theory ( PSO-LDSEDS 1). 
4.3 Low-discrepancy Sampling  in Expanded Dimensional Space  
Based on  a Combination of Low-dimensional Samples  
Generally, the difference between the low -discrepancy sample set  generated by number 
theory and that of a random sample set increase s with the number of samples  but decreases with 
the dimension.  Considering that the dimension of the sample set 
GP  involved in PSO is so high 
that directly generating it with number theory method may not decrease its discrepancy when the 
number of particles is not too large. Therefore, we propose another LDSEDS based on a 
combination of low -dimensional samples.  
Suppo sing we have obtained a low -discrepancy sample set 
Î˜  with 
N  samples in 
-D This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 dimensional  space,  
 
11 12 1 1,:
21 22 2 2,:
1 2 ,:N
N
D D DN Dï± ï± ï±
ï± ï± ï±
ï± ï± ï±ïƒ© ïƒ¹ ïƒ© ïƒ¹
ïƒª ïƒº ïƒª ïƒº
ïƒª ïƒº ïƒª ïƒº==ïƒª ïƒº ïƒª ïƒº
ïƒª ïƒº ïƒª ïƒºïƒ« ïƒ» ïƒ« ïƒ»Î¸
Î¸Î˜
Î¸
 , (21) 
and now we want to generate 
N  samples in 
2-D dimensional  space. For the number array 
ï› ï 1, 2, , D
, we make a random permutation , denoted by 
ï› ï 12, , , D ï° ï° ï°=Ï€
 . Using 
Ï€  can yield 
a new low-discrepancy sample set  
ï°Î˜ 
 
1 1 1 1
2 2 2 21 2 ,:
1 2 ,:
1 2 ,:D D D DN
N
Nï° ï° ï° ï°
ï° ï° ï° ï°
ï°
ï° ï° ï° ï°ï± ï± ï±
ï± ï± ï±
ï± ï± ï±ïƒ© ïƒ¹ ïƒ© ïƒ¹
ïƒª ïƒº ïƒª ïƒº
ïƒª ïƒº ïƒª ïƒº==ïƒª ïƒº ïƒª ïƒº
ïƒª ïƒº ïƒª ïƒºïƒ« ïƒ» ïƒ« ïƒ»Î¸
Î¸Î˜
Î¸
 . (22) 
Clearly, 
ï› ï;Ï€Î˜Î˜  forms a new low-discrepancy sample set  with 
N  samples in 
2D -
dimensional  space.  Then, we apply this technique to PSO.  Using this combining method can 
easily yield 
GP  in 
( ) 22GD+ï‚´ -dimensional  space,  
 
ï› ï1 2 2; ; ;G G + = Ï€ Ï€ PÎ˜Î˜Î˜
 , (23) 
where 
iÏ€  represents the random permutation. By combining the low -dimensional samples 
generated using different LDSs  (such as HW S, DES, HSS and S S) in a random permutation al way, 
it is quite convenient  to generate the samples in the dynamically expanded dimensional  space. 
This more efficient PSO algorithm is called  PSO-LDSEDS , and is based on a c ombination of low -
dimensional samples  (PSO-LDSEDS 2). 
5. Numerical Test of PSO -LDSEDS  
This section uses numerical experiments to verify the correctness of the  error  analysis  in 
Section 3 and the effectiveness of the two improved algorithms proposed in Section 4. 
5.1 Measurement of Performance  
In this section, the PSO s with two  different  samplings are considered as two different 
algorithms. To compare the performanc e of the different algorithms, we used the following 
metrics:  
Error tolerance (
tolï¥ ): When the relative error between the fitness of the best solution and the This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 true optimal solution is smaller than 
tolï¥ , the algorithm is considered convergent.  
Convergence speed  (CS) : This metric indicates  the number of  iterat ions after which  the 
algorithm converges. For  the two algorithms, the smaller CS  is, the more powerful  the search 
ability of the algorithm. Due to the randomness existing in PSO, 60 runs are performed for each 
test function and for each algorithm. The average convergence curve of 60 runs is recorded, and 
the CS for a given  error tolerance  is evaluated based on the average convergence curve. If the CS 
is greater than the maximum number of iteration s 
G, it is c laimed that the algorithm fails to find 
the global optimum under the given error tolerance , and it is represented by "" -"" in the table.  
5.2 Test Functions  
In this section, 15 benchmark functions selected from the 30 wi dely used benchmark 
functions provided by the CEC 2017 special session [48] are used as the test functions. The name, 
topology, and tr ue optimal solutions  (
*Z) of these 15 test functions are listed  in Table I. For the 
other 15 functions the original PSO cannot converge within 
7500G=  iterations,  and they are 
discarded . 
TABLE I  
BENCHMARK FUNCTIONS  
Topology  No. Function name  
*Z  
Unimodal Fns.  
1F  Shifted and rotated Zakharov function  300 
Simple 
multimodal  
Fns. 
2F Shifted and rotated Rosenbrockâ€™s function  400 
3F
 Shifted and rotated Rastriginâ€™s function  500 
4F
 Shifted and rotated Expaned Schaffer F6 function  600 
5F
 Shifted and rotated Lunacek Bi -Ratriginâ€™s function  700 
6F
 Shifted and rotated Non-continuous Rastriginâ€™s function  800 
7F
 Shifted and rotated Lvey function  900 
Hybrid Fns.  
8F  Zakharov, Rosenbrock, Rastrigin  1100  
9F
 High -conditioned elliptic; Ackley; Schaffer; Rastrigin  1400  
10F
 Bent Cigar; HGBat; Rastrigin; Rosenbrock  1500  
11F
 Expanded schaffer; HGBat; Rosenbrock; Modified Schwefel; Rastrigin  1600  
12F
 Katsuura; Ackely; Expanded Griewank plus Rosenbrock; Schwefel; Rastrigin  1700  
13F
 High -conditioned elliptic; Ackley; Rastrigin; HGBat; Dicus  1900  
 
14F  Bent Cigar; Griewank plus Rosenbrock; Rastrigin; Expanded Schaffer  2000  
Composite F ns. 
15F  Griewank; Rastrigin; Modified schwefel  2200  
Fns. Functions This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 5.3 Statistical Analysis  
The modified Friedman test  (MFT) [49] and the Nemenyi test  (NT) [50] were used here to 
compare the performance of  the different algorithms. The MFT justifies whether  there are 
significant differences between the considered algorithms in terms of the Friedman statictics 
Fï´  
 
( )
( ) ( )( )22
22
211 12,1 1 4F
F i F
i Fm k k mRm k k kï£ï´ï£ï£ïƒ©ïƒ¹ âˆ’+= = âˆ’ ïƒªïƒºâˆ’ âˆ’ +ïƒ«ïƒ»ïƒ¥ , (24) 
where 
m  is the number of test functions, 
k  is the number of algorithms considered, and 
iR  is the 
average rank of the 
-thi  algorithm. T he smaller 
iR  is, the better the performance of the 
-thi
algorithm.  If 
Fï´  is greater than the critical value 
cï´  for a given s ignificance  level 
ï¡ , it is claimed 
that there are significant differences between the considered algorithms. If signific ant differences 
are observed, the NT is used to justify which algorithm is signifi cantly superior to  the other 
algorithms. This test states that the performance of  the two algorithms is significantly different if 
the corresponding average ranks differ by at least a critical difference , defined as follows : 
 
( )1
6kkCD qmï¡+= , (25) 
where 
qï¡  can be obta ined by querying the studentized range statistic  table [50] with the 
significance  level 
ï¡ . In all the experiments, the confidence level is set to 
0.05ï¡= . 
5.4 Performance of PSO -LDSEDS1  
In this section, a comparison between PSO and PSO -LDSEDS1 is presented using the test 
functions with 
10D= . The parameters involved are the same for both algorithms except for the 
sample sets.  The maximum number of iterations is 
7500G= . 
w decreases linearly with iteration s 
in the range of 0.9 -0.4. 
1c  and 
2c  vary linearly with iteration s in the range of 2.5 -0.5 and 0.5 -2.5, 
respectively. To compare the CSs of differ ent algorithms at different  error tolerances, 
tol1% ï¥=  
and 
5%  are used.  
PSO-LDSEDS1 directly us es the HS S method to generate 
GP  with dimensions  of 
( ) 22GD+ . 
Obviously,  
GP is an ultrahigh dimensional LDS, so it may need a large number of samples to 
match the dimensions to achieve the ideal uniformity effect . Here, three groups of c omparative 
experiment s with 
40N= , 100 , and 160, are given to compare the CSs of the original PSO This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 (denoted by Rand) and PSO -LDSEDS1 (denoted by HS S) at 
tol1% ï¥=  and 
5% . The CSs  and 
ranks of Rand and HS S with different population sizes  at different tolerance errors and population 
sizes are listed in Table II. 
As shown in Table II, the A vgRks  of PSO-LDSEDS1 are smaller than th ose of PSO in almost 
all simulation conditions, ex cept 
40N=  and 
tol5% ï¥= . For both 
tol1% ï¥=  and 
5% , the Friedman  
statistics 
Fï´  increase as 
N  increase s. This is because the LDS  covers the search  space better than 
the random sample set,  and the advantage becomes more evident as the population  size increases.  
When  
160N= , the Friedman  statistics  at 
tol1% ï¥=  and 
5%  are both far greater than the critical 
value 
c4.600 ï´= . Therefore, it can be stated that when 
160N= , PSO -LDSEDS1 converge s 
significantly faster than PSO at the significance  level 
0.05ï¡= . 
The experimental result shows that , although directly generating the low -discrepancy sample 
GP
 can improve the numerical performance of PSO, the po pulation size required need s to be large 
enough, which increases the computational cost. Next, we test the performance of PSO -LDSEDS2.  
TABLE II 
CSS AND  RANKS OF DIFFERENT ALGORITHMS WITH DIFFERENT POPULATION SIZES  AT 
DIFFERENT TOLERANCE ERRORS  
 
tol5% ï¥=  
tol1% ï¥=  
40N=
 
100N=  
160N=  
40N=  
100N=  
160N=  
Rand HSS Rand HSS Rand HSS Rand HSS Rand HSS Rand HSS 
1F
 1515 (2) 1281 (1) 1385(2)  1223(1)  1336(2)  1201(1)  1626 (2) 1388 (1) 1492(2)  1314(1)  1436(2)  1289(1)  
2F
 189(1) 353(2) 82(1)  117(2)  52(2)  42(1)  2006 (2) 1611 (1) 1799(2)  1563(1)  1688(2)  1406(1)  
3F
 948(2) 747(1) 835(2)  811(1)  745(1)  770(2)  -(1.5)  -(1.5)  2765(1)  4674(2)  2252(1)  2306(2)  
4F
 24(2) 17(1) 16(2)  15(1)  15(2)  13(1)  474(1) 479(2) 314(1)  346(2)  254(2)  233(1)  
5F
 1420 (2) 1098 (1) 1299(2)  1072(1)  1244(2)  1048(1)  -(1.5)  -(1.5)  -(1.5)  -(1.5)  -(1.5)  -(1.5)  
6F
 582(2) 494(1) 327(1)  454(2)  325(2)  287(1)  2472 (1) -(2) 1928(1)  2008(2)  1716(2)  1683(1)  
7F
 562(2) 511(1) 418(2)  415(1)  281(2)  272(1)  908(2) 729(1) 803(2)  704(1)  675(2)  633(1)  
8F
 350(1) 398(2) 228(2)  208(1)  172(2)  160(1)  1061 (2) 905(1) 914(2)  821(1)  860(2)  809(1)  
9F
 1054 (1) 1121 (2) 753(2)  739(1)  705(2)  632(1)  -(1.5)  -(1.5)  5713(1)  -(2) 2715(2)  2651(1)  
10F
 1995 (1) 2070 (2) 1394(2)  1283(1)  1305(2)  1205(1)  3767 (1) -(2) 2588(2)  2559(1)  2310(2)  2128(1)  
11F
 452(1) 460(2) 233(1)  261(2)  191(2)  169(1)  906(2) 843(1) 601(1)  683(2)  601(2)  563(1)  
12F
 392(2) 328(1) 162(1)  208(2)  137(2)  134(1)  1730 (2) 1720 (1) 1360(2)  1286(1)  1261(2)  1243(1)  
13F
 1656 (1) -(2) 1019(2)  888(1)  793(2)  774(1)  3230 (1) -(2) 1726(2)  1703(1)  1552(2)  1526(1)  
14F
 165(2) 147(1) 83(1)  90(2)  65(2)  64(1)  1200 (2) 1140 (1) 1116(2)  972(1)  956(2)  893(1)  
15F
 814(2) 723(1) 396(1)  458(2)  200(2)  22(1)  -(1.5)  -(1.5)  -(1.5)  -(1.5)  -(2) 736(1)  
AvgR.  1.60(2) 1.40(1) 1.60(2) 1.40(1) 1.93(2) 1.07(1) 1.60(2) 1.40(1) 1.60(2) 1.40(1) 1.90(2) 1.10(1) 
Fï´
 0.583  0.583  42.250  0.583 0.583  24.889  
AvgR.  Average ranks This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 5.5 Performance  of PSO -LDSEDS 2 
The comparison between PSO and PSO -LDSEDS2 using the 
10D=  dimensional test 
functions is  presented  first. The adopted parameters are the same as those used previously , except 
for the sample sets  
40N= . PSO -LDSEDS2 uses the combining method introduced in Section 4 
to generate 
GP . As shown b y (23), the seed sample set 
Î˜  was generated using four LDSs , i.e., 
HWS, DES, HSS, and S S. For convenience, PSO -LDSEDS2 , which uses certain type s of LDSs  to 
generate the seed sample set , is denoted by the name of the corresponding LDS . As the original 
PSO generates 
GP  by random sampling, it is denoted by Rand. The CSs , the computation times  
(CTs) and their ranks of Rand, HW S, DES, HSS, and S S at different tolerance errors are listed in 
Table III and Table IV.  
The comparison in Table III and Table IV shows that under the same accuracy requirements, 
the number of iterations  and the CTs required by PSO -LDSEDS2 is significantly less than that 
required by PSO. According to Table III and Table IV, for both 
tol5% ï¥=  and 1%, 
Fï´  is greater 
than the critical value 
c2.537 ï´=  in the significance level 
0.05ï¡= . According to NT and  (25), the 
critical difference  
1.575 CD= . Therefore, the A vgRks  of PSO -LDSEDS2 with different LDS s are 
always significantl y smaller than those  of PSO at both 
tol5% ï¥=  and 1%.  
Next, the performance of PSO -LDSEDS2 is evaluated using the 
30D=  dimensional test 
functions. When  
30D= , there are many test functions in Table I for which both PSO and PSO -
LDSEDS2 fail to find solutions with relative errors smaller than 
tol5% ï¥= . Therefore, 
tol20% ï¥=  
and 
tol10% ï¥=  were used. In addition, there are still five test functions for which the adopted 
algorithms fail at 
tol20% ï¥= , and we adopted only the re maining  ten test functions. The 
population size is 
100N= . The o ther parameters are the same as those used previously . The CSs , 
the CTs  and the ir ranks of  the considered algorithms at different tolerance errors are listed in Table 
V and Table  â…¥. 
The comparison in Table V and Table  â…¥ shows that for 30 -dimensional problem s, PSO-
LDSEDS2 still performs significantly better than PSO under the same error tolerance.  For both 
tol20% ï¥=
 and 10%, 
Fï´  are greater than the critical value 
c2.634 ï´=  in the significance level  
0.05ï¡=
. Therefore, there are significant differences between th e CSs and the CTs  of the five 
algorithms  considered.  The A vgRks  of HW S, DES, HS S and SS are all smaller than that of Rand. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 According to NT and  (25), 
1.929 CD= . Therefore, HW S, DES and HS S perform significantly 
better than Rand a t
tol20% ï¥= , and  HWS and DES perform significantly better than Rand at  
tol10% ï¥=
.Although the difference between the A vgRks  of Rand and S S is not greater than  
CD , 
SS actually performs better than Rand for almost all  the test functions . 
TABLE III 
CSS AND  RANKS OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol5% ï¥=  
tol1% ï¥=  
Rand HWS  DES HSS SS Rand HWS  DES  HSS SS 
1F
 1515 (5) 943(2) 977(4) 963(3) 916(1) 1626 (5) 1032 (2) 1064 (4) 1056 (3) 997(1) 
2F
 189(5) 62(1) 142(4) 94(3) 73(2) 2006 (5) 1532 (2) 1800 (3) 1813 (4) 1451 (1) 
3F
 948(5) 428(1) 496(3) 520(4) 488(2) -(5) 4202 (4) 3474 (3) 2347 (1) 3271 (2) 
4F
 24(5) 20(2) 21(3) 19(1) 22(4) 474(5) 128(1) 136(3) 149(4) 130(2) 
5F
 1420 (5) 856(2) 804(1) 870(3) 901(4) -(3) -(3) -(3) -(3) -(3) 
6F
 582(5) 192(2) 195(3) 179(1) 197(4) 2472 (5) 1717 (2) 1786 (4) 1702 (1) 1724 (3) 
7F
 562(5) 163(2) 178(4) 171(3) 152(1) 908(5) 381(3) 384(4) 376(2) 335(1) 
8F
 350(5) 169(3) 154(1.5)  154(1.5)  196(4) 1061 (5) 625(3) 610(1) 652(4) 612(2) 
9F
 1054 (5) 833(1) 874(2) 941(4) 899(3) -(3) -(3) -(3) -(3) -(3) 
10F
 1995 (4) 2068 (5) 1841 (3) 1766 (2) 1747 (1) 3767 (5) 3666 (2) 3633 (1) 3765 (4) 3668 (3) 
11F
 452(5) 308(3) 280(2) 345(4) 263(1) 906(5) 831(4) 672(2) 749(3) 624(1) 
12F
 392(5) 229(3) 251(4) 207(2) 168(1) 1730 (3) 2328 (4) 2947 (5) 1676 (1) 1702 (2) 
13F
 1656 (4) 1499 (1) 1646 (3) 1501 (2) 2115 (5) 3230 (4) 3185 (3) 3127 (2) 3030 (1) 4001 (5) 
14F
 165(5) 158(4) 121(2) 118(1) 124(3) 1200 (5) 976(3) 858(1) 914(2) 979(4) 
15F
 814(5) 193(3) 256(4) 131(1) 140(2) -(3) -(3) -(3) -(3) -(3) 
AvgR.  4.87(5) 2.33(1) 2.90(4) 2.37(2) 2.53(3) 4.40(5) 2.800 (3.5)  2.800 (3.5)  2.600 (2) 2.400 (1) 
Fï´
 11.728  4.817 
  
TABLE IV  
CTS AND  RANKS  OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol5% ï¥=  
tol1% ï¥=  
Rand HWS  DES HSS SS Rand HWS  DES  HSS SS 
1F
 0.101(5) 0.064(1) 0.070(3) 0.071 (4) 0.065(2) 0.109(5) 0.069(2) 0.071(3) 0.074 (4) 0.067(1) 
2F
 0.010 (4) 0.004(1) 0.014(5) 0.006(3) 0.004 (2) 0.097(5) 0.069(1) 0.086(3) 0.091 (4) 0.074(2) 
3F
 0.064(5) 0.033(1) 0.034 (3) 0.038 (4) 0.033 (2) 0.321 (5) 0.229(1) 0.256(3) 0.247 (2) 0.284(4) 
4F
 0.004 (5) 0.003 (1) 0.004 (4) 0.003 (2) 0.004(3) 0.060 (5) 0.017 (2) 0.019(4) 0.019(3) 0.017 (1) 
5F
 0.101 (5) 0.054 (1) 0.061(3) 0.067(4) 0.056(2) 0.592 (5) 0.570(2) 0.543(1) 0.591(4) 0.586(3) 
6F
 0.041(5) 0.016(4) 0.016(3) 0.015 (2) 0.012 (1) 0.234 (5) 0.157(2) 0.152(1) 0.162(3) 0.173 (4) 
7F
 0.041(5) 0.010 (1) 0.011(2) 0.015(4) 0.011 (3) 0.065 (5) 0.025 (2) 0.026(3) 0.029(4) 0.024 (1) 
8F
 0.022(5) 0.010(2) 0.009 (1) 0.011(3) 0.012(4) 0.068(5) 0.034(1) 0.040(2) 0.054 (4) 0.044 (3) 
9F
 0.076 (5) 0.064(2) 0.059(1) 0.074 (4) 0.066 (3) 0.443 (5) 0.403 (1) 0.426(3) 0.428 (4) 0.404(2) 
10F
 0.148(4) 0.137(2) 0.152(5) 0.136(1) 0.145(3) 0.255(5) 0.214 (1) 0.229(2) 0.239 (4) 0.230 (3) 
11F
 0.030(4) 0.023 (3) 0.017 (1) 0.030 (5) 0.020 (2) 0.062 (5) 0.040(1) 0.042(2) 0.048 (4) 0.043(3) 
12F
 0.042 (5) 0.031 (3) 0.036(4) 0.024 (1) 0.030(2) 0.642 (4) 0.654 (5) 0.521 (3) 0.442(1) 0.446 (2) 
13F
 0.514(3) 0.368(1) 0.535 (4) 0.489(2) 0.630 (5) 1.208 (3) 1.114(1) 1.215(4) 1.127(2) 1.281(5) This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 
14F 0.024 (5) 0.022 (4) 0.015 (2) 0.017 (3) 0.015 (1) 0.319(5) 0.259 (2) 0.206 (1) 0.261 (3) 0.317(4) 
15F
 0.125(5) 0.044 (3) 0.051(4) 0.042(2) 0.039 (1) 1.293 (4) 1.311 (5) 1.276(3) 1.212 (1) 1.232(2) 
AvgR.  4.667(5) 2.000 (1) 3.000 (4) 2.933 (3) 2.400 (2) 4.733 (5) 1.933 (1) 2.533 (2) 3.133 (4) 2.667(3) 
Fï´
 9.900  11.430  
TABLE V 
CSS AND RANKS OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol20% ï¥= 
tol10% ï¥=  
Rand HWS  DES  HSS SS Rand HWS  DES  HSS SS 
1F
 3702(5)  3491(3)  3456(1)  3487(2)  3545(4)  3787(5)  3595(3)  3571(1)  3572(2)  3644(4)  
3F
 1843(5)  1498(3)  1455(1)  1497(2)  1519(4)  2803(5)  2011(2)  2228(4)  2048(3)  1949(1)  
4F
 2(3) 2(3) 2(3) 2(3) 2(3) 21(5)  20(3.5)  19(1.5)  19(1.5)  20(3.5)  
5F
 1985(5)  1581(1)  1598(3)  1596(2)  1704(4)  -(3) -(3) -(3) -(3) -(3) 
6F
 1665(5)  1122(2)  1195(4)  1120(1)  1139(3)  2016(5)  1580(2)  1606(3)  1538(1)  1647(4)  
7F
 1691(5)  1371(4)  1357(3)  1289(1)  1356(2)  2020(5)  1744(2)  1852(3)  1725(1)  1963(4)  
8F
 1409(5)  1105(3)  1066(1)  1122(4)  1079(2)  2001(2)  1963(1)  2595(3)  2602(4)  2703(5)  
12F
 1168(5)  970(2)  956(1)  988(3)  1033(4)  2962(5)  2275(3)  2000(2)  1856(1)  2633(4)  
14F
 1038(5)  732(1)  770(2)  1032(4)  857(3)  1761(4)  1443(2)  1394(1)  3224(5)  1636(3)  
15F
 823(5)  324(2)  188(1)  387(4)  375(3)  1402(5)  531(2)  310(1)  940(4)  553(3)  
AvgR.  4.800(5) 2.400(2) 2.000(1) 2.600(3) 3.200(4) 4.400(5) 2.350(2) 2.250(1) 2.550(4) 3.450(3) 
Fï´
 8.308  4.534 
 
TABLE â…¥ 
CTS AND  RANKS  OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol20% ï¥= 
tol10% ï¥=  
Rand HWS  DES  HSS SS Rand HWS  DES  HSS SS 
1F
 1.866(5) 1.492 (1) 1.559 (2) 1.566 (3) 1.570 (4) 1.744 (5) 1.423(1) 1.484 (3) 1.462(2) 1.487 (4) 
3F
 1.253 (5) 0.916 (2) 0.792(1) 0.939(3) 0.944(4) 3.095(5) 2.304(2) 2.081(1) 2.465(4) 2.375(3) 
4F
 0.007 (2) 0.007 (3) 0.007(1) 0.007 (4) 0.008(5) 0.028 (5) 0.023 (2) 0.022 (1) 0.025 (3) 0.026 (4) 
5F
 1.648 (5) 1.140 (1) 1.215(2) 1.222 (3) 1.340(4) 5.422(5) 5.055(2) 5.015 (1) 5.197(4) 5.078(3) 
6F
 1.171 (5) 0.806(3) 0.624(1) 0.831(4) 0.771 (2) 1.636(5) 1.321(3) 1.107 (1) 1.151(2) 1.355 (4) 
7F
 1.182(5) 0.873(2) 0.963(3) 0.968(4) 0.829 (1) 1.462(3) 1.254(1) 1.742 (5) 1.314 (2) 1.488(4) 
8F
 0.913 (5) 0.655(3) 0.576 (1) 0.761(4) 0.627(2) 1.785(2) 1.827 (3) 1.706(1) 2.367 (5) 2.127 (4) 
12F
 1.912(5) 1.338(2) 1.582 (3) 1.756 (4) 1.273 (1) 4.454 (5) 3.842 (1) 4.097(3) 3.907(2) 4.369 (4) 
14F
 1.397 (5) 0.998(1) 1.031(2) 1.352 (4) 1.169(3) 3.323 (1) 3.431(2) 3.448(3) 6.032(5) 3.774(4) 
15F
 1.952(5) 0.761(3) 0.217 (1) 0.834(4) 0.456(2) 1.928 (5) 0.773(2) 0.451 (1) 0.996(4) 0.838(3) 
AvgR.  4.700(5) 2.100(2) 1.700(1) 3.700(4) 2.800 (3) 4.100 (5) 1.900 (1) 2.000(2) 3.300 (3) 3.700 (4) 
Fï´
 13.059  6.000 
 
5. Disscussio ns 
From previous experiments, we can conclud e that generating 
GP  with LDS s improve s the 
convergence  speed of PSO. For PSO -LDSEDS1, when  
40N= , its performance is similar to that 
of PSO. This is because the population size is so small that the uniformity of the high -dimensional This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 sample set generated by directly using the LDS  is not better than that of the random sample sets. 
However, with an increase in the population size, PSO -LDSEDS1 performs increasingly  better. 
When  
160N= , the convergence speed of PSO -LDSEDS1 is significantly superior to that of PSO. 
The PSO-LDSEDS2  can substantially improve the convergence speed without reducing the search 
ability of the original PSO for the 10 - and 30 -dimensional problems. We adopted four sampling 
methods to generate the seed low -discrepancy sample set, and HW S and DES are more rob ust 
than the other  two samplings. Tables  III-â…¥ show  that the combin ed sampling technique  is more 
efficient than direct sampling based on  number theory, and both technique s are more efficient than  
random sampling.  
It is natural  to question whether  the LDSEDS technique  can be extended to other modified 
versions of PSO. In the next section, the LDSE DS was combined with a widely used modified 
PSO, i.e., CLPSO, and experiments and discussions were presented for testing the performance of 
CLPSO -LDSEDS.  
6. Extended to  CLPSO  
It seems that LDSEDS  can be extended to other PSO variants. According to the error analysis 
in Section 3, there is a  precondition that the  position updating of each particle depends on the 
random variables that are independent of the other particles and a global best that is the same for 
all the particles . Nevertheless, among the many variants of PSO, few algorithms can strictly meet 
these preconditions except for PSO , which  directly changes the control parameter.  For some  PSO 
variants that change the population topologies , each particle learn s a lot from  the adjacent particles , 
which undoubtedly does not meet the preconditions of the analysis in Section 3. However, there 
are some excellent PSO variants, such as CLPSO and HCLPSO, in which each particle updates its 
position with only a small amount of information from  the other particles  and mainly depend s on 
the information of the particle itself. These types of algorithms c ould be expected to accelerate the 
convergence speed by using the LDSE DS. In this section, we choose the classic CLPSO among 
these variants as the carrier for the next promotion.  
As shown in Section 5, the combining sampling based on random permutations of a low -
dimensional  low-discrepancy sample set is more efficient,  and it will be adopted for CLPSO. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 Unlike PSO, the velocity updating formula of CLPSO does not involve global optima. Therefore, 
in each iteration of CLPSO, it is only necessary  to sample the random vector 
,giÎµ  once.  Within 
G  
iterations, the dimension of the total sample set 
GP  is 
( )1GD+ï‚´ . For a seed low -discrepancy 
sample set 
Î˜ , combining its random permutations yields  
 
ï› ï12; ; ;G G + = Ï€ Ï€ PÎ˜Î˜Î˜
  (26) 
where 
iÏ€  represents the random permutation, as shown in Section 4. The modified CLPSO is 
denoted as CLPSO -LDSEDS.   
6.1 Test Functions  
The test functions were still provided by  the CEC 2017 special session  [48]. As the search 
capability of CLPSO is better than that of PSO, we can select 19 test functions, listed in Table V, 
for which CLPSO can find optimal solutions with relative errors smaller than 
tol5% ï¥= . The o ther 
11 test functions are dis carded. 
TABLE VII 
BENCHMARK FUNCTIONS  
Topology  No. Function name  
*Z  
Unimodal Fns.  
 
1F Shifted and rotated Zakharov function  300 
Simple 
multimodal 
Fns. 
2F Shifted and rotated Rosenbrockâ€™s function  400 
3F
 Shifted and rotated Rastriginâ€™s function  500 
4F
 Shifted and rotated Expaned Schaffer F6 function  600 
5F
 Shifted and rotated Lunacek Bi -Ratriginâ€™s function  700 
6F
 Shifted and rotated Non -continuous Rastriginâ€™s function  800 
7F
 Shifted and rotated Lvey function  900 
Hybrid Fns.  
8F  Zakharov, Rosenbrock, Rastrigin  1100  
9F
 Bent Cigar, Rosenbrock; Lunacek bi -Rastrigin  1300 
10F
 High -conditioned elliptic; Ackley; Schaffer; Rastrigin  1400  
11F
 Bent Cigar; HGBat; Rastrigin; Rosenbrock  1500  
12F
 Expanded schaffer; HGBat; Rosenbrock; Modified Schwefel; Rastrigin  1600  
13F
 Katsuura; Ackely; Expanded Griewank plus Rosenbrock; Schwefel; Rastrigin  1700  
14F
 High -conditioned elliptic; Ackley; Rastrigin; HGBat; Dicus  1900  
15F
 Bent Cigar; Griewank plus Rosenbrock; Rastrigin; Expanded Schaffer  2000  
Composite 
Fns. 
16F Katsuura; Ackley; Rastrigin; Schaffer; Modified Schwefel  2100  
17F
 Griewank; Rastrigin; Modified schwefel  2200  
18F
 Ackley; Griewank; Rastrigin; High -conditioned Elliptic  2400  
19F
 Modified Schwefel; Rastrigin; Rosenbrock; Griewank; Expanded schaffer  2600 This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 6.2 Parameters Setting  
The CLPSO code is downloaded from https://github.com/ zmdsn/ALFRAME . The inertia 
weight 
w  decreases linearly with iteration s in the range of 0.9 -0.2. The acceleration coefficient is  
1.49445c=
. The maximum number of iterations is 
7500G= . When 
10D= , 
40N= , and  
tol1% ï¥=
 and 
5%  were used . When 
30D= , 
100N= , and  
tol10% ï¥=  and 20% were used.  
6.3 Numerical Comparisons and Discussions  
A comparison between CLPSO and CLPSO -LDSEDS with 10 dimensional test functions is 
first presented. HW S, DES, HS S and S S were adopted  to generate 
Î˜ . The CS s, the CTs and the ir 
ranks  of the results obtained by using the original CLPSO (denoted by Rand) and the CLPSO with 
different LDSs . (denoted by the name of the sampling method) are listed in Table â…§ and Table  
â…¨. 
As shown in Table â…§ and Table  â…¨, 
Fï´ is greater than the critical value 
c2.537 ï´=  for both 
tol5% ï¥=
 and 
tol1% ï¥= , which means  that there are significant differences between the 
performances of all five algorithms considered. According to the NT,  
1.399 CD= , the AvgRks  of 
the CLPSO -LDSEDSs with HWS, DES , and S S are significantly smaller than th ose of CLPSO, 
which means that these three algorithms converge significantly faster than CLSPO at the same 
error tolerance. Th e AvgRk of CLPSO -LDSEDS with HSS is also smaller than that of the original 
CLPSO.   
TABLE  â…§ 
CSS AND  RANKS OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol5% ï¥=  
tol1% ï¥=  
Rand HWS  DES  HSS SS Rand HWS  DES  HSS SS 
1F
 2285 (5) 2243 (3) 2203 (2) 2272 (4) 2116 (1) 2603(5)  2602(4)  2527(2)  2589(3)  2405(1)  
2F
 437(5) 418(3) 409(2) 433(4) 385(1) 2850(5)  2755(2)  2774(4)  2770(3)  2275(1)  
3F
 972(5) 857(2) 876(3) 956(4) 785(1) 3732(3.5)  3761(5)  3566(1)  3732(3.5)  3655(2)  
4F
 127(5) 111(1.5) 120(3) 122(4) 111(1.5) 510(5)  442(3)  438(2)  509(4)  427(1)  
5F
 1568 (5) 1461 (3) 1409 (2) 1566 (4) 1252 (1) -(3) -(3) -(3) -(3) -(3) 
6F
 387(3) 385(2) 400(4) 462(5) 349(1) 2898(5)  2728(3)  2812(3)  2869(4)  2597(1)  
7F
 549(4) 527(3) 519(2) 561(5) 487(1) 846(4)  785(2)  764(2)  896(5)  729(1)  
8F
 468(5) 446(2) 455(4) 452(3) 411(1) 1180(5)  1149(3)  1110(2)  1167(4)  1086(1)  
9F
 6898 (5) 4419 (3) 5961 (4) 4376 (2) 4137 (1) -(3) -(3) -(3) -(3) -(3) 
10F
 2423 (4) 1925 (1) 2065 (2) 2215 (3) 2755 (5) -(4.5)  7499(2.5)  7499(2.5)  7196(1)  -(4.5) This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 
11F 2254 (5) 2042 (3) 1829 (1) 2162 (4) 2030 (2) 6976(5)  5874(3)  5076(1)  5597(2)  6703(4)  
12F
 601(5) 506(1) 591(3) 597(4) 524(2) 1128(5)  1024(1)  1118(4)  1097(3)  1078(2)  
13F
 315(4) 306(3) 268(1) 344(5) 274(2) 2416(5)  2373(3)  2324(2)  2401(4)  2307(1)  
14F
 1246 (5) 864(1) 950(2) 1221 (4) 1023 (3) 3294(5)  2494(1)  2806(3)  2928(4)  2775(2)  
15F
 252(5) 238(3) 235(2) 245(4) 198(1) 1330(5)  1110(1.5)  1177(3)  1299(4)  1110(1.5)  
16F
 -(4) -(4) 6884 (2) -(4) 3407 (1) -(3) -(3) -(3) -(3) -(3) 
17F
 683(5) 677(4) 584(1) 627(2) 641(3) -(3) -(3) -(3) -(3) -(3) 
18F
 4931 (4) 4634 (2) -(5) 4746 (3) 3072 (1) -(3) -(3) -(3) -(3) -(3) 
19F
 -(4) -(4) 5858 (2) 5811 (1) -(4) -(3) -(3) -(3) -(3) -(3) 
AvgR.  4.58(5) 2.55(3) 2.47(2) 3.63(4) 1.76(1) 4.21(5) 2.74(3) 2.61(2) 3.29(4) 2.16(1) 
Fï´
 17.287  5.947  
 
TABLE â…¨ 
CTS AND  RANKS  OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol5% ï¥=  
tol1% ï¥=  
Rand HWS  DES  HSS SS Rand HWS  DES  HSS SS 
1F
 1.029 (5) 0.807(1) 0.914 (3) 0.922 (4) 0.832 (2) 1.152(5) 0.967 (1) 1.090 (3) 1.097 (4) 0.998 (2) 
2F
 0.286 (5) 0.222(1) 0.284(4) 0.280(3) 0.248 (2) 1.246(4) 1.146 (1) 1.239(3) 1.284(5) 1.226(2) 
3F
 0.445 (5) 0.314 (1) 0.404 (3) 0.422 (4) 0.362(2) 1.706(5) 1.355(1) 1.641(4) 1.617(3) 1.512 (2) 
4F
 0.193 (4) 0.165 (2) 0.181(3) 0.205(5) 0.157 (1) 0.227 (5) 0.165 (1) 0.196(3) 0.221(4) 0.191(2) 
5F
 0.670(5) 0.575 (2) 0.652(3) 0.679(4) 0.552 (1) 3.7680(5) 3.184(1) 3.702(3) 3.736(4) 3.677(2) 
6F
 0.215 (5) 0.144 (1) 0.204(4) 0.203 (3) 0.188(2) 1.320 (5) 1.108(1) 1.275(3) 1.282(4) 1.269 (2) 
7F
 0.234(5) 0.178 (1) 0.215 (3) 0.228 (4) 0.194 (2) 0.413(4) 0.316(1) 0.386 (3) 0.419(5) 0.349(2) 
8F
 0.177 (5) 0.144 (1) 0.172 (3) 0.173 (4) 0.161 (2) 0.516(4) 0.415(1) 0.462(3) 0.534(5) 0.442 (2) 
9F
 1.795 (5) 1.294 (1) 1.713(3) 1.756(4) 1.575(2) 3.257(5) 2.698(1) 3.235 (4) 3.109 (2) 3.139(3) 
10F
 0.868 (5) 0.633(1) 0.858(4) 0.822(2) 0.822 (3) 2.784 (5) 2.123 (1) 2.574 (2) 2.757 (4) 2.700(3) 
11F
 0.932(5) 0.631 (1) 0.695(2) 0.865 (4) 0.786 (3) 2.153(5) 1.796(1) 2.013 (2) 2.035(3) 2.044(4) 
12F
 0.234 (5) 0.157(1) 0.226 (4) 0.214 (3) 0.196 (2) 0.426 (4) 0.333 (1) 0.403(2) 0.430(5) 0.419 (3) 
13F
 0.144 (5) 0.108(1) 0.140(3) 0.143(4) 0.130 (2) 1.153(5) 0.962(1) 1.057 (3) 1.123 (4) 1.030(2) 
14F
 0.687(5) 0.439(1) 0.623(3) 0.652(4) 0.614 (2) 2.330(5) 1.701(1) 1.903(2) 2.065(3) 2.182 (4) 
15F
 0.098(5) 0.073(1) 0.081(2) 0.087 (4) 0.087(3) 0.585(5) 0.439(1) 0.522(2) 0.579 (4) 0.543 (3) 
16F
 2.540(3) 2.817 (5) 2.258(2) 2.621 (4) 1.804(1) 3.930 (4) 3.382 (1) 3.881 (3) 3.864 (2) 3.964(5) 
17F
 0.423(5) 0.328 (1) 0.362 (2) 0.398(4) 0.387 (3) 4.311(3) 3.781(1) 4.240(2) 4.344(5) 4.333(4) 
18F
 2.477(4) 2.314(2) 3.129(5) 2.393(3) 1.424 (1) 4.353 (5) 3.747 (1) 4.352(4) 4.261(2) 4.348 (3) 
19F
 3.095(5) 2.878 (2) 3.054(3) 2.659(1) 3.078 (4) 4.660(5) 4.004 (1) 4.510 (3) 4.514(4) 4.421 (2) 
AvgR.  4.790(5) 1.421 (1) 3.105 (3) 3.579(4) 2.105 (2) 4.632(5) 1.000 (1) 2.842 (3) 3.790(4) 2.737(2) 
Fï´
 39.000  50.689  
 
Next, the 30-dimensional test functions were used to test the performance of CLPSO -
LDSEDS. In addition, some functions in Table V were discar ded, as CLPSO cannot find their 
optimal solutions with relative errors smaller than 20%. The CSs , the CTs  and the ir ranks of  
different algorithms are compared in Table â…© and â…ª . It can be observed again that CLPSO -
LDSEDSs perform better than CLSPO. The Friedman statistics 
Fï´  are larger than the critical 
value 
c2.537 ï´=  for both the CSs and the CTs , which shows the significant differences between 
the considered five algorithms. According to the NT,  when 
tol20% ï¥= , the AvgRks  of CSs of all This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 four CLPSO -LDSEDSs are significantly smaller than that of CLPSO; when 
tol10% ï¥= , the 
AvgRks  of CSs of CLPSO -LDSEDSs with HWS and DES are significantly smaller than that of 
CLPSO. The AvgRks  of CTs of  with HWS and DES are significantly smaller than that of CLPSO; 
when 
tol10% ï¥= , The AvgRks  of CTs of CLPSO -LDSEDSs with HWS, DES , and SS  are 
significantly smaller than that of CLPSO . 
According to Tables â…¥-â…¦, it can be concluded that the proposed LDSEDS techniqu e can 
substantially improve the convergence speed without reducing the search ability of the  original 
CLPSO . Among  the four adopted LDSs , the HWS and DES are more robust than the other two 
samplings and can significantly improve the convergence speed of CLPSO.  
TABLE â…© 
CSS AND RANKS OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol20% ï¥=  
tol10% ï¥=  
Rand HWS  DES  HSS SS Rand HWS  DES  HSS SS 
2F
 4086(5)  3568(1)  3700(2)  3719(3)  3827(4)  -(3) -(3) -(3) -(3) -(3) 
3F
 2906(5)  2567(1)  2611(2)  2801(3)  2854(4)  6139(5)  5800(2)  5619(1)  5951(3)  6084(4)  
4F
 28(5)  19(2)  2(1) 25(3)  27(4)  335(5)  267(2)  261(1)  294(3)  312(4)  
5F
 3338(5)  2693(1)  2868(2)  3061(3)  3254(4)  -(3) -(3) -(3) -(3) -(3) 
6F
 1633(5)  1364(1)  1403(2)  1426(3)  1595(4)  4044(5)  3571(1)  3578(2)  3671(3)  3825(4)  
7F
 3715(5)  3079(1)  3237(2)  3560(3)  3687(4)  4454(5)  3727(1)  3855(2)  4176(3)  4373(4)  
8F
 2195 (5) 1943(2)  1933(1)  2020(3)  2091(4)  3749(5)  3434(2)  3361(1)  3604(3)  3670(4)  
11F
 4371(5)  4072(1)  4200(2)  4251(3)  4291(4)  5845(5)  5479(2)  5776(4)  5448(1)  5634(3)  
13F
 1179(5)  1074(2)  1081(3)  1056(1)  1155(4)  2406(5)  2137(3)  2131(2)  2116(1)  2402(4)  
14F
 3434(5)  2990(1)  3087(2)  3145(3)  3350(4)  3922(5)  3491(1)  3623(3)  3584(2)  3827(4)  
15F
 1279(5)  959(1)  1091(3)  1162(4)  1070(2)  3578(4)  2605(1)  3542(4)  7270(5)  2810(2)  
16F
 735(5)  655(1)  656(2)  673(4)  657(3)  -(4.5)  5321(2)  -(4.5)  6380(3)  4162(1)  
17F
 1938(5)  1910(4)  1630(2)  1561(1)  1753(3)  3333(3)  6182(5)  2718(2)  2609(1)  3421(4)  
18F
 4986(3)  7310(5)  4553(1)  6482(4)  4643(2)  -(3) -(3) -(3) -(3) -(3) 
19F
 -(3.5)  6262(1)  -(3.5)  -(3.5)  -(3.5)  -(3) -(3) -(3) -(3) -(3) 
AvgR.  4.767 (5) 1.667 (1) 2.033 (2) 2.967 (4) 2.533 (3) 4.233 (5) 2.267 (1) 2.500 (2) 2.667 (3) 3.333 (4) 
Fï´
 22.416  4.817 
 
TABLE â…ª 
CTS AND  RANKS  OF THE FIVE ALGORITHMS AT DIFFERENT TOLERANCE ERRORS  
 
tol20% ï¥=  
tol10% ï¥=  
Rand HWS  DES  HSS SS Rand HWS  DES  HSS SS 
2F
 6.872(5) 4.621 (1) 5.753 (3) 5.627(2) 6.491(4) 10.030(5) 8.381 (1) 9.844 (2) 9.640 (4) 9.724 (3) 
3F
 4.454(5) 3.263(1) 3.933(2) 4.114 (3) 4.262 (4) 10.067(5) 8.237 (1) 9.543(2) 9.025(3) 9.661(4) 
4F
 0.027(3) 0.019(1) 0.019 (2) 0.0290(5) 0.028(4) 0.522(5) 0.409(1) 0.461 (3) 0.486(2) 0.498(4) 
5F
 6.023 (5) 4.219(1) 4.959 (2) 5.378 (3) 5.747 (4) 13.71 3(5) 11.91 0(1) 13.37 4(2) 13.300(4) 13.319(3) 
6F
 2.351 (5) 1.638 (1) 1.970(2) 2.085(4) 2.043 (3) 6.224(5) 4.825(1) 5.628 (3) 5.791(2) 5.841(4) 
7F
 5.163(5) 3.651(1) 4.484 (2) 4.769(3) 4.973(4) 6.589(5) 4.963 (1) 5.886(3) 6.276 (2) 6.514(4) This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 
8F 2.600 (5) 1.962(1) 2.435 (2) 2.467(3) 2.527 (4) 5.127(5) 4.180 (1) 4.629(3) 4.885(2) 5.102(4) 
11F
 6.391(5) 4.914 (1) 5.998(2) 6.364(4) 6.162 (3) 8.559(5) 6.553 (1) 7.573 (4) 8.353 (2) 8.118(3) 
13F
 1.803 (5) 1.544(1) 1.702 (2) 1.783 (4) 1.780(3) 4.631 (5) 3.436(2) 3.303(3) 3.926(1) 4.162(4) 
14F
 11.42 9(5) 9.370(1) 9.894(2) 10.597(3) 10.640(4) 13.41 2(5) 11.339(1) 11.800(3) 12.429(2) 13.189(4) 
15F
 2.431(5) 1.640 (1) 2.297 (3) 2.341(4) 1.9610(2) 7.141(3) 4.166(1) 8.088(5) 10.86 1(4) 5.849(2) 
16F
 1.186 (5) 0.969 (1) 1.168 (4) 1.126(3) 1.055 (2) 13.40 1(4) 12.222(3) 15.839(2) 11.73 3(5) 10.59 1(1) 
17F
 3.572(5) 3.190 (4) 2.506(1) 2.831(2) 3.103(3) 5.295 (4) 5.971(5) 4.082(2) 4.801 (1) 5.284 (3) 
18F
 15.678(2) 15.812(3) 15.388(1) 17.48 2(4) 17.598(5) 17.609(2) 16.21 3(1) 17.62 3(5) 17.89 2(3) 17.82 3(4) 
19F
 21.539(4) 18.564(2) 18.008(1) 21.41 1(3) 21.916(5) 22.149(5) 20.67 4(1) 22.100(3) 22.096(4) 22.057(2) 
AvgR. 4.600(5)  1.400 (1) 2.067(2) 3.333 (3) 3.600 (4) 4.533(5) 1.467(1) 2.733 (2) 3.000 (3) 3.268(4) 
Fï´
 25.573  13.155  
 
7. Conclusions  
Many researchers have tried to use LDS to initialize the population, hoping to accelerate the 
convergence  of PSO by taking advantage of the excellent uniformity of the low-discrepancy 
sample set . However, the effect of this improvement direction seems inconclusive, and it also 
lacks corresponding theoretical support.  
Based on Niderreiterâ€™s theorem, this paper reveals  the relationship between the uniformity of 
the sample set and the error bound  of PSO, which  provides theoretical support for using LDS  in 
the expanded dimensional space  to accelerate PSO . On this basis, a new acceleration technique, 
LDSEDS , is provided. Two different sample construction methods  are proposed to generate the 
low-discrepancy sample sets in the expanded dimensional space, and correspondingly,  two more 
effective PSO algorithms are proposed, namely PSO-LDSEDS 1 and PSO-LDSEDS 2. 
The computa tional performance of PSO -LDSEDS1 and PSO -LDSEDS2 is studied, and the 
following conclusions are obtained based on numerical verification . Using PSO -LDSEDS1 to 
calculate the test function s can indeed converge faster than PSO . However, this advantage is only  
obvious when the  population size  
N is large  due to  the construction method of the low-
discrepancy sample set  in PSO -LDSEDS1. Therefore, we prefer to use PSO -LDSEDS2, which has 
the same advantages and requires fewer samples. Numerical experiments show that the proposed 
PSO-LDSEDS2 not only improve s the convergence speed of PSO in solving low dimensional 
problems but also improve s its convergence speed in solving high -dimensional problems . 
In addition, t he improve d direction asserted in  this paper can be extended to other PSO -type 
algorithms. The CLPSO -LDS EDS generated by combining with CLPSO also has a fast This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 conver gence speed in low and high dimensions.   
The effects of the different LDSs are different but on the whole,  HWS  and DES  are more 
robust. There is always a significant difference between the improved algorithm using HWS (or 
DES ) and the original algorithm. Therefore, it is recommended to give priority to HWS and DES 
in practical application.  
Finally, it is worth further emphasizing that the acceleration method in this paper may be 
extended to other PSO -type optimization algorithms  (including multiobjective optimization 
problems) and to other types of evolutionary algorithms, which is also a direction need ing further 
study.  
 
 
REFERENCE  
 [1] J. Kennedy and R. Eberhart, ""Particle swarm optimization,"" in Proceedings of ICNN'95 - International Conference on Neural 
Networks , Perth, WA, Australia, 1995, pp. 1942 -1948.  
 [2] R. Eberhart and J. Kennedy, ""A new optimizer using particle swarm theory,"" i n MHS'95. Proceedings of the Sixth 
International Symposium on Micro Machine and Human Science , Nagoya, Japan, 1995, pp. 39 -43. 
 [3] W. Jiang  et al. , ""Query -Efficient generation of adversarial examples for defensive DNNs via Multi -Objective optimization,"" 
IEEE Trans. Evol. Comput. , pp. 1. 2023, doi: 10.1109/TEVC.2022.3231460.  
 [4] J. H. Huang, B. Xue, Y . N. Sun, M. J. Zhang, and G. G. Yen, ""Particle swarm optimization for compact neural architecture 
search for image classification,"" IEEE Trans. Evol. Comput. , early access , doi: 10.1109/TEVC.2022.321  
7290.  
 [5] K. Ishaque, Z. Salam, M. Amjad, and S. Mekhilef, ""An improved particle swarm optimization (PSO) -based MPPT for PV 
with reduced Steady -State oscillation,"" IEEE Trans. Power Electr. , vol. 27, no. 8, pp. 3627 -3638, Aug. 2012, doi: 
10.1109/TPEL.2012.2185713.  
 [6] B. Ahadzadeh  et al. , ""SFE: A simple, fast and efficient feature selection algorithm for High -Dimensional data,"" IEEE Trans. 
Evol. Comput. , early access , doi: 10.1109/TEVC.2023.3238420.  
 [7] Y . Hu, Y . Zhang, and D. W. Gong, ""Multiobjective particle swarm optimization for feature selection with fuzzy cost,"" IEEE 
Trans. Cybern ., vol. 51, no. 2, pp. 874 -888, Feb. 2021, doi: 10.1109/TCYB.2020.3015756.  
 [8] B. B. Li, L. Wang, and B. Liu, ""An effective PSO -Based hybrid algorithm for multiobjective permutation flow shop 
scheduling,"" IEEE Trans . on Systems, Man, and Cybern .- Part A: Systems and Humans , vol. 38, no. 4, pp. 818 -831, Jul. 2008, 
doi: 10.1109/TSMCA.2008.923086.  
 [9] Y . H. Shi and R. C. Eberhart, ""A modified particle swarm optimizer,"" in IEEE International Conference on Evolutionary 
Computation , Anchorage, AK, 1998, pp. 69 -73. 
[10] M. Clerc and J. Kennedy, ""The particle swarm - explosion , stability, and convergence in a multidimensional complex space,"" 
IEEE Trans. Evol. Comput. , vol. 6, no. 1, pp. 58 -73, Feb. 2002, doi: 10.1109/4235.985692.  
[11] Z. H. Zhan, J. Zhang, and L. Y un, ""Adaptive particle swarm optimization,"" in IEEE Trans . on Sy stems, Man, and Cybern ., 
Part B: Cybernetics , USA, 2009, pp. 1362 -1381.  
[12] J. J. Liang, A. K. Qin, P. N. Suganthan, and S. Baskar, ""Comprehensive learning particle swarm optimizer for global 
optimization of multimodal functions,"" IEEE Trans. Evol. Comput ., vol. 10, no. 3, pp. 281 -295, Jul. 2006, doi: 
10.1109/TEVC.2005.857610. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 [13] N. Lynn and P. N. Suganthan, ""Heterogeneous comprehensive learning particle swarm optimization with enhanced 
exploration and exploitation,"" Swarm Evol . Comput ., vol. 24, pp. 11 -24, Oct. 2015, doi: 10.1016/j.swevo.2015.05.002.  
[14] Z. H. Zhan, J. Zhang, Y . Li, and Y . H. Shi, ""Orthogonal learning particle swarm optimization,"" IEEE Trans. Evol. Comput. , 
vol. 15, no. 6, pp. 832 -847, Dec. 2011, doi: 10.1109/TEVC.2010.2052054.  
[15] X. Y . Liu, G. G. Wang, and L. Wang, ""LSFQPSO: Quantum particle swarm optimization with optimal guided LÃ© vy flight 
and straight flight for solving optimization problems,"" Eng. Comput. -Germany , vol. 38, no. S5, pp. 4651 -4682, Dec. 2022, doi: 
10.1007/s00366 -021-01497 -2. 
[16] R. Mendes, J. Kennedy, and J. Neves, ""The fully informed particle swarm: Simpler, maybe better,"" IEEE Trans. Evol. 
Comput. , vol. 8, no. 3, pp. 204 -210. 2004, doi: 10.1109/TEVC.2004.826074.  
[17] N. Y . Zeng  et al., ""A dynamic Neighborhood -Based switching particle swarm optimization algorithm,"" IEEE Trans. Cybern. , 
vol. 52, no. 9, pp. 9290 -9301, Sep. 2022, doi: 10.1109/TCYB.2020.3029748.  
[18] B. Kazimipour, X. D. Li, and A. K. Qin, ""A review of population initia lization techniques for evolutionary algorithms,"" in 
IEEE Congr . Evol. Comput . (CEC) , Beijing, China, 2014, pp. 2585 -2592.  
[19] D. S. Wang, D. P. Tan, and L. Liu, ""Particle swarm optimization algorithm: An overview,"" Soft Comput. , vol. 22, no. 2, pp. 
387-408, Jan. 2018, doi: 10.1007/s00500 -016-2474 -6. 
[20] S. Rana, S. Jasola, and R. Kumar, ""A review on particle swarm optimization algorithms and their applications to data 
clustering,"" Artif. Intell. Rev. , vol. 35, no. 3, pp. 211 -222, Nov. 2011, doi: 10.1007/ s10462 -010-9191 -9. 
[21] B. Niu, Y . L. Zhu, X. X. He, and H. Wu, ""MCPSO: A multi -swarm cooperative particle swarm optimizer,"" Appl. Math. 
Comput. , vol. 185, no. 2, pp. 1050 -1062, Feb. 2007, doi: 10.1016/j.amc.2006.07.026.  
[22] M. Richards and D. V entura, ""Choosing a starting configuration for particle swarm optimization,"" in IEEE Inter . Joint 
Confer . Neural Networks , Budapest, Hungary, 2004, pp. 2309 -2312.  
[23] R. W. Morrison, Dispersion -Based population initialization , Berlin, Heidelberg: Springer Berlin Heidelberg, 2003, pp. 1210 -
1221.  
[24] Q. Li, S. Y . Liu, and X. S. Yang, ""Influence of initialization on the performance of metaheuristic optimizers,"" Appl. Soft 
Comput. , vol. 91, pp. 106193, Jun. 2020, doi: 10.1016/j.asoc.2020.1 06193.  
[25] A. Tharwat and W. Schenck, ""Population initialization techniques for evolutionary algorithms for single -objective 
constrained optimization problems: Deterministic vs. Stochastic techniques,"" Swarm Evol . Comput ., vol. 67, pp. 100952, Dec. 
2021, doi: 10.1016/j.swevo.2021.100952.  
[26] J. Kennedy, ""The behavior of particle,"" in International Conference on Evolutionary Programming VII. Springer -Verlag , 
San Diego, CA, USA, 1998, pp. 581 -589. 
[27] E. Ozcan and C. K. Mohan, ""Analysis of a simple particl e swarm optimization system,"" in Intell . Engineer . Systems Artif . 
Neural Networks , 1998, pp. 253 -258. 
[28] F. van den Bergh, ""An analysis of particle swarm optimizers,"" Ph.  D. dissertation thesis, University of Pretoria, South Africa, 
2002.  
[29] I. C. Trelea, ""The particle swarm optimization algorithm: Convergence analysis and parameter selection,"" Inform. Process. 
Lett., vol. 85, no. 6, pp. 317 -325, Mar. 2003, doi: 10.1016/S0020 -0190(02)00447 -7. 
[30] H. M. Emara and H. A. A. Fattah, ""Continuous s warm optimization technique with stability analysis,"" in American Control 
Confer ., Piscataway NJ, Evanston IL, 2004, pp. 2811 -2817.  
[31] E. GarcÃ­ a -Gonzalo and J. L. FernÃ¡ ndez -MartÃ­ nez, ""Convergence and stochastic stability analysis of particle swarm Confer ., Piscataway NJ, Evanston IL, 2004, pp. 2811 -2817.  
[31] E. GarcÃ­ a -Gonzalo and J. L. FernÃ¡ ndez -MartÃ­ nez, ""Convergence and stochastic stability analysis of particle swarm 
optimi zation variants with generic parameter distributions,"" Appl. Math. Comput. , vol. 249, pp. 286 -302, Dec. 2014, doi: 
10.1016/j.amc.2014.10.066.  
[32] V . Kadirkamanathan, K. Selvarajah, and P. J. Fleming, ""Stability analysis of the particle dynamics in particl e swarm 
optimizer,"" IEEE Trans. Evol. Comput. , vol. 10, no. 3, pp. 245 -255, Jun. 2006, doi: 10.1109/TEVC.2005.8570  
77. This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 [33] M. D. Mckay, R. J. Beckman, and W. J. Conover, ""A comparison of three methods for selecting values of input variables in 
the analysis of output from a computer code,"" Technometrics , vol. 2, no. 21, pp. 239 -245. 1979, doi: 10.2307/1268522.  
[34] Y . W. Leung and Y . P. Wang, ""An orthogonal genetic algorithm with quantization for global numerical optimization,"" IEEE 
Trans. Evol. Comput. , vol. 5, no. 1, pp. 41 -53, Feb. 2001, doi: 10.1109/4235.910464.  
[35] L. Peng, Y . Z. Wang, G. M. Dai, and Z. S. Cao, ""A novel di fferential evolution with uniform design for continuous global 
optimization,"" Journal Comput ., vol. 7, no. 1. 2012, doi: 10.4304/jcp.7.1.3 -10. 
[36] L. G. Hua and Y . Wang, ""On uniform distribution and numerical analysis ( â…°) (Number -Theoretic method),"" Science China , 
vol. 16, no. 4, pp. 483 -505, Nov. 1973  
[37] L. G. Hua and Y . Wang, ""On uniform distribution and numerical analysis ( â…±) (Number -Theoretic method),"" Science China , 
vol. 17, no. 3, pp. 331 -348, Jun. 1974  
[38] L. G.  Hua and Y . Wang, ""On uniform distribution and numerical analysis ( â…²) (Number -Theoretic method),"" Science China , 
vol. 18, no. 2, pp. 184 -198, Mar. 1975  
[39] J. H. Halton, ""On the efficiency of certain quasi -random sequences of points in evaluating multi -dimensional integrals,"" 
Numer. Math. , vol. 2, no. 1, pp. 84 -90, Dec. 1960, doi: 10.1007/BF01386213.  
[40] I. M. Sobol, ""On quasi -Monte Carlo integrations,"" Math. Comput. Simulat. , vol. 2 -5, no. 47, pp. 103 -112, Aug. 1998, doi: 
10.1016/S0378 -4754(98)00096 -2. 
[41] A. Tharwat and A. E. Hassanien, ""Chaotic antlion algorithm for parameter optimization of support vector machine,"" Appl. 
Intell. , vol. 48, no. 3, pp. 670 -686, Mar. 2018, doi: 10.1007/s10489 -017-0994 -0. 
[42] R. L. Cook, ""Stochastic sampling in computer g raphics,"" ACM Transaction on Graphics , vol. 1, no. 5, pp. 51 -72, Jan. 1986, 
doi: 10.1145/7529.8927.  
[43] R. Bridson, ""Fast poisson disk sampling in arbitrary dimensions,"" presented at the ACM SIGGRAPH 2007 Sketches 
Program, 2007.  
[44] F. De Rainville, C. G agnÃ© , O. Teytaud, and D. Laurendeau, ""Evolutionary optimization of low -discrepancy sequences,"" 
ACM Trans. Model . Comput . Simul., vol. 22, no. 2, pp. 1 -25, Mar. 2012, doi: 10.1145/2133390.2133393.  
[45] F. Wu, Y . L. Zhao, K. Zhao, and W. X. Zhong, ""A multi -body dynamical evolution model for generating the point set with 
best uniformity,"" Swarm Evol . Comput ., no. 73, pp. 101121, Aug. 2022, doi: 10.1016/j.swevo.2022.101121.  
[46] L. Kocis and W. J. Whiten, "" Computational investigations of low -discrepancy sequences,"" ACM Trans. Math. Software , vol. 
23, no. 2, pp. 266 -294, Jun. 1997, doi: 10.1145/264029.264064.  
[47] H. Niederreiter, A quasi -Monte Carlo method for the approximate computation of the extreme value s of a function : 
BirkhÃ¤ user Basel, 1983.  
[48] G. H. Wu, R. Mallipeddi, and P. N. Suganthan, ""Problem Definitions and Evaluation Criteria for the CEC 2017 Competition 
and Special Session on Constrained Single Objective Real -Parameter Optimization,"". 2017  
[49] R. L. Iman and J. M. Davenport, ""Approximations of the critical region of the fbietkan statistic,"" Commun . statistics. Theory 
methods , vol. 9, no. 6, pp. 571 -595, Jul. 1980, doi: 10.1080/03610928008827904.  
[50] P. Nemenyi, Distribution -free multiple comparisons , WASHINGTON: International Biometric Soc 1441 I ST, 1962, p. 263.  
 
Feng Wu  (Member, IEEE ) received his B.Sc degrees in Civil Engineering from Guangxi 
University in 2007. And from the same university, he received the M.Eng in Structural Engineering in 
2010. He obtained the Ph.D degree in Engineering Mechanics from Dalian University of Technology in 
2015. From 2015 to 2017, he worked as a post -doctor in the School of Naval Architecture & Ocean 2010. He obtained the Ph.D degree in Engineering Mechanics from Dalian University of Technology in 
2015. From 2015 to 2017, he worked as a post -doctor in the School of Naval Architecture & Ocean 
Engineering at Dalian Univ ersity of Technology. Since 2017, he has been an associate professor in 
Dalian University of Technology.  His research direction is the  dynamics and control . This work has been submitted to the IEEE for possible publication. Copyright may be transferred without 
notice, after which this version may no longer be accessible.  
 
 Yuelin Zhao (Student Member , IEEE)  is working as a postgraduate student in Computational 
mechanics with the faculty of vehicle engineering and mechanics, Dalian University of Technology. Her 
research interests include the construction and application of the low -discrepancy sample s. 
  
 
 
 
Jianhua Pang  received the Ph.D degree in Ship and Ocean Engineering from Dalian University of 
Technology in 2016. Currently, he is the leader of the marine intelligent equipment and system team of 
Guangdong Ocean University Shenzhen Research Institute, the post doctoral supervisor of ma rine 
engineering technology of Tsinghua University International Graduate School, the young scientist of 
Guangdong Province, the outstanding young scholar of Guangdong Ocean University's top talents, the 
high-level leading reserve talents of Shenzhen. His research direction is the theory and method of 
intelligent ocean technology.  
 
Jun Yan  received the Ph.D degree in Engineering Mechanics from Dalian University of Technology 
in 2007 . In 2015, he was selected into the growth plan of outstanding young schola rs in colleges and 
universities of Liaoning Province. He is the deputy director of the Department of Engineering Mechanics 
of Dalian University of Technology, the member of the Education Work Committee of the Chinese 
Mechanics Society, the member of the Fo reign Exchange and Cooperation Work Committee, and the 
director of key funds of the National Natural Science Foundation of China. His research direction is 
structure and multidisciplinary optimization.  
 
Wanxie Zhong  graduated from the Department of Bridge  and Tunnel, Tongji University in 1956.  In 
1984, he was elected as the chairman of China Association of Computational Mechanics; In 1993, he 
was awarded honorary professor by the University of Wales and the University of Hong Kong; In the 
same year, he was  elected as an academician of Chinese Academy of Sciences.  He has put forward 
important theories and methods in group theory, limit analysis, parametric variational principle, etc.  , and 
organizes and develops various large -scale structural simulation  systems."," This paper proposes a new acceleration technique for Particle Swarm Optimization (PSO) using low-discrepancy sampling in the expanded dimensional space. It is supported by various grants and the corresponding authors are Feng Wu and Jun Yan. The technique reduces the error at each iteration and improves the convergence speed. The paper also compares the effects of five famous population initialization methods and discusses the error of the PSO algorithm. The paper further investigates why the advantages of using an LDS initialization cannot be preserved during the entire iteration of PSO. The paper also presents two versions of the LDSEDS technique, which is combined with PSO to generate two more effective algorithms. The performance of the different algorithms is measured using the metric of error tolerance. The paper also compares the performance of PSO and PSO-LDSEDS2 using 10D and 30D dimensional test functions. The paper concludes that the LDSEDS technique can significantly improve the convergence speed of PSO, with HWS and DES being the most robust samplings."
18," 1   S  
 
Emerging AI Technologies Inspiring the 
Next Generation of E -textiles 
FRANCES CLEARY1,2, WITAWAS SRISA- AN3, David C. Henshall.1 and Sasitharan 
Balasubramaniam 3 
1Physiology and Medical Physics,  RCSI Uni- versity of Medicine Health Sciences,  Dublin,  Ireland  
2Walton Institute,  South East Technological University,  Waterford,  Ireland  
3School of Computing,  University of Nebraska,  Lincoln,  United States  
 
ABSTRACT  The smart textile and wearables sector is looking towards advancing technologies to meet 
both industry,  consumer  and new emerging  innovative  textile  application  demands,  within  a fast paced  textile 
industry. In parallel inspiration based on the biological neural workings of the human brain is driving the 
next generation of artificial intelligence. Artificial intelligence inspired hardware (neuromorphic computing) 
and software modules mimicking the pr ocessing capabilities and properties of neural networks and the 
human nervous system are taking shape. The textile sector needs to actively look at such emerging and 
new technologies  taking  inspiration  from  their workings  and processing methods  in order  to stimulate  new 
and innovative  embedded intelligence  advancements  in the etextile  world.  This emerging  next generation  of 
Artificial intelligence(AI)  is rapidly  gaining interest  across  varying industries  (textile,  medical,  automotive, 
aerospace, military ). It brings the promise of new innovative applications enabled by low size, weight  
and processing power technologies. Such properties meet the need for enhanced performing integrated circuits (ICâ€™s) and complex machine learning algorithms. How such propertie s can inspire and drive 
advancements within the etextiles sector needs to be considered. This paper will provide an insight into 
current nanotechnology and artificial intelligence advancements in the etextiles domain before focusing 
specifically  on the future  vision  and direction  around the potential  application  of neuromorphic  computing 
and spiking neural network inspired AI technologies within the textile sector. We investigate the core architectural  elements  of artificial neural  networks,  neuromorphic  computing (2D and 3D structures ) 
and how such neuroscience inspired technologies could impact and inspire change and new research developments within the e -textile sector.  
 
Keywords  Artificial Intelligence,  Etextiles,  Neural  Networks,  Neuromorphic  Computing.  
 
 
I. INTRODUCTION  
MART  clothing  traditionally  refers  to a garment  with the 
capability  to enable/disable  a function  such as monitor - 
ing a personâ€™s physical condition [5], whereas an e -textile 
provides  an added layer  of intelligence  such as connection to 
a peripheral  or embedded electronic  device into the garment 
or fabric, providing added value to the person that wears  
the item.  Smart  clothing  leveraging  embedded intelligent 
e-textiles with computational and memory capabilities are 
foreseen  as the next big market  mover  in the Internet  of things 
space. Demand for usable and wearable technology is con - 
stantly growing and the expected market traction was fore - 
casted  etextiles  growth from 2981  Million  Dollars  (2022)  to 8508.1 Million  Dollars  (2028)  stated  by Absolute  reports . 
Three generations of smart textiles have evolved over the 
years (1) 1st generation of smart textiles: little integration 
between  the electronics  and the textile  (2) 2nd generation of 
smart  textiles: evolved with the adaptation  of traditional tex- 
tile fabrication methods to include additional functionality. 
eg sewn in conductive thread into textiles. (3) 3rd genera-  
tion integration of electronic sensing properties into textile 
materials. What will the next generation of etextiles and 
smart  cloth ing look like. Advancements  of ICT technologies 
(artificial intelligence  (AI))  intertwined  with nanotechnology materials. What will the next generation of etextiles and 
smart  cloth ing look like. Advancements  of ICT technologies 
(artificial intelligence  (AI))  intertwined  with nanotechnology 
(nano- textiles  and wearable  sensing  nanomaterials ) are key 
enabling drivers  of the next generation  of smarter  and more 2    
  
 
 
advanced etextiles  driving AI inspired computing fabrics. 
Rapidly Advancing ICT technologies such as artificial in - 
telligent spiking neural networks (SNN) and neuromorphic 
computing core technologies, computational capabilities as 
well as their architectural structure brin g the potential to 
inspire new and fresh innovations in this domain.  
The textile  sector  has been  experiencing  a digital transfor-  
mation predominately within its textile manufacturing pro - 
cesses  and production  industry,  where  AI-enabled  technolo - 
gies are being adopted for production line fabric inspection 
and defect detection, enhancing output quality [3] [4]. [14] 
provides a survey of state of art technological interventions 
that meet automatic fabric defect detection aligning to the 
industry 4.0 initiat ive, detailing traditional(statistical meth - 
ods, structural methods, model based methods) as well as learning  based  methods  (machine learning  or deep  learning). 
Intelligent clustering and classification techniques adopted 
and utilised in the textiles indu stry are summarised in [13], 
highlighting both supervised and unsupervised learning types supporting production planning, fabric fault detection, per - 
formance  and predictive  models.  In this paper  we will exam - 
ine in more  detail  artificial intelligence  ICT advancements  fo- 
cusing specifically  on neuromorphic  computing  and spiking 
neural network artificial intelligence, assessing their archi - 
tectural  structure,  vision,  capabilities  and how these  elements 
could be of relevance to inspire  future  research  advancements 
in the e -textiles sector. Healthcare is emerging as one of the 
key sectors where e -textiles and new advances in artificial 
intelligence (AI) driving embedded textile intelligence and on-body computation, can be leveraged and utilised in the 
near future both within a clinical environment such as a hospital and also support enhanced remote monitoring of 
patients  from  the comfort  of their own home.  [37] details 
a smart garment MyWear that monitors and collects phys - 
iological data ( muscle  activity, stress levels and heart rate 
variations ) processing the data in the cloud and providing 
predictions  to the user based  on abnormalities  detected.  Such 
e-textile applications and services utilising these AI tech - 
nologies bring the added value of a more effective real time monitoring and analysis for varying health conditions such 
as cancer care, cardiovascular and neurological disorders, 
leading  when  required  to early  interventions  as critical health 
concerns  are detected.  The â€˜Internet  of Smart  Clothing â€™ [12] 
pushes the boundaries around smart garment inter commu-  
nication, their interaction with environmental objects and how they actively communicate with remote servers for the 
provision of advanced  services.  The next generation  of smart 
clothing and e -textiles brings more intelligent embedded 
technological  layers  than before  and hence has requirements 
for more flexible, modular, integrated, seamless and usable 
functionality to meet end user needs.  
The rest of the paper  is organized as follows:  Section  2 provides an overview of advancements in nano technology and nano materials.  Section  3 details  AI intelligence  currently 
impacting  the textile  sector  and highlights  four core technical 
properties  required  to be considered  linked  to data flow com- 
munication  and process  methodology.  Section  4 discusses the 
core architectural  properties  of a spiking neural  network  and 
section 5 discusses the core architectural properties of neu - 
romorphic computing with the objective to provoke thought around how inspiration  can be taken  from  these  elements  and 
actively fed into next generation of etextiles.  
 
II. NANOTECH TEXTILE  RESEARCH ADVANCEMENTS  
Nanotech fabric that involves the integration of electron - actively fed into next generation of etextiles.  
 
II. NANOTECH TEXTILE  RESEARCH ADVANCEMENTS  
Nanotech fabric that involves the integration of electron - 
ics with textiles are pushing the boundaries in an exciting 
new phase  of interactive  smart  garments  [39][38].  Nanotech - 
nology involves the manipulation of individual atoms and molecules in order to create nano -scale machines that open 
the potential for a variety of applications  across  many  sectors 
(Sensors, Repel liquids, sensor display technology, odour 
control,  fabric  strength,  wrinkle  resistant ). [9] highlights  the 
advantages of Wearable memories and Computing devices 
(WMCs) and recent advances in nanotech nology and mate - 
rials science. The link between WMC and the human brain 
could enable  fast operation  along with interface  complexity, 
directly  mapping the continuous  states  available  to biological 
systems.  
Advances in micro -sensor technology and nano materials 
are feeding new and disruptive innovations around how we 
wear and actively engage with our clothing. Nanomaterials 
are enabling the next generation  union of textiles,  electronics 
and information processing [Fig 1]. Through this combina - 
tion or h ybrid approach this opens the door to integrate new 
capabilities  such as antimicrobial properties  or the integration 
of biological functions. Nanomaterials can be added during 
the fibre  production phase  or also during the finishing  phase 
onto the fibre  surface.  The aim is to utilise  nanomaterials 
in order to achieve enhanced flexibility, usability while also being more fashionable. Nanomaterials consist of various 
materials  such as graphene,  carbon nanotubes,  ploymers,  di- 
electric  elastomers  and composites.  Based  on various  stimuli 
to such nanomaterials  this creates  different  characteristic be- 
haviours that can in turn be utilised for varying applications 
specifically in the healthcare sector related to patient care 
applications. Biosensors that look at utilising nanomaterials 
integrates varying disciplines ranging from molecular engi - 
neering, material science, biotechnology/chemistry offering high sensitivity towards the recognition of various disease biomarkers at an early stage[40].  
In 2004 researchers  succeeded  in isolating  graphene  sheets 
(exfoliated graphene). This two dimensional material con - 
sists of carbon  atoms  arranged  in a hexagonal  lattice.  It is the 
thinnest  material  known in the world  (one atom  thick ) and 3   
  
opens the door to multiple opportunities in the design and 
development  of intelligent and smart  garments  and etextiles. 
Graphene  is light,  has greater  elasticity  and conductivity and 
brings the potential to replace synthetic fibres( polyester, 
nylon).  Chemical  sensing  properties  through graphene  fibers 
can be introduced into textile based materials. Cutecircuit (https://cutecircuit.com ) creat ed a black  dress that contained 
graphene. The dress had the capability to change colour in 
synch with the wearers  breathings.  This was completed  using 
mini LED lights with graphene used to power the lights and 
as a sensor to record the wearers breathing. G raphene based 
composites have also been used in 3D printing technologies 
to investigate the development of highly stretchable and 
sensitive  strain  sensors.  Such  an application  can be leveraged 
for breathing pattern monitoring and measurement [41].  
Nanopart icles are emerging  as diagnostic  sensors.  Textile 
advances  at nanometer  level encourage a new era of improved 
textile  functions  and capabilities  for example enhanced com- 
munications , antibacterial, sensing capabilities of textiles or 
moisture absorbing. Garment communication through eas - 
ily integrated textile antennas and interconnected integrated wearable textile systems are completed through the use of 
electroconductive fibres/yar ns and embroidery techniques. 
Research  in this area has been  actively  investigating  material 
properties  (flexibility,  conductiveness,  weight)  leading  to the 
emergence of nanoengineered functional  textiles  and the ad- 
dition  of nanoparticles  to fabrics  to increase textile  properties 
and capabilities.  (Ghadremani  et al 2016)  details  the addition 
of silver  nano particle  in order  to improve  the static  properties 
of a textile. (Liu et al 2010) highlights the addition of Ag (Silver ) nanoparticles  on sock garments  that in turn limit the 
growth of fungi and bacteria, reducing odour and itching of the feet. Nanomaterial skin -like wearable sensors, flexible 
electronic  substrates  are the focus  of development  at industry 
level.  There  has been  ongoing attempts  to mimic  human skin 
flexibility and stretch -ability in the etextile world. Sample 
Smart skin developments include  
â€¢ (Tianzhao  Bu et al) developed  a stretchable  triboelectric - 
photonic  skin with multidimensional tactile  and gesture 
sensing.  
â€¢ (Liu et al) completed a review on Lab -on-Skin, in par - 
ticular flexible and stretchable electronics for wearable health monitoring.  
â€¢ (Yang Et al) presents a novel structured fibre sensor 
embedded in silicone for the precise measurement of 
low-pressure in sm art skin.  
Such  nanotechnology,  nanomaterial  and smart  skin advance-  
ments  are attracting  alot of attention  both within  the research 
world and also with businesses as they see the economical 
impact  and the potential end user commercial  applications  of 
promi se that are emerging.  In parallel  the next generation  of 
artificial  intelligence  is seeing  the emergence  of Spiking  Neu- 
ral Networks(SNN) and neuromorphic computing, that will 
no doubt in the future trigger research directions focused on 
a fusion of nanotechnology AI-driven embedded  E-textiles  innovations. The remainder of this paper will delve further 
into the AI ( SNN) and neuromorphic engineering technolo - 
gies mapping and highlighting key architectural aspects to be considered further within the textile and smart garment 
research and innovation domain.  
 
III. ARTIFICIAL INTELLIGENCE  IMPACTING  TEXTILE 
SECTOR  
Etextile  research  doma in experts,  suppliers  and manufac-  
turers are starting to investigate at a deeper level the im - 
pact AI and machine learning technologies can have across varying sectors [6]. Digital transformation through the use 
of artificial intelligence is currently im pacting the textile pact AI and machine learning technologies can have across varying sectors [6]. Digital transformation through the use 
of artificial intelligence is currently im pacting the textile 
industry through the creation  of a more  sustainable  digi- 
tal supply chain and smart intelligent textile manufacturing optimization( production planning and operational process 
management ) right through to fabric defect identification 
[2], pattern inspection analytics and much more.(Chaudhari 
et al) provide an insight into the application of Artificial 
neural network (ANN) in fabric engineering, focusing on  
the application of ANN in the textile domain to support 
fabric cl assification, fabric wrinkle, automatic recognition  
of fabric patterns and fabric comfort. How such enhanced and smart technologies can aide the textile industry towards 
a sustainable and circular economy is of high priority and 
gaining a substantial amount  of attention.  Textile  fabric  based 
design software is also seeing the adoption and usage of AI 
based software tools in pattern design, making and cutting, 
providing  a superior  level  of tools  with inbuilt 3D visualisa - 
tions features [1].  
The adoption and use of AI within fabric based textiles 
requires  a structured  and methodological  process  taking  into 
account  technical  properties  of importance  along with the end 
user functional and form factors (Giuseppe et al)[13]. Such 
key etextile  embedded functionality  technical  properties  that 
are required to be considered when contemplating taking 
inspiration  from  advanced  AI technologies  into a fabric  based 
environment include  
 
â€¢ Fabric  based textile  computational  consideration s 
(Data Acquisition and Data Processing)  
â€¢ Monitoring  and measuring  capabilities  and techniques 
suitable for a fabric based environment . 
â€¢ Suitable  communications  methods  and techniques . 
â€¢ Energy  considerations  of relevance for textile -driven 
intelligence . 
All these  elements  directly  relate to the data flow commu - 
nication and processing methodology. In this paper we will 
adopt  these  elements  in order  to map across  new AI technol - 
ogy properties to the textile domain within sect ion 4 and 5. 
Currently  within  the healthcare medical  sector  such technical 
functional properties are applied and demonstrated through 
intelligent e -textiles for patient centric garment- based wear - 
ables[19].  Such  considerations  in the design and development 
enable the possibility  to gather  human  monitored  health 4   
  
 
 
 
FIGURE  2. Fabric  based  Neural  Network  Workflow  . 
 
 
related  datasets  such as Electromyography (EMG) or Electro - 
cardiography (EKG) data -sets through textile based sensors 
in wearable garments.  Such  data collection  type garments  and 
textiles  need  to be adaptable  to the users needs  for ease of use 
at varying levels.  Through  the active  collection  of these  data- 
sets, t his then allows for the transmission, processing and 
extraction of key analysis and results for effective decision 
making, this is aided through the development and imple - 
mentation of intelligent algorithms. The use of Artificial intelligent based algorithms and techniques enables an era  
of intelligent textiles utilising real time and accurate data knowledge in dynamically changing healthcare monitoring type environments.When considering such embedded  AI in a 
textile environment, there is a need to also look at the state of art of current AI formal methods and how they must be 
advanced to adapt. Key challenges and questions arise that 
will require  further  investigation  and research  as technology 
advances and emerges in this space.  
Pushing the boundar ies around the use of conductive 
threads  and embedded  smart  wearable intelligence  and func- 
tionality [48] were successful at their attempts to store data 
in fabric,  this was completed  through the magnetic  properties 
of conductive thread and this allowed f or applications such 
as utilising a garment to store a passcode to open a door to 
gain access to a building through the swipe of the garment arm that holds the passcode.  
We must ask ourselves what future fabric -based AI al - 
gorithms will look like, how will they be developed and integrated in a functioning manner in the very core of a 
fabric and fibre environment. Not only will new Fabric AI design fabrications emerge but also new fully fabric driven 
data acquisition and data processing driven approaches po - 
tentially  adopting  or inspired  by new AI best practice,  stan-  
dards and methodologies. Key features of fabric -based AI 
algorithms need to consider during implementation speed 
(response  time),  processing  capabilities,  complexity/size  and 
also learning. [Fig 2] provides an overview of the key com - 
ponents for consideration for a textile driven AI workflow facilitating a fabric based data acquisition, data processing 
fabric -based engine, execution in a fabric environment and 
also deployment.  
There is an em erging research interest around the appli - 
cation  of artificial intelligent technologies  in smart  wearable 
garments and the internet of smart clothing. Research ques - 
tions  are being investigated  around how such AI intelligence 
can be embedded  into the very core of a fabric  environment, 
with AI intelligence applications seamlessly embedded invis - 
ible to the human eye. [6] provide a comprehensive review 
of advancements in Smart textile integrated microelectronic systems,highlighting the core properties of importance 1) 
flexibility allowing for effective drape on 3D curvilinear 
surface such as a human body and 2) structural transforma - 
tion of textiles resulting in low fibre strain and fabric life cycle longevity. [11] convey a vision of moving from fibre devices to fabric computers , where the fabric fibers have 
inbuilt capability to perform sensory,storage,processing and 
powering capabilities providing a fabric based computing 
environment. Such a powerful fabric fibre based processing capability  enables  the execution  of fabric  based  programs  that 
can activate  fiber  sensors,  processing  and storing  data within 
the fabric computer. Work has been ongoing around the de - 
velopment  of such new fibres  with specific  focus  on scalable 
processes using thermal drawing, melt spinning, coating to 
provide  fibre  structures  that can house  and deliver  computing 
functionality[7][8][10]. Investigative methods into the digital processes using thermal drawing, melt spinning, coating to 
provide  fibre  structures  that can house  and deliver  computing 
functionality[7][8][10]. Investigative methods into the digital 
fabrication  of fibres  is being researched  where  inbuilt func- 5   
  
tionality provides in -fibre storage programs, data storage, 
sensors and digital communication [11], such a fabrication 
structured process proposes uniform placement of discrete 
in-fibre  electronic  devices  that will carry  out such function al- 
ity. Researchers are actively thinking outside the box about new and potentially disruptive innovative ways to fuse AI 
with etextiles  moving away  from  the traditional textile  world 
as we know it. This is sparking a renewed interest in this 
domain and s hows promise of real impact across multiple 
sectors.  
 
IV. SPIKING  NEURAL  NETWORK  PROPERTIES  
Artificial neural networks are seeing the emergence of new 
spiking neural network (SNN) technologies that simulate functionality using electronics components replicating and 
mimicking human brain biological workings of neurons, 
synapses and neural networks. Core architectural properties 
of an SNN include  
â€¢ Neurons  that emit a spike  once  a set threshold has been 
met. 
â€¢ Learning  in the neural  network is completed  by altering 
the synaptic weight. Random weight change algorithm is one of the most adopted and simple algorithms used 
during the learning  phase.  For this algorithm  the correct 
output  is known and the error  increased  or decreased  as 
required.  
â€¢ Results obtained depends  on the neuron spiking  activity 
and also the neural node inputs.  
[15] detail and explain a single neuron level, giving 1D 
neuron model examples such as Leaky integrate and fire (LIF) [16],the  Spike  Response  Model  (SRM)[17]  as well 
as more c omplex and biologically feasible artificial neurons 
such as the the Hodgkin and Huxley model[18].  We will now 
assess the core computational, monitoring /measurements, communications  and energy  of such SNN,  highlighting struc - 
tural and processing paradigms inspired by the human brain 
and the potential they could bring to the etextiles domain. [Fig 2] details the adoption of this data flow communica - 
tion and processing technology methodology to the etextile domain highlighting a fabric based workflow of relevance towards the implementation, validation and deployment of 
fabric driven AI ( neural network ) intelligent etextile wear - 
ables.  
 
A. COMPUTATIONAL ELEMENTS OF SNN ENABLING 
FABRIC-DRIVEN DATA ACQUISITION  AND PROCESSING  
Data acquis ition refers to the methodology and process of 
acquiring data and performing analysis in order to interpret 
it. This involves  the use of varying  techniques  and tools  used 
to sample  data,  convert  the data into a format  that can in turn 
be used for further a nalysis and processing. From a neural 
network point of view, we will now investigate further the 
main computational elements with a focus on highlighting 
architectural aspects of importance for consideration in a 
textile  environment  1) Artificial fabric  neurons  2) Artificial  fabric  synapses  3) Artificial fabric  neural  networks required 
to perform data acquisition and processing and the potential for adoption into a fabric environment.  
 
 
1) Etextile  Artificial  Fabric  Neuron  
Neurons are the core building blocks of neural networks. The workings of a neuron include synapses represented by 
weights, a threshold and an output spike that in turn resets the neuron. Each neuron has a membrane potential. This 
membrane potential is the equivalent of a volta ge and when 
that voltage passes a defined threshold a spike ( or action 
potential ) is emitted and hence this generated spike is the 
method by which one neuron communicates to another neu-  
ron in a SNN. Taking these aspects, how can we begin to 
consider a fa bric based neuron, its workings to replicate not 
only an individual neurons functionality but having the ca - 
pability  to be extended  to implement  multiple  interconnected 
neural  nodes  in a fabric  environment.  To work  towards  such only an individual neurons functionality but having the ca - 
pability  to be extended  to implement  multiple  interconnected 
neural  nodes  in a fabric  environment.  To work  towards  such 
a goal, we have to delve into the artificial electronic neuron representations  currently  defined  and that could inspire  future 
fabric based neural implementations. Here we will consider 
the Leaky integrate and Fire Model and the Hodgkin and 
Huxley Model. Further enhancements to these models and 
other  models  exist,  but this is outside  the scope  of this paper. 
Leaky Integrate and Fire Model (LIF) : The most simplistic 
model of a neuron is the Leaky Integrate and Fire neuron 
artificial electronic circuit b ased on the logic that if the  
spike (driving current) goes beyond the defined threshold then the neuron emits its own spike and resets. The model 
operates based on a resistor and capacitor (RC circuit) [Fig 3]. Limitations  of the LIF model  is that no memor y of spiking  
 
 
FIGURE  3. Simple  Integrate  and Fire artificial  (RC) neural  node 
 
activity is retained as the membrane potential is reset after each spike.  We need  to consider  how such a LIF model  could 
be replicated to produce an event driven spiking neuron in  
a fabric environment leveraging the leaky integrate and fire 
neuron model. Soft fabric based resistors can be fabricated 
using conductive  thread  (Zigzag  machine stitch  to create)  and 
ongoing research  is active  around the development  of textile 
based  capacitors[20].[51]  investigate  methods  for the capac- 6   
  
ity increasing of textile capacitors for planar and sandwich 
type textile capacitors using hybrid conductive threads and 
conductive  textiles.  Experimental  research  has also been  on- 
going into the development  of wearable fabric  Brain  enabling 
on-garment edge- based sensor data processing inspired by 
SNN architectural techniques and LIF model [56]. Such advancements  will open up options  and new methods  to work 
towards  functional  fabric  based  neural  nodes  based  on an RC 
circuit and LIF model, capable of processing â€˜eventâ€™ spike driven  activity  replicating  a neural  node,  that can be extended 
into a basic working event driven spiking neural network.  
Additional  embedded transistor  gated  circuitry  is required 
in order to implement the threshold level Vth for the mem - 
brane potential, when this threshold has been reached this 
produces an action potential spike. [22] detail an orga nic 
field-effect transistor that is realized on a flexible film that 
can be applied,  after the assembly,  on textiles.  [23] showcase 
a fully inkjet -printed  2D-material  active  heterostructures  with 
graphene and hexagonal -boron nitride (h -BN) inks, which 
are used to fabricate an inkjet -printed flexible and wash - 
able field -effect transistors on textile. Such advancements  
in textile based FETâ€™s bring the capability to incorporate textile  threshold level  gates  enabling  the possibility  of vary- 
ing threshold levels for the various neural nodes in a fabric 
spiking neural network.  
 
Hodgkin and Huxley neuron model  is a more  complex model 
to replicate the generation of an action potential of a neural node. The model can describe the time behavior of the 
membrane  potential and currents  through potassium  (K) and 
sodium (Na) channels using differential equations[Fig 4. 
They  were  able to observe  the generation of action  potential 
as well as the refractory period [21]. In this circuit the capacitor is representative of the cell membrane, the circuit 
has variable resistors that represent the voltage -dependent 
K+ and Na+ conductanceâ€™s and there is also a fixed resistor 
representing the voltage -independent leakage conductance. 
This model has three power batteries for the reverse po - 
tentials for the corresponding conductanceâ€™s. Generation of 
this model in a fabric environment would require the tex-  
tile resistor and capacitor as well as the requirement for a 
variable resistor interconnected using co nductive thread. To 
date variable textile resistors have been created in the form 
of fabric based potentiometers.Such fabric potentiometers 
contain a conductive wiper function as well as a resistive 
track where its ends has measurement points included. The  
conductive wiper acts as a means to set and measure a variable  resistance through  adjustment of the sliding  wiper.  
[49] detail and demonstrate a zipper based potentiometer. 
Other variable resistance elements that could be considered 
to produce such a vari able resistor include include Eeonyx 
Stretchy Variable Resistance Sensor Fabric ( Adafruit) that 
can be utilised to make soft sensors that are required to be 
movable and adaptable. Such stretch fabric sensors using 
stretchable conductive fabric enables chan ges in resistance 
when  stress  is applied.Further  research  is required  into how textile and fabric based variable resistance can be leveraged and potentially be utilised in the design of a fabric neural 
node.  
 
 
FIGURE  4. Hodgkin  and Huxley  electronic  Artificial  neural  node 
 
Key textile components are in existence to enable the 
creation of a fabric base Hodgkin Neural Node, how such 
elements can come together from a design perspective to 
produce  a working  neural  node  is the key challenge  here 
in order to produce a working Hodgkin and Huxley Neural 
node.  
 
2) Etextile  Artificial  Fabric  synapse produce  a working  neural  node  is the key challenge  here 
in order to produce a working Hodgkin and Huxley Neural 
node.  
 
2) Etextile  Artificial  Fabric  synapse 
Current learning in SNN are dependent on the capability to alter and interchange  the synapse  weights  for each of the neu- 
ral network nodes.  When  a neuron threshold is reached  it fires 
and produces  an action  potential.  This is a result  of the sum of 
excitatory and inhibitory potentials and these are connected to the neuron through the synapse. We refer to the synapse as a synaptic  weight.  This is the strength  of a connection be- 
tween  two nodes  in a neural  network.  [25] focus  on non-static 
neural  networks  at a signficant distance  from  each other  and 
how through their implementation of an all -optical synapse 
stemming  from  wavelength  division multiplexed  visible  light 
communications  can overcome  real-time weight  adjustments.  
[52] investigated yarn coated with reduced graphene oxide (RGO) to produce two -terminal memristor -based artificial 
synapses  suitable  for use in wearable neuromorphic  comput - 
ing systems. [53] researched the design and development of 
a one-dimensional  organic  artificial multi- synapses  enabling 
electronic  textile  neural  network  for wearable neuromorphic 
applications, where the multi- synapses comprising of ferro-  
electric organic transistors fabricated on a silver ( Ag ) wire.  
To replicate a SNN in a fabric environment we need to 
consider  the functionality  required  for the synapse  and how to 
embed this in a workable manner into a fabric environment. 
As the weight influences the fir ing of a neuron, in a SNN,  
at a basic level this can be replicated by embedding the option to be able to connect  and interchange  from  one 7   
  
TABLE  1. Types  of Neural  Network  more  relevant  to SNNâ€™s  
 
SNN  Type  Data  Flow  Memory  Prediction  Weights  
FeedF  orward  Input  to 
Output  No Memory  Poor Weight  matrix  
inputs,  
produces  
output  
Recurrent  Looping  
Information  
cycles  Has 
Memory - 
learns  Good  Weights  
applied  current  
and previous  
inputs  
 
 
conductive  thread -based  resistor  in a fabric  environment 
to another conductive thread resistor. Such textile resistors 
can in turn be utilized as synaptic fabric -based weights. 
Further  advancements  with the introduction  of memristors  as 
synaptic weights are emerging and need to considered from a fabric  synapse  implementation  point  of view,  these  will be 
covered in section 5 neuromorphic computing properties.  
 
 
3) Etextile  Artificial  Fabric  Spiking Neural  Network  
There is multiple types of neural networks percept ron, 
multilayered perceptron, feed -forward, recurrent, fully con - 
nected, Convolution, Radial Basis Functional,Long Short - 
Term Memory (LSTM), Sequence to Sequence Models and Modular  Neural  Network.  Table  1 provides  an overview  of a 
Feed -forward  and re-currant neural  network  properties  of rel- 
evance when  considering a SNN  type to adopt  and conform  to 
[42][43][44]. When designing an embedded neural network in a fabric environment key fabric and end user properties need to be accounted for including aesthetics, durability, 
comfort and maintenance. Based on the overall size of the 
SNN  and the number  of hidden layers  it incorporates,  this de- 
ciphers the number of textile artificial neural nodes,synapse interconnections and interconnected fabric multi -layers re-  
quired.  
We can then begin to investigate  the best possible  design, 
layout and functionality integration methods around how to 
accommodate and embed into a fabric environment.  
 
B. SPIKING  NEURAL  NETWORK MONITORING/ 
MEASURING  
A SNN  can learn  by supervised learning,  where  you have  an 
input  and an output  variable  and the algorithmic  computation 
within  the neural  network  learns  from  a training  dataset,  once 
an acceptable level of performance is achieved the learning stops. An unsupervised method in comparison has input 
variables but no output variables that are used to support 
training  and learning  of the neural  network.  [24] present 
an overview of the varying training methods for SNNâ€™s  
such as conventional deep networks, constrained training , 
spiking variants of back- propagation and variants of Spike 
time dependant  plasticity  (STDP)  in order  to categorise SNN 
training methods and also highlight their advantages and 
disadvantages.  Creating  such a training  or learning  process  in 
a fabric  etextile  is a challenge that has not yet been  achieved.  The use of nanotech is the obvious initial best approach to 
attempt to embed such a learning element into an intelligent 
fabric garment.  
Depending on the structure of a SNN, this identifies its 
classificatio n. For this paper we will focus on a fully con-  
nected  multi- layer  neural  network.  Such  a multilayered  Spik- 
ing neural network consists of multiple layers of artificial neural nodes (usually has three of more layers and utilizes a 
nonlinear activation function). From a design perspective in a fabric  environment  once  we have  identified  the core textile 
components required to implement a working neural node  
as well as a functional method for interchangeable synaptic 
weights,  the next step is to progress  towards  the identification 
of a most  practical  and feasible fabric -driven  design in order 
to incorporate  multi- layers,  their interconnections  and how to 
be capable  of validating  and modifying during the execution 
phase.  
Several layers of fabric woven and stacked produces a 
multilayer  fabric,  secured  together  with connecting yarns 
in a third (Z direction) dimension. Such woven fabrication phase.  
Several layers of fabric woven and stacked produces a 
multilayer  fabric,  secured  together  with connecting yarns 
in a third (Z direction) dimension. Such woven fabrication 
techniques  along  with layered  and interwoven  fabric  manip - 
ulations  are design options  that need to be assessed  to identify 
suitable  and best practice  design  for the development  of SNN 
technical  textiles  [Fig 5]. Weaving  multiple  layers  in a fabric 
provide the opportunity to embed neural network nodes and interconnected neural networks in an embedded fabric en-  
vironment . Research into best approach ,best methodology to adopt and also core components and their re -usability  
still remain under investigation, but as textile c omponents 
and intelligence along with nanotechnology advances, new opportunities are emerging pushing towards this vision of a 
Fabric AI Driven intelligence. In section 5 we will delve a 
little further into 2D/3D stacked layered techniques taking 
inspiration from neuromorphic computing and advancements 
here.  
 
 
 
FIGURE  5. Multilayered conceptual  design approaches  inspired by stacked 
neural  networks 8   
  
TABLE  2. Neuronal  Information  Encoding  Types  
 
Coding  Type  Details  
RateCoding  Rate of spikes  in a set time interval.Can  
be used at single  neuron  level  or interpre - 
tation spike trains.  
BinaryCoding  A neuron  is active  or inactive  in a set 
time interval.It  fires 1 or more  spikes  
within that timeframe.  
T imetofirstspikecoding  Method  is used to encode  information  
for fast responses  ( in milliseconds).  it is 
based on first -spike patterns).  
FullyT  emporalcoding  Precise  timing  of all spikes  generated  
are part of the encoding.  Timings  are 
important.  
PhaseCoding  Convert  inputs  into binary  representa - 
tions (eg a â€™1â€™ equals a spike gener - 
ated).Information is added by assigning  
different  weights  to each bit represented  
in the phase  
BurstCoding  A burst  of Spikes  (Short  and High  fre- 
quency  of Train  of spikes).Assessment  of 
the number  of pattern  of spikes  in a burst  
coding  
Latencycoding  Number  of spikes  is not the prior- 
ity,instead  the time between  an event  and 
when  the first spike  triggers  is important.  
Stimulus is encoded based on a rank - 
order  where  neurons  in a group  generate  
their first spikes  
 
 
C. SPIKING  NEURAL  NETWORK  COMMUNICATIONS  
SNN drives the adoption of brain- inspired computing, pro-  
viding not only fast but also a large substantial amount of 
event -driven data processing. An SNN neural computation 
and communication is defined through the generation of spikes enabling neurons to communication from one to an - 
other via such triggered spikes. Research is ongoing around the types of neuronal information encodingâ€™s.[29]  summarise 
the signal encoding schemes for a spiking neural network. 
Neuronal  encoding and decoding is the information  and com- 
munication process where for example an external variable or stimulus triggers neural activity within the brain. Such 
stimuli (e .g touch stimuli) produce varying neural activity 
patterns in the brain.[27] provides an overview of neural 
coding with bursts and new methods for their analysis. [28] 
introduce spiking autoencoders with temporal coding and 
pulses, trained using backpropagation to store and recon - 
struct images with high fidelity from compact representa - 
tions.  
Classification of the spike train pattern and what this 
means, enables active decoding of the pattern. One such example is the classification of spike train through active 
matching of the spike train patterns to templates. Such a 
template  would be a set word,  meaning  or result.  Within 
an etextile  world  neural  information  encoding,  decoding and 
the creation and validation of potential Fabric SNN clas - 
sification templates mapping to external sensing embedded 
textile sensors linked to fabric based neural networks, could 
enable the communication and processing of fabric based 
SNN encoding. Such Fabric SNN classification templates 
could correspond to an alert notification  raising  awareness  around a critical health monitoring scenario where such a 
template could be used in conjunction with a SNN fabric 
Smart garment to assess the health status and provide feed - 
back to the wearer based on the use of such classification templates to raise alerts to the wearer as required. Core to 
the fundamental working of a SNN is the manner in which 
the network nodes interconnect and how information flow s 
and communication between the nodes is enabled. Multiple 
artificial neural  network types  exist.  [26] provides  a compar - 
ative overview of neural coding in a spiking neural network with in-depth detail  on rate coding,  time-to-first spike  (TTFS) 
coding, phase coding, and burst coding. Table 2 provides a substantial list of the types  of neuronal  information  encoding 
techniques utilised  to-date for consideration. It highlights 
their key elements for consideration when investigating the potential for Fabric -driven SNN neuronal encoding and de - techniques utilised  to-date for consideration. It highlights 
their key elements for consideration when investigating the potential for Fabric -driven SNN neuronal encoding and de - 
coding.  
 
D. SPIKING  NEURAL  NETWORKS  ENERGY 
CONSIDERATIONS  
Spiking neural networks bring the promise  of enhanced en - 
ergy efficiency. As an SNN is a dynamic system this suits more  dynamic  driven processes  and applications.  Research  is 
ongoing to investigate  how to effectively  lower  synaptic  oper- 
ations  and hence the computational  performance of the neural 
network.  [50] focus  on the optimization  of energy  consump-  
tion of SNN  for neuromorphic  applications  through a hybrid 
training  strategy  that also accounts  for energy  cost stemming 
from  the networks  computations.  From  a structure  and archi - 
tectural  point  of view  SNN  have  typically  fewer  neural  nodes 
than more  traditional artificial neural  networks  along with the 
fact that SNN  can implement â€™ node  connection pruningâ€™[Fig 
6] in order to reduce processing power and improve overall 
the working functionality  and energy  efficiency  of the SNN.  
[30] develop  a pruning method  for SNNs  by exploiting  the 
 
 
 
FIGURE  6. Difference conveying no pruning in SNN versus  pruning  in SNN 9   
  
output  firing  characteristics  of neurons,  which  can be applied 
during network training. [31] detail the process of pruning 
STDP- based connections as well as quantizing the weights 
of critical synapses at regular intervals during the training process. They validate a classification accuracy of 90.1 per- 
cent and show an improvement in energy efficiency. When implementing  a SNN  in a textile  environment,  the capability 
to be able to disconnect and reconnect fabric neural nodes 
needs  to be considered in order  to be able to prune  the Fabric 
SNN  in an efficient  manner  enhancing  the fabric  SNN  energy 
operational  functionality.  From  a computational  point  of view 
the SNN  has the capability  to operate more  quickly  due to the 
neurons sending spike impulses. As SNNâ€™s adopt temporal 
information retrieval this increases the overall processing 
time and productivity and hence has a very positive end impact on energy consumption in the SNN.  
 
V. NEUROMORPHIC COMPUTING  PROPERTIES  
Neuromorphic computing concept originated in the 1980â€™s. Taking inspiration from computer science, mathematics to 
bio-inspired  models  of neural  network.  This emerging  inter- 
disciplinary research field has the potential to disrupt tradi - 
tional computing methods  and architectural  implementations 
leading to a mor e centralized and combined memory and 
computational driven approach, moving away from the von Neumann architectural approach with separate memory and 
computing capabilities  and high compute  power  needs.  Such 
inspiration coming from the working of the human brain 
paves the way for new and more fault tolerant layered and 
parallel architectural designs and layouts.  
 
 
FIGURE  7. Timeline  of technological  advancements  in Neuromorphic  
Computing  In order to understand what aspects of neuromorphic 
computing can inspire innovative advancements in the next generation of smart etextiles and on -garment edge based 
intelligence,  we will first highlight  the core key architectural 
elements  of importance  within neuromorphic  computing  and 
assess  their potential within  an etextiles  domain.  Neuromor - 
phic computing core architecture  is based  on the concept 
of communicating through event driven spikes generated 
through simple  processing structures  represented  by synapses 
and neurons. Ongoing research is pushing the production 
possibilities using complementary metal oxide semiconduc - 
tor (CMOS) technology to develop neuromorphic spiking 
neural  network hardware  implementations  [45][46][47].  Key 
properties  such as size, weight,  low power  consumption,  and 
modular design (scalability) are dominating the research 
areas of focus linked to such technologies. Over the years 
advancements in CMOS technology has driven smaller and 
more power efficient systems with the capabi lity to mass 
produce.  Such  technology combined  with advanced  machine 
learning techniques has directly lead to the simulation and 
implementation of silicon based neurons, otherwise defined 
as neuromorphic computing.  
[Fig 7] highlights advancements, with Bra inchip 
(https://brainchip.com/) announcement in 2022 claiming to 
be the worlds first commercial producer of a Neuromorphic 
AI processor â€˜Akida â€™ that has the capability to mimic the 
working of the human brain and process data with high 
precision  and energy  efficiency.  Akida  being  an event -based 
AI neural processor featuring 1.2 million neurons and 10 billion synapse . 
 
A. NEUROMORPHIC COMPUTING  COMPUTATION  
1) Crossbar  Array  Architectural  Properties  
As neuromorphic computing moves away from the tradi - 
tional Von Neumenn  architecture towards  a more  focused  in- 
memory computational architecture, the processing occurs 
inside the memory functionality elements, hence reducing 
data transfer  time and energy.  Hardware  architectural  design 
considerations  need  to take into account  1) synapse  intercon - inside the memory functionality elements, hence reducing 
data transfer  time and energy.  Hardware  architectural  design 
considerations  need  to take into account  1) synapse  intercon - 
nections between neural nodes and 2) how this can be im - 
plemented  in order  to complete a fully connected  neural  net- 
work . From  a hardware design perspective the cross bar array 
architecture has been  adopted in neuromorphic  computing in 
order to implement a full complement of interconnections 
required for to meet the neural network structure require - 
ments. The cross bar array architecture includes a number  
of rows (word lines) and columns (bit lines) with memory 
devices interconnected between both the row and column. 
Advancements have been made through the development of 
resistive  memory  devices  known as memristors  (one transis - 
tor and 1 resistor combination).  The operational  functionality 
of the crossbar  array  is based  in input  current  (voltage  pulse ) 
to selected rows which in turn activates selected columns  
via a voltage pulse, depending on the activation of varying 
cells in the crossbar array. For active cells in a particular 
row/column vertical  line in the crossbar  array,  the sum of 10   
  
TABLE  3. Taking  Inspiraton  from SNN  and Neuromorphic  advancements,  highlighting  key considerations  to feed into future  etextile neural  network  research  and 
prototypes  
 
Human Brain - NN properties/Neuromorphic Computing  Properties  Inspired Etextiles  Considerations  
Synapse /Memristor: component  that regulates  electric  current  flow remem - 
bering  the previous current flowthrough.  
 
  
 
 
 
 
 
Soma /Neuristor:  Device  to capture  the properties  of a neuron,  Spike  or 
impulse generation when threshold reached.  How to represent weights in a fabric environment to simulate synapse  
interconnections between fabric -based neurons. Conductive thread -based  
resistors, surface mount devices or nanodevices in a fabric environment to  
simulate the workings of the synapse weights. Interchangeability of these  
weights in a fabric environment need  to be considered and generation of a  
new method and fabric -based process around how to design , develop and  
validate. How to embed in a workable manner a wearable memory aspect  
in a fabric environment, in a seamless functioning manner. What would a 
fabric  based memristor look like, how could this be completed and validated  
in a fabric environment.  
 
Replication of a Neuron in a fabric environment.Take inspiration from  
current electronic artificial neurons (LIF, Hodgki  Huxley).Considerations  
around how to create textile and fabric -based components to replace hard  
component elements (conductive thread -based resistors, textile- based ca-  
pacitors).  The aim being  to investigate  the most  suitable  way to create  
a working fabric neuron but with limited hard components instead using  
textile  versions.  
 
 Axon /Circuit  interconnections  and signal  conditioning.  In order  to maint ain the  focus  on a textile -based  implementation  the use  of 
conductive  thread  (embroidered  conductive  thread  neuron  interconnections  
design  pattern)  as a means  to easily  reproduce  and create  such fabric  neuron  
interconnections.  
Dendrite /3D architectural design implementation, pattern detection and sub  
threshold  filtering.  
 
 
Fan In,Fan  Out/Implemented  using  crossbar  array,  but this has limitations  
with regard scaling. Higher radix interconnections are being considered.  
(Loihi2 pr ovides faster and higher radix interfaces).  Taking  inspiration  from  the 3D architectural  design  used in Neuromorphic  
computing , can this motivate and inspire new 3D fabric manipulation and  
3D fabric layering type designs in a garment structure , to embed and  
interconnect such fabric driven neural network functionality.  
Conductive  thread,  with insulation  bridges  to eliminate  short  circuits  in 
a fabric environment , can be utilized to embed such a crossbar array  
design in a textile environment. Dependi ng on the type of synapse utilized 
( conductive thread resistor, SMD resistor, memristor or other) a physical  
connection to this synapse type will need to be considered to assess best  
approach in order to interconnect to the fabric -based crossbar array.  
 
 
 
 
 
FIGURE  8. Conceptual  Jacket  design  with embedded neural  network  using  
crossbar array architectural design.  
 
 
currents  equals  the output  current,  calculated  using  Ohms  law 
and Kirchhoffâ€™s  law. Research  into memristor  crossbar  arrays 
for brain inspired computing neural networking has been 
investigated and summarised by [35]. [54] report a 64x64 
passive crossbar circuit that demonstrat es approximately 99 
percent  nonvolatile  metal -oxide  memristors,  enabling  the ac- 
tive storing  of large  neural  network models  on neuromorphic  chips.  
From a functionality and design perspective, how can 
inspiration be taken and mapped to an etextiles fabric envi - 
ronment in order to progress towards an embedded neural From a functionality and design perspective, how can 
inspiration be taken and mapped to an etextiles fabric envi - 
ronment in order to progress towards an embedded neural 
network. The crossbar row/column structure design is a key element to consider, how ca n this architectural design be 
accommodated  in a fabric  material  in order  to recreate such a 
neural  network [Fig 8]. Can embroidery based  techniques  and 
patterns using conductive thread , fabric tape or embedded woven conductive elements into a fabric envi ronment be 
experimented with in order to recreate such a crossbar array 
type architectural  structure  in a fabric  material.  This is a key 
design element for further exploration and research.  
 
B. NEUROMORPHIC COMPUTING MONITORING/ 
MEASURING  
Memristors also known as resistive  switching  random  access 
memory devices that have the capability to change their re - 
sistance  state and act as non volatile  memories  for embedded 
memory based devices are showing promise in the neuro - 
morphic  world  as key components  to implement  high-density 
memory.  Properties  of memristors  include  small  device/high 
density integration, low power, high speed and highly scal - 
able( Zhang et al., 2020). New research is focusing on the 
potential to enable  controls  for resistive  filament switc hing in 
synapse  applications, as well as further investigation  around 11   
  
varying  memristor  materials  for artificial synapses  with spe- 
cific focus on the synaptic behaviors of organic materials, 
2D materials, emerging materials ( halide perovskites ) and 
low-dimensional materials [33][34].The memristor is very 
suitable for analog based circuits as well as hardware multi - 
state neuromorphic appli cations due to its high and low 
resistance state. Interconnections between the neural nodes 
in the human brain have a joint strength represented by the 
synapse. Memristive synapses are ideal candidates to create 
an artificial synaptic  device helping it mimic interconnection 
strengths  between  artificial neural  nodes.  A core requirement 
is the need to enable and alter resistance states. When we 
consider  fabric  smart  material,  how wearable memory  can be 
incorporated into a fabric environment is a key element t hat 
requires extensive investigation and research. Taking inspi - 
ration from memristor -based analog memory circuits, what 
properties  and elements  need  to be considered  when  consid - 
ering the link between fabric materials and the application 
functionality.A nalog memristors  exhibit  a gradual  change  in 
resistance and hence  are more  suitable  for analog  circuits  and 
neuromorphic  system  applications.  Bi-stable  memristors  act 
as binary memory/switches and digital logic circuits. Multi-  
state memistors are used as multi -bit memories, reconfig - 
urable  analog  circuits,  and neuromorphic  circuits  [32].Ames 
Research Center in California have implemented a method 
of weaving flexible computer memory into garments. This 
flexible memory is woven together using strands of copper and copper -oxide  wires.  [57] demonstrate  advanced  research 
into the development  of a textile  memristor  using  a robust  fi- 
bre through an electric  field assembly  method that weaves  the 
fibres  into a scalable  textile  memristor.  This exciting  research 
era will see advances through the fusion of nanotechnology level memristor devices.  
 
C. NEUROMORPHIC COMPUTING  COMMUNICATIONS 
AND ENERGY EFFICIENCY  
Building  on the crossbar  array  design,  neuromorphic  chip ad- 
vancements  look to implement energy  efficient  lower  power 
consumption  architectures  supporting  the required  precision 
communication. In order to accomplish this research is on - 
going around the design and development of smaller and 
multiple arrays. Such multiple arrays are emerging as either 
having a lateral 2D layout or a 3D vertical stacking layout. 
Circuit designs  are required  to be efficient  in order  to enable 
data flow between each layer in such 3D pas sive arrays. 3D 
memristive  neural  networks  are taking  inspiration  from  string 
stacking for 3D NAND flash (Xia et al).  
From  a design perspective when  considering how to embed 
a multilayered neural network in a fabric environment, it is 
vital to consider key properties of the fabric as well as key 
design and usability  functionality  requirements  for end users. 
We already  touched  on possible  layered  and woven concep - 
tual design layout  approaches  in [Fig 5], but if adopting a 3D 
stacked  layered  fabric  approach,  how we can interconnect  the 
layered neural node connections also need to be considered. 
How do we interconnect  from  one fabric  layer  to another  fabric layer in an energy efficient, low power and reduced 
size capacity to ensure a high operational  standard for the 
fabric  based  neural  network.  A modular  fabric  design- based 
approach with inter -changeable neural nodes and hidden 
neural  layers  may prove  to be a more  suitable  option availing 
of the capability to interconnect, remove and replace neural 
nodes  using for example  snap connectors  or other  connector 
method options as described in [36].  
 
VI. AI TEXTILE  INTELLIGENCE  USE CASE  EXAMPLES  
Embedded AI intelligence in a fabric based environment method options as described in [36].  
 
VI. AI TEXTILE  INTELLIGENCE  USE CASE  EXAMPLES  
Embedded AI intelligence in a fabric based environment  
has the potential to be applied across many sector based 
applications. Here we briefly provide 2 such examples in 
order to convey the possibilities of such an advanced fab - 
ric computing and fabric AI intelligence driven era, 1) the 
healthcare/rehabilitation sector application space and 2) the 
unman ned aircraft/drone sector where textile -  driven drone 
control intelligence applications could be exploited.  
 
A. HEALTHCARE  AI SMART  TEXTILE  USE CASE  
Smart  garment  applications  can greatly  contribute  towards  re- 
mote monitoring, where individual and personalised health-  
care provides enhanced real time assessment and early in - 
tervention. Embedded seamless AI in a textile environment adds another layer of real time intelligent wearable point of 
care going beyond c urrent state of the art. The application  
of AI intelligence in a fabric wearable environment bring  
the potential for enhanced quality of life for end users. Here 
we provide two such conceptual end user -centric scenario 
examples.  
â€¢ Aisling  is concerned  about  getting  a variant  of COVID - 
19 and is looking for a new means  to be able to monitor 
and track her general health without it impacting on  
her daily  activities.  Aisling  purchased  an AI monitoring 
package ( textile sensors and Fabric AI patch intelli - 
gence)  that can be fitted  in a modular  manner  into 
her latest modular clothing garment. Aisling now has 
embedded  artificial  intelligence  in her everyday  clothing 
and can monitor  her breathing and temperature,  analyse 
the data in real time and be alerted about abnormali - 
ties that occur, allowing her to respond in an efficient manner,  detect  symptoms  early,  take a COVID test and 
restrict her movements if needs be.  
â€¢ Jim suffers from Epileptic seizures. He was diagno sed 
as having tonic -clonic seizures which cause symptoms 
such as his muscles to stiffen, reduced breathing capa - 
bility, loss of consciousness (prone to falls) and rapid 
jerking  of the arms  and legs. Due to not knowing  when 
such a seizure can occur, Jim has become very anxious 
about leaving the house on this own to run errands. 
This has a huge impact on Jimâ€™s quality of life. Jimâ€™s 
doctor introduced him to the wearable modular smart 
AI garment with interchangeable Fabric AI embedded, 
that can help monitor Jimâ€™s temperature, breathing and 
selected arm/leg muscle Electromyography (EMG) re - 
sponse through embedded textile based sensors in the 12   
  
 
 
FIGURE  9. Core  building modules  and emerging technologies  that are contributing towards  the next smart  textiles  generation incorporating Fabric  AI inspired  
e-textiles.  
 
wearable modular  garment  interconnected  to a Fabric  AI 
neural  network computational  interchangeable  patch.  If 
Jim wears this garment when leaving the house to run 
his errands,  the sensors  will monitor  his measurements, 
depending on the assessment completed via the Fabric 
AI neural network patch, this can decipher in real time 
if Jim is in a pre -seizure state or not. I t was explained 
to Jim that this analysis  is completed  in the intelligence 
embedded in the core fabric and yarn of the garment 
and is not visible to the human eye. If a pre -seizure 
state is detected a simple visual alert via an embedded 
light alert system  in the sleeve of jims garment  will alert 
him to the pre -seizure and give jim time to try to find  
a safe zone in an attempt to reduce potential falls and 
injuries. In parallel the embedded fabric AI would also 
raise the alert externally  to Jims carer,  informing them  of 
the pre-seizure  state.  This form  of monitoring  provided 
the wearer with a sense of e mpowerment and control.  
 
B. TEXTILE -DRIVEN DRONE  CONTROL  USE CASE  
The application of etextiles across multiple domains and 
sectors is gaining traction. New innovative ideas extending beyond the norm of healthcare are starting to be considered and emerging.  Advances  in fabric  based  AI intelligence  open 
the opportunity to extend  applications  of etextiles  fusing non 
traditional techniques  and new technologies.  An example  of 
one such area is the application and use of a based fabric textile  intelligence  with unmanned  Ariel vehicles  (UAV).  the 
following provides example use cases for consideration  â€¢ Taking a modular designed dynamic field pro - 
grammable or Fabric AI -driven smart garment with in - 
telligent embedded  control  logic  functionality  [55][58], 
opens up opportunities towards the use of such a smart 
garment as a control device of the UAVâ€™s based on 
human  control  activated  movements  linked  to the smart 
garment triggering smart textile sensors as actuators directing the movement and control of the UAV. Such 
fabric  AI driven haptic  wearable devices  can have  mul- 
tiple applications for varying devices providing a more seamless embedded control options for end users. This 
has numerous innovative applications in construction, 
defence and more.  
 
VII. CONCLUSION  
Its evident  that AI driven technology advancements  are mov- 
ing at a rapid pace. Vast research stemming from architec-  
turally inspired specification and design properties of SNN and neuromorphic computing provide valuable inspiration 
towards new techniques, methodologies and designs that  
can be applied across to d rive emerging innovations in the 
etextiles  domain.  This paper  has delved  into key architectural 
properties of SNN ( artificial neurons and synapses )as well 
as neuromorphic  computing (cross  bar analysis,  memristors, 
stacked and layered design based approache s) to stem such 
experimental research avenues.Table 3 and [Fig 9] provide  
a summarised visual of core aspects to inspire and drive  
new and novel innovations in the next generation fabric AI inspired etextiles. 13   
  
Continued research is required in this area. Key research 
questions  and challenges  still remain  unanswered  hence  val- 
idating  the need for further research in this space. Such 
challenges and future research investigations include the 
following  
â€¢ Advancements  in the specification,  design and verifica - 
tion of Fabric AI.  
â€¢ Consideration around the identification and develop - 
ment of a  Fabric AI based development language.  
â€¢ Investigation  into how AI algorithms  can be embedded 
in an operational manner in a Fabric AI environment.  
â€¢ In a textile  environment  what  methods  or processes  can 
be applied to enable ML based data abstraction and proce ssing.  
â€¢ Specification  and formalisation  of textile  driven  proper - 
ties to support fabric AI systems.  
â€¢ The need for further investigate research around the 
verification of Fabric AI approaches delving into trust - 
worthy and explainable Fabric AI.  
AI technologies  have  developed  at a much  quicker  pace over 
the past few years,  its now time for the etextiles  domain 
to embrace such advancements and build on core defined elements and properties in order to stem new and exciting 
research driven innovations in the etextiles domain.  
 
REFERENCES  
[1] Hong,  Y., Zeng,  X., Brunixaux,  P., Chen,  Y. (2018).  Evaluation  of Fashi on 
Design Using Artificial Intelligence Tools. In Artificial Intelligence for  
Fashion Industry in the Big Data Era (pp. 245 -256). Springer, Singapore.  
[2] Banumathi, D.P., Sree, T.S.,  Priya, S. (2015). Artificial Intelligence  
Techniques in Textile Fabric Inspe ction.  
[3] Hanbay, K., Talu, M. F.,  Ã–zgÃ¼ven, Ã–. F. (2016). Fabric defect detection  
systems and methods â€”A systematic literature review. Optik, 127(24),  
11960 -11973.  
[4] Yuldoshev, Nuritdin Tursunov, Bobir  Qozoqov, Saidmuhtor. (2018).  
Use of artificial intelligence methods in operational planning of textile  
production.  Journal  of Process  Management.  New Technologies.  6. 41-51. 
10.5937/jouproman6- 17221.  [5] Jiang, Siqi Stange, Oliver  BÃ¤tcke, Fynn  Sultanova, Sabina  Sabantina,  
Lilia.  (2021).  Applications of Smart  Clothing â€“ a Brief  Overview.  Commu - 
nications  in Development  and Assembling  of Textile  Products.  2. 123-140. 
10.25367/cdatp.2021.2.p123- 140. 
[6] Shi J, Liu S, Zhang L, Yang B, Shu L, Yang Y, Ren M, Wang Y, Chen J,  
Chen  W, Chai  Y, Tao X. Smart  Textile -Integrated  Microelectronic  Systems  
for Wearable Applications. Adv Mater. 2020 Feb;32(5):e1901958. doi: 
10.1002/adma.201901958. Epub 2019 Jul 5. PMID: 31273850.  
[7] Loke, G., Yan, W., Khudiyev, T., Noel, G.,  Fink, Y. (2020). Recent  
progress and perspectives  of thermally drawn  multimaterial  fiber electron - 
ics. Advanced Materials, 32(1), 1904911.  
[8] Park, S., Loke, G., Fink, Y.,  Anikeeva, P. (2019). Flexible fiber -based  
optoelectronics for neural interfaces. Chemical Society Reviews, 48(6),  
1826- 1852.  
[9] Rajan,  Krishna,  Erik Garofalo,  and Alessandro  Chiolerio.  2018.  ""Wearable  
Intrinsically Soft, Stretchable, Flexible Devices for Memories and Com - 
puting"" Sensors 18, no. 2: 367. https://doi.org/10.3390/s18020367 
[10] Zeng,  W., Shu, L., Li, Q., Chen,  S., Wang,  F. and Tao, X.-M. 
(2014), Fiber -Based Wearable Electronics: A Review of Materials,  
Fabrication, Devices, and Applications. Adv. Mater., 26: 5310-5336.  
https://doi.org/10.1002/adma.201400633 
[11] Loke, Gabriel  Khudiyev, Tural  Wang, Brian  Fu, Stephanie  Payra, 
Syamantak Shaoul, Yorai Fung, Johnny Chatziveroglou, Ioannis Chou,  
Pin-Wen Chinn, Itamar  Yan, Wei  Gitelson-Kahn, Anna  Joannopou - 
los, John  Fink,  Yoel.  (2021).  Digital  electronics  in fibres  enable  
fabric -based machine -learning inference. Nature Communica tions. 12.  
10.1038/s41467 -021-23628 -5. 
[12] FernÃ¡ndez -CaramÃ©s, Tiago M., and Paula Fraga -Lamas. 2018. ""Towards  
The Internet  of Smart  Clothing: A Review  on IoT Wearables  and Garments 10.1038/s41467 -021-23628 -5. 
[12] FernÃ¡ndez -CaramÃ©s, Tiago M., and Paula Fraga -Lamas. 2018. ""Towards  
The Internet  of Smart  Clothing: A Review  on IoT Wearables  and Garments 
for Creating Intelligent Connected E -Textiles"" Electronics 7, no. 12: 405.  
https://doi.org/10.3390/electronics7120405 
[13] Pelin Yildirim Taser, Vahid Khalilpour Akram, Machine Learning Tech - 
niques  for IoT-Based  Indoor  Tracking and Localization,  Emerging Trends  
in IoT and Integration  with Data Science,  Cloud  Computing,  and Big Data 
Analytics, 10.4018/978 -1-7998 -4186 -9.ch007, (123-145), (2022).  
[14] Li, Jun Li, Yafei Li, Lingmin He, Xiaokang Fu, Jingjing Chen, and  
Xiaokang Zhou. 2021. Fabric Defect Detection in Textile Manufacturing: 
A Survey of the State of the Art. Sec. and Commun. Netw. 2021 (2021).  
https://doi.org/10.1155/2021/9948808 
[15] Taherkhani  A, Belatreche  A, Li Y, Cosma  G, Maguire  LP, McGinnity TM. 
A review of learning in biologically plausible spiking neural networks.  
Neural Netw. 2020 Feb;122:253 -272. doi: 10.1016/j.neunet.2019.09.036.  
Epub 2019 Oct 11. PMID: 31726331.  
[16] Koch, C., Segev, I. (Eds.). (1998). Methods in neuronal modeling: from  
ions to networks. MIT press.  
[17] Gerstner, W., Sprekeler, H.,  Deco, G. (2012). Theory and simulation in  
neuroscience. Science , 338(6103), 60â€“ 65. 
[18] Izhikevich, E. M. (2003). Simple model of spiking neurons. IEEE Trans - 
actions on neural networks, 14(6), 1569- 1572.  
[19] Andreoni, G., Standoli, C. E.,  Perego, P. (2016). Defining Requirements  
and Related  Methods for Designing  Sensorized  Garments.  Sensors  (Basel,  
Switzerland),  16(6),  769. https://doi.org/10.3390/s16060769  
[20] Qiang, Siyu and Carey, Tian and Arbab, Adrees and Song, Weihua and  
Wang, Chaoxia and Torrisi, Felice(2019), Wearable solid -state capacitors  
based on two- dimensional material all -textile heterostructures,Nanoscale  
journal,Vol 11, Issue 20 .  
[21] Beeman D. (2014) Hodgkin -Huxley Model. In: Jaeger D., Jung R. (eds)  
Encyclopedia of Computational Neuroscience. Springer, New York, NY.  
[22] A. Bonfiglio et al., ""Organic  field effect  transistors for textile  applications,""  
in IEEE Transactions on Information Technology in Biomedicine, vol. 9,  
no. 3, pp. 319 -324, Sept. 2005.  
[23] Carey, T., Cacovich, S., Divitini, G. et al. Fully inkjet -printed two - 
dimensional material field-effect heterojunctions for wearable and textile  
electronics. Nat Commun 8, 1202 (2017).  
[24] Pfeiffer M, Pfeil T. Deep Learning With Spiking Neurons: Oppor - 
tunities and Challenges. Front Neurosci. 2018 Oct 25;12:774. doi:  
10.3389/fnins.2018.00774. PMID: 30410432; PMCID: PMC6209684.  
[25] M. Hulea, Z. Ghassemlooy and S. Rajbhandari, ""A Spiking Neural Net - 
work with Visible Light Communications,"" 2018 11th International Sym - 
posium on Communication Systems, Networks  Digital Signal Processing  
(CSNDSP), 2018, pp. 1 -5, doi: 10.1109/CSNDSP.2018.8471811.  
[26] Guo W, Fouda  ME, Eltawil  AM, Salama  KN. Neural  Coding in 
Spiking Neural  Networks:  A Comparative  Study  for Robust Neu- 14   
  
romorphic Systems. Front Neur osci. 2021 Mar 4;15:638474. doi: 
10.3389/fnins.2021.638474. PMID: 33746705; PMCID: PMC7970006.  
[27] Zeldenrust, F., Wadman, W. J.,  Englitz, B. (2018). Neural Coding With  
Bursts- Current State and Future Perspectives. Frontiers in computational  
neuroscience, 12, 48. https://doi.org/10.3389/fncom.2018.00048 
[28] ComsÂ¸a, I. M., Versari, L., Fischbacher, T., Alakuijala, J. (2021). Spik - 
ing Autoencoders With Temporal Coding. Frontiers in neuroscience, 15,  
712667.  https://doi.org/10.3389/fnins.2021.712667 
[29] Auge, D., Hille, J., Mueller, E.,  Knoll, A. (2021). A survey of encoding  
techniques for signal processing in spiking neural networks. Neural Pro - 
cessing Letters, 53(6), 4693- 4710.  
[30] Shi Y, Nguyen L, Oh S, Liu X, Kuzum D. A Soft-Pruning Method  
Applied During Training of Spiking Neural Networks for In-memory  
Computing Applications. Front Neurosci. 2019 Apr 26;13:405. doi: 
10.3389/fnins.2019.00405. PMID: 31080402; PMCID: PMC6497807.  
[31] Rathi,  N., Panda,  P., Roy,  K. (2019).  STDP -Based  Pruning of Connections 
and Weight  Quantization  in Spiking  Neural  Networks  for Energy -Efficient 
Recognition.  IEEE Transactions  on Computer -Aided Design of Integrated  
Circuits and Systems, 38, 668-677.  
[32] Xu, W., Wang, J.,  Yan, X. (2021). Advances in Memristor -Based Neural  
Networks. Frontiers in Nanotechnology.  
[33] Wang,  Z. Y., Wang,  L. Y., Nagai,  M., Xie, L. H., Yi, M. D., Huang,  W., 
Adv.  Electron. Mater.  2017, 3,  1600510.  
[34] Kim, S. G., Han, J. S., Kim, H., Kim, S. Y., Jang, H. W., Adv. Mater. 
Technol. 2018 , 3, 1800457.  
[35] Xia, Q.,  Yang, J. J. (2019). Memristive crossbar arrays for brain -inspired 
computing. Nature Materials, 18(4), 309 â€“323. 
[36] Castano, L. M.,  Flatau, A. B. (2014). Smart fabric sensors and e -textile  
technologies: a review. Smart Materials and struc tures, 23(5), 053001.  
[37] Sethuraman,  S. C., Kompally,  P., Mohanty,  S. P., Choppali,  U. (2021).  My- 
Wear: A novel smart garment for automatic continuous vital monitoring.  
IEEE Transactions on Consumer Electronics, 67(3), 214 -222. 
[38] Ali, N. A.,  Abu-Elkheir, M. (2015, October). Internet of nano -things  
healthcare applications: Requirements, opportunities, and challenges. In  
2015 IEEE 11th International Conference on Wireless and Mobile Com - 
puting, Networking and Communications (WiMob) (pp. 9 -14). IEEE.  
[39] Dong, K., Peng, X., Wang, Z. L. (2020). Fiber/fabric -based piezoelectric  
and triboelectric  nanogenerators  for flexible/stretchable  and wearable  elec- 
tronics and artificial intelligence. Advanced Materials, 32(5), 1902549.  
[40] Xu, K., Huang,  J., Ye, Z., Ying,  Y., Li, Y. (2009).  Recent  development of 
nano -materials used in DNA biosensors. Sensors, 9(7), 5534 -5557.  
[41] Wood,  J. (2018).  Revolutions in wearable  technology for apparel.  In High - 
performance apparel (pp. 325 -339).  
[42] She, X. (2022). Design and Optimization of Heterogeneous Feedforward  
Spiking Neural Network For Spatiotemporal Data Processing (Doctoral  
dissertation, Georgia Institute of Technology).  
[43] Shen, J., Liu, J. K.,  Wang, Y. (2021). Dynamic Spatiotemporal Pattern  
Recognition With Recurrent Spiking Neural Ne twork. Neural Computa - 
tion, 33(11), 2971 -2995.  
[44] Stoliar, P., Schneegans, O.,  Rozenberg, M. J. (2021). Implementation of  
a Minimal Recurrent Spiking Neural Network in a Solid-State Device.  
Physical Review Applied, 16(3), 034030.  
[45] Davies et al., (2018)""Loihi: A Neuromorphic Manycore Processor with  
On-Chip Learning,"" in IEEE Micro, vol. 38, no. 1, pp. 82 -99. 
[46] A. L. et. al (2018), Loihi Asynchronous Neuromorphic Research 
Chip.24th IEEE International Symposium on Asynchronous Circuits and 
Systems  (ASYNC).  
[47] Cheng,  H., Wen,  W., Wu, C., Li, S., Li, H.H.,  & Chen,  Y. (2017).  
Understanding the design of IBM neurosynaptic system and its tradeoffs: Systems  (ASYNC).  
[47] Cheng,  H., Wen,  W., Wu, C., Li, S., Li, H.H.,  & Chen,  Y. (2017).  
Understanding the design of IBM neurosynaptic system and its tradeoffs:  
A user perspective. Design, Automation & Test in Europe Conference &  
Exhibition (DATE), 2017, 139 -144. 
[48] Chan,  J., Gollakota,  S. (2017,  October).  Data  storage  and interaction  using 
magnetized fabric. In Proceedings of the 30th Annual ACM Symposium  
on User Interface Software and Technology (pp. 655 -663).  
[49] Lindrupsen,  N. (2021).  Exploring  Textile  Controllers  for Computer  Music  
(Masterâ€™s  thesis).  
[50] Sorbaro M, Liu Q, Bortone M and Sheik S (2020) Optimizing the Energy Consumption of Spiking Neural Networks for Neuromorphic Applica - 
tions. Front. Neurosci. 14:662. doi: 10.3389/fnins.2020.00662 
[51] Blecha, T.,  Moravcova, D. (2022, Ma y). Methods for the Capacity In - 
creasing of Textile Capacitors. In 2022 45th International Spring Seminar  
on Electronics Technology (ISSE) (pp. 1-5). IEEE.  
[52] Park,  Y., Park,  M.-J., Lee, J.-S., Adv.  Funct.  Mater.  2018,  28, 1804123.  
https://doi.org/10.1002/adfm.201804123.  [53] Ham S, Kang M, Jang S, Jang J, Choi S, Kim TW, Wang G. One - 
dimensional organic artificial multi -synapses enabling electronic textile  
neural network for wearable neuromorphic applications. Sci Adv. 2020 
Jul 10;6(28) :eaba1178. doi: 10.1126/sciadv.aba1178. PMID: 32937532.  
[54] Kim, H., Mahmoodi, M.R., Nili, H. et al. 4K -memristor analog -grade 
passive crossbar circuit. Nat Commun 12, 5198 (2021).  
[55] Rajappan  A, Jumet  B, Shveda  RA, Decker  CJ, Liu Z, Yap TF, Sanchez  V, 
Preston DJ . Logic -enabled textiles. Proc Natl Acad Sci U S A. 2022 Aug  
30;119(35):e2202118119. doi: 10.1073/pnas.2202118119. Epub 2022  
Aug 22. PMID: 35994641; PMCID: PMC9436326.  
[56] F. Cleary  et al., ""Wearable  Fabric  Brain  Enabling  On-Garment  Edge -Based  
Sensor Data Proc essing,"" in IEEE Sensors Journal, vol. 22, no. 21, pp.  
20839 -20854, 1 Nov.1, 2022, doi: 10.1109/JSEN.2022.3207912.  
[57] Liu, Y., Zhou,  X., Yan,  H., Zhu, Z., Shi, X., Peng,  Y., Chen,  L., Chen,  
P., Peng,  H., Robust Memristive  Fiber  for Woven  Textile  Memristor.  Adv.  
Funct.  Mater.  2022,  32, 2201510.  https://doi.org/10.1002/adfm.202201510 
[58] Cleary, F., Henshall, D. C.,  Balasubramaniam, S. (2021). On -Body Edge  
Computing Through E -Textile Programmable Logic Array. Frontiers in  
Communications and Networks, 18."," This paper explores the potential of emerging AI technologies to inspire the next generation of e-textiles. It examines nanotechnology and AI advancements in the e-textiles domain, focusing on the potential application of neuromorphic computing and spiking neural network inspired AI technologies. It looks at the use of AI-enabled technologies for production line fabric inspection and defect detection, as well as intelligent clustering and classification techniques adopted and utilized in the textiles industry. It also examines the use of nanotech fabric research advancements and the integration of electronic components into textiles. Finally, it looks at the use of AI and machine learning technologies to create a more sustainable digital supply chain and optimize textile manufacturing processes."
19," Networksâ€™ modulation: How diï¬€erent structural
network properties aï¬€ect the global
synchronization of coupled Kuramoto oscillators.
Juliette Courson1;2;3, Thanos Manos2, and Mathias Quoy2;4
1Laboratoire de Physique ThÃ©orique et ModÃ©lisation (LPTM), CNRS, UMR 8089,
CY Cergy Paris UniversitÃ©, Cergy-Pontoise Cedex, France
juliette.courson@cyu.fr
2Equipes Traitement de lâ€™Information et SystÃ¨mes (ETIS), CNRS, UMR 8051,
ENSEA, CY Cergy Paris UniversitÃ©, Cergy-Pontoise Cedex, France
thanos.manos@cyu.fr
3Department of Computer Science, University of Warwick, Coventry, UK
4IPAL CNRS Singapore
mathias.quoy@cyu.fr
Abstract. Inalargevarietyofsystems(biological,physical,socialetc.),
synchronizationoccurswhendiï¬€erentoscillatingobjectstunetheirrhythm
when they interact with each other. The diï¬€erent underlying network
deï¬ningtheconnectivitypropertiesamongtheseobjectsdrivestheglobal
dynamics in a complex fashion and aï¬€ects the global degree of synchrony
of the system. Here we study the impact of such types of diï¬€erent net-
work architectures, such as Fully-Connected, Random, Regular ring lat-
tice graph, Small-World and Scale-Free in the global dynamical activity
of a system of coupled Kuramoto phase oscillators. We ï¬x the external
stimulation parameters and we measure the global degree of synchrony
whendiï¬€erentfractionsofnodesreceivestimulus.Thesenodesarechosen
either randomly or based on their respective strong/weak connectivity
properties (centrality, shortest path length and clustering coeï¬ƒcient).
Our main ï¬nding is, that in Scale-Free and Random networks a sophis-
ticated choice of nodes based on their eigenvector centrality and average
shortest path length exhibits a systematic trend in achieving higher de-
gree of synchrony. However, this trend does not occur when using the
clustering coeï¬ƒcient as a criterion. For the other types of graphs consid-
ered, the choice of the stimulated nodes (randomly vs selectively using
the aforementioned criteria) does not seem to have a noticeable eï¬€ect.
1 Introduction
Complex networksâ€™ theory is a powerful tool in various ï¬elds that allow us to
investigate and understand the real world [1,2]. For example, diï¬€erent ensembles
of neurons connected by synapses coordinate their activity to perform certain
tasks (in biology), infrastructures like the Internet are formed by routers and
computer cables and optical ï¬bers (in hardware communication) and the human
personal or professional relationships (in social sciences) to name a few [3].arXiv:2303.03099v1  [nlin.AO]  24 Feb 2023 1. INTRODUCTIONCourson et al.
Nonlinearity is a very important feature in complex systems giving a rich
repertoire of diï¬€erent activity patterns, such as stable, unstable, periodic etc. A
modiï¬cation of some parameter might also produce a change in their stability,
and therefore in the dynamics of the system. Furthermore, such systems may
have a high sensitivity to initial conditions, or to any external input, that could
completely change their dynamics [4].
Suchdynamicsoftenyieldtoaself-organisedcoherentactivity,i.e.tosynchro-
nization. The latter can be loosely deï¬ned as the capacity of diï¬€erent oscillating
objects to adjust their rhythm due to their interaction and plays a key role in a
large variety of systems, whether biological, physical, or even social (see e.g. [5]).
In a more formal way, synchronization emerges from the interaction of several
autonomous oscillators, also called self-sustained oscillators. That is, nonlinear
dynamicalsystemsthatproduceoscillationswithoutanyneedofexternalsource.
Their dynamics is given by a nonlinear diï¬€erential equation or, in the case of
multiple coupled oscillators, by several coupled diï¬€erential equations.
The relative way that autonomous oscillators are connected within a given
network can aï¬€ect their global activity and synchronization properties. Neural
networks can be represented as a graph of connections between the diï¬€erent neu-
rons. Since the introduction of small-world networks and scale-free networks (see
e.g. [6,8]), the ï¬eld of network graph analysis has attracted the attention of many
studies aimed to better understand complex systems (see e.g. [9,10,11,12,13]).
Furthermore, modern network connectivity techniques allow us to capture var-
ious aspects of their topological organization, as well as to quantify the local
contributions of individual nodes and edges to networkâ€™s functionality (see e.g.
[14]).
In neuroscience, synchronization plays a very important role. The human
brain is a very large and complex system whose activity comprises the rapid
and precise integration of a gigantic amount of signals and stimulus to perform
multiple tasks (see e.g. [14,15,16]). One example occurs in epileptic seizures,
where periods of abnormal synchronization in the neural activity can spread
within diï¬€erent regions of the brain, and cause an attack in the aï¬€ected person
(see e.g. [17]). More examples are found in other brain diseases such as Parkinson
disease, where an excessively synchronized activity in a brain region correlates
with motor deï¬cit (see e.g. [18,19] and references therein) or tinnitus (see e.g.
[20,21,22] and references therein).
In this study, we focus at a rather theoretical framework. We set out to in-
vestigate the impact of diï¬€erent network architectures, such as Fully-Connected,
Random, Regular ring lattice graph, Small-World and Scale-Free in the global
dynamical activity of a system of coupled Kuramoto phase oscillators [23]. The
Kuramoto model has been broadly used to study various types of oscillatory
complex activity, see e.g. [24,25,26] (to name only a few) and references therein.
Our goal is to investigate the impact of the network (graph) structure in the sys-
temâ€™sglobaldegreeofsynchronizationwhenapplyingidenticalandï¬xedexternal
stimulus to diï¬€erent subsets of nodes which are chosen according to various net-
work connectivity criteria. We ï¬nd that, in scale-free and random networks, a
2 Courson et al.
2. METHODS AND MATERIALS
sophisticated choice of nodes based on graph connectivity properties exhibits a
systematic trend in achieving higher degree of synchrony. For the other types of
graphs considered, the choice of the stimulated nodes (randomly vs selectively
using the aforementioned criteria) seems to not have a noticeable eï¬€ect.
2 Methods and Materials
2.1 Connectivity measurements
We here study the dynamics of phase oscillators coupled via binary, undirected
graphsG= (V;E), containing a set of NverticesV=fv2J1 :NKgand a set
E=f(v;w)2J1 :NK2gof edges. Let Abe the corresponding adjacency matrix,
withAvw= 1if there is a connection between node vand nodew,0otherwise.
Self-connections are excluded, so Av;v= 0for any vertex v. For our analysis
later on, we will use the following graph connectivity measurements [27]:
â€“ Shortest path length. The shortest path length Lv;wbetween any two
nodesvandwis the number of connections on the shortest path going
from one to another, computed following Dijkstraâ€™s algorithm. We deï¬ne
the shortest path length of a node vas the average shortest path between v
and any other node of the network:
<Lv>=X
w2VLv;w
N: (1)
Note thatLv;wmight not be deï¬ned if there is no way connecting node vto
nodew. The lower the shortest path length, the fastest the information goes
from one node to another. For example, when building a subway network
(that is, a graph where diï¬€erent stations are interconnected), one might
want to minimize the stationsâ€™ average shortest path length so the users can
easily navigate across the city.
â€“ Centrality. The eigenvector centrality is used to quantify the importance
of a node in the network. Let be the highest eigenvalue for A, so that all
the corresponding eigenvectorâ€™s components are non null. The eigenvector
centralityxvof vertexvis deï¬ned as the vthcomponent the eigenvector,
namely:
xv=1
X
w2VAw;vxw: (2)
Keeping in mind the subway network example, a station with a high cen-
trality would be densely connected to other stations, in particular to other
central ones.
â€“ Clustering. Letkv=P
wAvwbe the degree of node v. In the case of a
undirected graph,kv(kv"," This paper examines the impact of different network structures, such as Fully-Connected, Random, Regular ring lattice graph, Small-World and Scale-Free, on the global dynamical activity of a system of coupled Kuramoto phase oscillators. It finds that in Scale-Free and Random networks, a sophisticated choice of nodes based on their eigenvector centrality and average shortest path length can lead to higher degrees of synchrony. The paper also discusses magnetoencephalographic functional connectivity in Alzheimer's disease and random graphs in nature, society, and the brain."
20," On Modifying a Neural Networkâ€™s Perception
Manuel de Sousa Ribeiro ,JoËœao Leite
NOV A LINCS, NOV A University Lisbon, Portugal
mad.ribeiro@campus.fct.unl.pt, jleite@fct.unl.pt
Abstract
Artiï¬cial neural networks have proven to be ex-
tremely useful models that have allowed for mul-
tiple recent breakthroughs in the ï¬eld of Artiï¬cial
Intelligence and many others. However, they are
typically regarded as black boxes , given how dif-
ï¬cult it is for humans to interpret how these mod-
els reach their results. In this work, we propose a
method which allows one to modify what an arti-
ï¬cial neural network is perceiving regarding spe-
ciï¬c human-deï¬ned concepts, enabling the gener-
ation of hypothetical scenarios that could help un-
derstand and even debug the neural network model.
Through empirical evaluation, in a synthetic dataset
and in the ImageNet dataset, we test the proposed
method on different models, assessing whether the
performed manipulations are well interpreted by
the models, and analyzing how they react to them.
1 Introduction
In this paper, we investigate how to modify a neural networkâ€™s
perception regarding speciï¬c human-deï¬ned concepts not di-
rectly encoded in its input, with the goal of being able to
better understand how such concepts affect a modelsâ€™ pre-
dictions. Our results suggest that this is possible to do with
few labeled data, and without need to change or retrain the
existing neural network model.
In the last few decades, artiï¬cial neural networks have en-
abled major advances in multiple ï¬elds, from text, image,
video and speech processing [Khan et al. , 2020 ], to medicine
[Shahid et al. , 2019 ], economics and ï¬nance [Ghoddusi et
al., 2019 ], and many others. Numerous successful neural
network-based applications have recently been implemented
[Abiodun et al. , 2018 ], rendering these models ubiquitous.
Despite their popularity, neural networks lack interpretabil-
ity, as they supply no direct human-interpretable indication
of why a given result was provided [Hitzler et al. , 2020 ].
This led to the development of multiple methods focused
on solving this shortcoming (cf. Section 6). Most popular
methods typically focus on pointing out which inputs con-
tributed most for the output, or on substituting the model for
one that is inherently interpretable [Kim et al. , 2018 ]. How-
ever, such methods leave to the users the burden of under-standing why the provided explanation justiï¬es the output,
e.g, users must interpret why a particular set of features, e.g.,
pixels in an image, and their values, leads to the output. Var-
ious user studies [Adebayo et al. , 2020; Chu et al. , 2020;
Shen and Huang, 2020 ]show that the explanations given by
these methods are often disregarded or unhelpful to end users.
One reason is that humans do not typically reason with fea-
tures at a very low level, such as individual pixels in an image
â€“ they typically reason with higher-level human deï¬ned con-
cepts. For example, a useful explanation from the standpoint
of a human as to why a network classiï¬ed a particular picture
of a train as being one of a passenger train will probably refer
to the fact that the wagons had windows rather than pointing
out speciï¬c pixels in the image.
Additionally, when humans attempt to determine the
causes for some non-trivial phenomena, they often resort
to counterfactual reasoning [Miller, 2019 ], trying to under-
stand how different scenarios would lead to different out-
comes. This approach seems also helpful for interpreting ar-
tiï¬cial neural networks, as it emphasizes the causes â€“ what is
changed â€“ and the effects â€“ what mutates as a result of the
changes. For example, to better interpret how a neural net-
works is classifying a particular picture of a train, the user
could ask what would have been the output had the picture
contained a passenger wagon. We would like to be able to
generate such counterfactual scenarios based on how different could ask what would have been the output had the picture
contained a passenger wagon. We would like to be able to
generate such counterfactual scenarios based on how different
human-deï¬ned concepts impact a modelâ€™s predictions. The
use of human-deï¬ned concepts â€“ the concept of passenger
wagon in the previous example â€“ is important as it provides
semantics with which to describe the counterfactuals, while
ensuring that these concepts are meaningful and understand-
able for the users of a particular model.
There has been work on developing methods to gener-
ate counterfactuals for artiï¬cial neural networks [Guidotti,
2022 ], with some even allowing for generating counterfac-
tual samples with respect to particular attributes [Yang et
al., 2021 ]. However, to our knowledge, they focus on how
particular changes to the input samples might affect a mod-
elsâ€™ output, neglecting what the model is actually perceiving
from those samples. Furthermore, current methods to pro-
duce counterfactuals are typically complex to implement, of-
ten requiring the training of an additional model to produce
the counterfactuals [Stepin et al. , 2021 ], and the use of spe-
ciï¬c neural network architectures, e.g., invertible neural net-arXiv:2303.02655v1  [cs.AI]  5 Mar 2023 works [HvilshÃ¸j et al. , 2021 ].
In this work, we address the issue of counterfactual gen-
eration at a different level of abstraction, focusing on what
a model is perceiving from a given input regarding speciï¬c
human-deï¬ned concepts, and how that affects the modelâ€™s
output. The idea would be to â€œ convince â€ the model that it
is perceiving a particular concept â€“ for example a passenger
wagon â€“ without producing a speciï¬c image containing one,
and checking its effect on the modelâ€™s output. By abstracting
away from generating particular counterfactual samples and
instead focusing on generating counterfactuals with regards
to what a model is perceiving about human-deï¬ned concepts,
we allow for a better understanding of how what is encoded in
a neural network impacts a modelsâ€™ predictions in a human-
understandable manner. By manipulating what a model per-
ceives regarding speciï¬c concepts of interest, we allow users
to explore how the output of a neural network depends on
what it is perceiving regarding such concepts.
In order for it to be possible to generate counterfactuals
based on what a model is perceiving instead of what the
model is fed, we need to be able to understand what a neu-
ral network model is perceiving and be able to manipulate
what the model is perceiving with respect to a speciï¬c con-
cept. We ï¬nd inspiration in the research conducted in the
ï¬eld of neuroscience, where highly selective neurons that
seemed to represent the meaning of a speciï¬c stimulus can be
identiï¬ed [Reddy and Thorpe, 2014 ]. These neurons, known
asconcept cells , seemed to â€œprovide a sparse, explicit and
invariant representation of conceptsâ€ [Quiroga et al. , 2005;
Quiroga, 2012 ]. The discovery of these cells contributed for
a better understanding of how the brain â€“ a complex and sub-
symbolic system â€“ works and how it relates different concepts
[Gastaldi et al. , 2022 ]. Additionally, through the technique of
optogenetics, it is possible to manipulate the activity of spe-
ciï¬c neurons and learn their purpose [Okuyama, 2018 ].
Analogously, being able to assign meaning to speciï¬c neu-
rons in a neural network could provide us with a better un-
derstanding of what information is encoded in a given model,
and how it might be associating different concepts. Moreover,
given that typically one has access to a neural networksâ€™ inter-
nals, we could manipulate the outputs of the neurons to which
meaning has been assigned, and examine how such changes
affect the model under different circumstances, thus generat-
ing counterfactual scenarios.
Based on the existing evidence that neurons with similar
properties to concept cells seem to emerge in artiï¬cial neural
networks [Goh et al. , 2021 ], we hypothesize that by identi-
fying which neurons in a neural network act as concept cells
to speciï¬c human-deï¬ned concepts and by manipulating the
activations of such neurons, we should be able to modify a
neural networkâ€™s perception regarding those concepts.
In this paper, we propose and test a method to gener-
ate counterfactuals scenarios for artiï¬cial neural networks
by modifying what they are perceiving regarding speciï¬c
human-deï¬ned concepts. In Section 2, we present the pro-
posed method, with Section 2.1 discussing how to pinpoint
which neurons identify a particular concept in a neural net-
work, and Sections 2.2 to 2.4 addressing different aspects of
the proposed method and providing experimental evidence tosupport our claims. Sections 3 and 4 illustrate possible ap-
plications of the proposed method. In Section 5, we apply
and test the method in the setting of the ImageNet dataset. In
Section 6, we discuss related work, concluding in Section 7.
2 A Method to Manipulate a Neural
Networkâ€™s Perception
In order to generate counterfactuals regarding what a neural
network model is perceiving about human-deï¬ned concepts,
we propose a method composed by three main steps. For each
concept of interest:
a) Estimate how sensitive each neuron is to that concept, network model is perceiving about human-deï¬ned concepts,
we propose a method composed by three main steps. For each
concept of interest:
a) Estimate how sensitive each neuron is to that concept,
i.e., how well its activations separate samples where that
concept is present from those where it is absent;
b) Based on the neuronsâ€™ sensitivity values, select which
neurons are considered as â€œconcept cell-likeâ€, which we
will refer to as concept neurons ;
c) For each concept neuron, compute two activation values,
representing, respectively, the output of that neuron for
samples where that concept is present and absent.
Consider a neural network model M:I!O, which is the
model being analyzed, where Iis the input data space and O
denotes the model output space. For each considered human-
deï¬ned concept C, we assume a set of positive PCIand
negative NCIsamples where the concept is, respectively,
present/absent. Let aM
i:I!Rrepresent the output of the
ithneuron of neural network model Maccording to some
arbitrary ordering of the neurons.
The ï¬rst step of our method consists in estimating how sen-
sitive each neuron is to each considered concept, i.e., how
well the activations of each neuron separate samples where a
concept is present from those where it is not. We denote by
rM
i: 2I2I![0;1]the function which, for a given neuron
iof a modelM, takes a set PCandNCand provides a value
representing how sensitive iis to concept C. In Section 2.1,
we consider different implementations of this function.
The second step is to select, for each concept of interest C,
which neurons ofMare to be considered as concept neurons
forC. LetsC:R!f0;1gbe a threshold function indicating,
for a given concept Cand sensitivity value, whether that value
is high enough to be considered as a concept cell. Then, for
each concept of interest C, we determine the set of selected
neurons as SC=fi:sC(rM
i(PC; NC)) = 1 ; i2[1; k]g,
where kis the number of neurons in M. In all experiments,
we set the threshold value by gradually decreasing it, while
testing the model performance in a 100sample validation set
for each concept. Once more than 3neurons have been added,
by decreasing the threshold, and no performance improve-
ment is seen in the validation set, we set the threshold to the
best found value.
Lastly, for each neuron selected as a concept neuron for
some concept C, we compute two activation values repre-
senting, respectively, when that concept is present and ab-
sent. We consider a function cM
i: 2I!R, which computes
an activation value for the ithneuron ofM, and use it com-
pute an activation value representing the presence of concept
C,cM
i(PC), and one representing its absence, cM
i(NC). In TypeAWarTraintEmptyTrain 9has :FreightWagonu9has :PassengerCaru9has :EmptyWagonvMixedTrain
TypeBPassengerTraintLongFreightTrain 9has :(PassengerCaruLongWagon )t(2 has :PassengerCar )vPassengerTrain
TypeCRuralTraintMixedTrain 9has :ReinforcedCaru9has :PassengerCarvWarTrain
LongFreightTrainLongTrainuFreightTrain (2 has :LongWagon )t(3 has :Wagon )vLongTrain
EmptyTrain8has :(EmptyWagontLocomotive )u9has :EmptyWagon (2 has :FreightWagon )vFreightTrain
Figure 1: Subset of the XTRAINS dataset ontologyâ€™s axioms, describing how the trainsâ€™ representations are classiï¬ed.
Figure 2: Sample images of the XTRAINS dataset.
Section 2.2, we discuss different implementations of cM
iand
compare how they impact the methodâ€™s results.
Subsequently, when some input x2Iis fed to neural net-
workM, to generate a counterfactual scenario where concept
Cis present or absent, we only need to replace the activa-
tion value aM
i(x)of each neuron iinSCwithcM
i(PC)or
cM
i(NC), respectively. We refer to this step, as injecting a
concept into a neural network model.
To test our method, we consider the Explainable Abstract
Trains Dataset (XTRAINS) [de Sousa Ribeiro et al. , 2020 ], a
synthetic dataset composed of representations of trains, such
as those shown in Figure 2. This dataset contains labels re-
garding various visual concepts and a logic-based ontology
describing how each of these concepts is related. Figure 1
shows a subset of the datasetâ€™s accompanying ontology il-
lustrating how different concepts are related to each other.
This ontology speciï¬es, for example, that TypeA is either
WarTrain orEmptyTrain , and that WarTrain encompasses
those having a ReinforcedCar and a PassengerCar . These
concepts have a visual representation, e.g, a ReinforcedCar
is shown as a car having two lines on each wall, such as the
ï¬rst two cars of the leftmost image in Figure 2.
In the experiments described below, we adopt a neural net-
work developed in [Ferreira et al. , 2022 ], trained to identify
trains of TypeA â€“ referred to asMA. This neural network was
trained to achieve an accuracy of about 99% in a balanced test
set of 10 000 images. We also consider the deï¬nition of rele-
vancy given in [de Sousa Ribeiro and Leite, 2021 ]to establish
which concepts are related to the task of a given neural net-
work (w.r.t. the datasetâ€™s accompanying ontology).
2.1 Identifying Concept Cell-like Neurons
In order to be able to modify a neural networkâ€™s perception re-
garding speciï¬c human-deï¬ned concepts, it is ï¬rst necessary
to determine which neurons in a model are identifying these
concepts. Based on the evidence that neural networks seem
to have information encoded in their internals regarding con-
cepts which are related with their tasks [de Sousa Ribeiro and
Leite, 2021 ], and that neurons with â€œconcept cell-likeâ€ prop-
erties seems to emerge in artiï¬cial neural networks [Goh et
al., 2021 ], we hypothesize that neural networks have neurons
which act as concept cells for concepts related with the tasks
they perform. In this section, we investigate how to determine
âˆ’2 0 2 4
Activation0.00.51.0DensityConceptÂ¬Concept
âˆ’2 0 2 4Figure 3: Probability density function of two neurons for samples
where a given concept is present/absent.
such neurons in a neural network model.
We consider a neuron to be â€œconcept-cell likeâ€ for some
concept Cif it is possible to separate samples where Cis
present from those where it is absent based on its activations.
Figure 3, illustrates the estimated probability density func-
tion of two neurons for some PCandNCsets. The neuron
on the left side seems to act as a concept cell for C, showing
well separated distributions for both sample sets. On the other
hand, the neuron on the right side does not act as a concept
cell for this concept, given that its activations do not distin-
guish between both sets of samples.
While there are methods, such as TCA V [Kim et al. , 2018 ]
and Mapping Networks [de Sousa Ribeiro and Leite, 2021 ], guish between both sets of samples.
While there are methods, such as TCA V [Kim et al. , 2018 ]
and Mapping Networks [de Sousa Ribeiro and Leite, 2021 ],
which allow for an understanding of whether a given model
is sensitive to a certain concept, here we are interested in un-
derstanding whether individual neurons are sensitive to that
concept. Our goal is not to check whether the model is sen-
sitive to a concept, for which only some neurons might be
sufï¬cient, but rather to ï¬nd all neurons that are sensitive to
that concept, so that we can manipulate them.
We consider three different implementations of rM
ito eval-
uate the adequacy of a neuron iofMas concept cell for C:
â€¢ Spearman rank-order correlation between a neuronâ€™s ac-
tivations and the datasetâ€™s labels, computed as j1"," This paper reviews a variety of research papers that focus on the use of artificial neural networks in decision-making, image recognition, and counterfactual explanation generation. It proposes a method to generate counterfactuals for a neural network model by manipulating what it perceives regarding specific human-defined concepts. Through empirical evaluation, the proposed method is tested on different models to assess whether the performed manipulations are well interpreted by the models and to analyze how they react to them. This method could help humans to better interpret how neural networks reach their results and to understand the causes and effects of different scenarios."
21," Notice
This work has been submitted to the IEEE for possible publication.
Copyright may be transferred without notice, after which this version
may no longer be accessible.arXiv:2303.02640v1  [cs.LG]  5 Mar 2023 Swim: A General-Purpose, High-Performing, and Efï¬cient Activation
Function for Locomotion Control Tasks
Maryam Abdool1and Tony Dear2
Abstract â€” Activation functions play a signiï¬cant role in
the performance of deep learning algorithms. In particular,
the Swish activation function tends to outperform ReLU on
deeper models, including deep reinforcement learning models,
across challenging tasks. Despite this progress, ReLU is the
preferred function partly because it is more efï¬cient than Swish.
Furthermore, in contrast to the ï¬elds of computer vision and
natural language processing, the deep reinforcement learning
and robotics domains have seen less inclination to adopt new
activation functions, such as Swish, and instead continue to
use more traditional functions, like ReLU. To tackle those
issues, we propose Swim, a general-purpose, efï¬cient, and high-
performing alternative to Swish, and then provide an analysis of
its properties as well as an explanation for its high-performance
relative to Swish, in terms of both reward-achievement and
efï¬ciency. We focus on testing Swim on MuJoCoâ€™s locomotion
continuous control tasks since they exhibit more complex
dynamics and would therefore beneï¬t most from a high-
performing and efï¬cient activation function. We also use the
TD3 algorithm in conjunction with Swim and explain this choice
in the context of the robot locomotion domain. We then conclude
that Swim is a state-of-the-art activation function for continuous
control locomotion tasks and recommend using it with TD3 as
a working framework.
I. INTRODUCTION AND RELATED WORK
Deep reinforcement learning can automate the design of
complex controllers for locomotion tasks [9]. Before the
emergence of deep reinforcement learning, a common tech-
nique was to manually design controllers for each locomotion
task; this process requires an accurate dynamic model of
the robot that may be difï¬cult to achieve [9]. In addition
to exhibiting complex dynamics, locomotion problems also
feature high degrees of freedom, complicating the task of
engineering controllers [5]. Therefore, we utilize deep rein-
forcement learning to automate the design of our controllers
for MuJoCoâ€™s locomotion continuous control tasks presented
in this paper.
In a neural network, each neuron performs a transforma-
tion on the inputs using the incoming weights and biases, but
such a simple stand-alone model fails to learn complex tasks
[17]. Therefore, non-linearity is introduced so that neural
networks can act as non-linear function approximators in
various settings, including reinforcement learning [19]. This
is achieved by using non-linear activation functions, such as
the Rectiï¬ed Linear Unit (ReLU), in the hidden layers of the
1Maryam Abdool is with Department of Computer Sci-
ence, Columbia University, New York, NY 10027, USA
maryam.r.abdool@gmail.com
2Tony Dear is with Department of Computer Science, Columbia Univer-
sity, New York, NY 10027, USA tony.dear@columbia.eduneural network [15]. Non-linearity is a powerful characteris-
tic of neural networks because of the universal approximation
theoremâ€™s implication that non-linear activation functions
can approximate any continuous function arbitrarily well
[10]. This has vital implications for the application of deep
reinforcement learning algorithms to continuous control and
locomotion tasks, as it guarantees that neural networks have
the potential to learn complex controllers.
TD3 is one such deep reinforcement learning algorithm
that is designed to learn complex locomotion controllers [7].
As a deep learning algorithm, TD3 follows the standard
approach of using ReLU, a non-linear activation function,
in the hidden layers of the neural network to model complex
tasks [7]. What distinguishes TD3 from other algorithms are
three aspects: an actor-critic approach, sample efï¬ciency, and
the twin critic networks. For these reasons, we select TD3
over other algorithms.
First, in TD3â€™s actor-critic neural network architecture, the twin critic networks. For these reasons, we select TD3
over other algorithms.
First, in TD3â€™s actor-critic neural network architecture,
the policy network is called the actor because it is used
to select actions, and the estimated value function network
is called the critic because it criticizes the actions made
by the actor [19]. An actor-critic method is advantageous
because it can be applied to problems with continuous
action spaces, namely MuJoCoâ€™s continuous control tasks,
where Q-learning methods cannot be directly applied; for
continuous control tasks with an inï¬nite set of actions, Q-
learning methods must search through the inï¬nite set to
select the action, while the separation of the policy from
the value function in the actor-critic method reduces the
extensive computation needed for each action selection [19].
Second, TD3 is sample-efï¬cient because it is based on a
deterministic policy gradient method [18]. The deterministic
policy gradient has the simple form of the expected gradient
of the action-value function [18]. Because of this simple
form, the deterministic policy gradient can be estimated
much more efï¬ciently than its stochastic counterpart [18].
Finally, TD3 uses two critic networks, instead of one, to
address the overestimation bias problem present in DDPG
and other Q-learning algorithms that occurs when the noisy
value estimate is maximized [7], [20].
Although designing new algorithms is an important prob-
lem, such as the TD3 algorithm that we employ to model
our controllers, research in creating new non-linear acti-
vation functions is neglected in favor of designing more
complex deep reinforcement learning algorithms. Therefore,
we pursue the ï¬eld of activation functions as research shows
that not all non-linear activation functions have the same
performance. For example, it is believed that ReLU is advan-
Manuscript submitted for review to the IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) tageous over Sigmoid because it reduces the likelihood of the
vanishing gradient problem and it is a simpler, more efï¬cient
activation function [8]. Similarly, [16] speculates that Swish
tends to outperform common baseline functions, including
ReLU, because it is non-monotonic. However, Swish is
less efï¬cient than ReLU due to the required exponential
computations, which is one of the reasons ReLU is a widely
used function, in addition to being more well-known; as
mentioned earlier, the choice of using ReLU in the original
TD3 implementation is one notable example [11], [7].
Because of those limitations, we invent Swim, a non-
monotonic, smooth activation function mathematically de-
ï¬ned as f(x) =x
2(kxp
1+k2x2+1). Swim is more efï¬cient and
more likely to be high-performing than Swish, and is conse-
quently also more likely to be high-performing than ReLU;
as mentioned earlier, [16] and [6] have shown that Swish
tends to outperform ReLU on deeper models, including deep
reinforcement learning models, across challenging tasks. We
achieve efï¬ciency and high performance without compro-
mising any of the desirable properties, such as smoothness,
that make Swish outperform baseline functions. This is in
contrast to previous work, such as [11]â€™s design of H-Swish,
an efï¬cient but non-smooth version of Swish. Ultimately, we
strive to achieve high performance and efï¬ciency as better
activation functions correspond to better locomotion con-
trollers. High performance and efï¬ciency are important met-
rics for the locomotion domain due to the complex dynamics
and time-intensive characteristics mentioned earlier. Finally,
we also hypothesize that there are speciï¬c properties intrinsic
to Swimâ€™s success in the deep reinforcement learning and
locomotion control domain.
II. SWIM: AN ANALYSIS
The newly proposed activation function, Swim, and its ï¬rst
derivative are deï¬ned as:
f(x) =x
2kxp
1+k2x2+1
;
f0(x) =1
2kx(k2x2+2)
(p
1+k2x2)3+1 (1)
where kis a constant that can be tuned or deï¬ned before
training. We pick a ksuch that it can support our analysis that
Swim outperforms Swish because of the properties intrinsic
to it, and not because of a constant rescaling of the function
that could be analogously applied to Swish by changing b,
which is also a learnable parameter. For this reason, we set k
= 0.5 to approximate the Swish function ( x1
1+e"," This paper proposes Swim, a new activation function for reinforcement learning and robotics tasks. It is tested on MuJoCo's locomotion continuous control tasks and is used in conjunction with the TD3 algorithm. Results show that Swim is a state-of-the-art activation function for continuous control locomotion tasks and is recommended for use with TD3. The paper also evaluates the performance and efficiency of the Twin Delayed Deep Deterministic Policy Gradient (TD3) algorithm and the Swim activation function on four MuJoCo benchmark locomotion control environments. Results showed that Swim outperformed Swish in three out of four environments. Further work with Swim remains, such as testing and optimization on the GPU."
22," Ensemble Reinforcement Learning: A Survey
Yanjie Song1, P. N. Suganthan2,3, Witold Pedrycz4, Junwei Ou1, Yongming He1, Yingwu
Chen1
Abstract
Reinforcement learning (RL) has achieved state-of-the-art performance in many scientic
and applied problems. However, some complex tasks still are dicult to handle using a
single model and algorithm. The highly popular ensemble reinforcement learning (ERL)
has become an important method to handle complex tasks with the advantage of combining
reinforcement learning and ensemble learning (EL). ERL combines several models or training
algorithms to fully explore the problem space and has strong generalization characteristics.
This study presents a comprehensive survey on ERL to provide the readers with an overview
of the recent advances and challenges. The background is introduced rst. The strategies
successfully applied in ERL are analyzed in detail. Finally, we outline some open questions
and conclude by discussing some future research directions of ERL. This survey contributes
to ERL development by providing a guide for future scientic research and engineering
applications.
Keywords: ensemble reinforcement learning, reinforcement learning, ensemble learning,
articial neural network, ensemble strategy
Email addresses: songyj_2017@163.com (Yanjie Song),
p.n.suganthan@qu.edu.qa,EPNSugan@ntu.edu.sg (P. N. Suganthan ), wpedrycz@ualberta.ca (Witold
Pedrycz ), junweiou@163.com (Junwei Ou), heyongming10@hotmail.com (Yongming He),
ywchen@nudt.edu.cn (Yingwu Chen)
1College of Systems Engineering, National University of Defense Technology, Changsha, China
2KINDI Center for Computing Research, College of Engineering, Qatar University, Doha, Qatar
3School of Electrical & Electronic Engineering, Nanyang Technological University, Singapore
4Department of Electrical & Computer Engineering, University of Alberta, Edmonton AB, Canada
Preprint submitted to Review March 7, 2023arXiv:2303.02618v1  [cs.LG]  5 Mar 2023 1. Introduction
In the last decades, reinforcement learning (RL) methods have demonstrated the advan-
tages of solving complex problems in many elds such as gaming, robotics, and computer
vision. Along with a series of breakthroughs like deep Q neural networks [1], AlphaGo
[2], video game [3, 4] and robotic control tasks [5], we have witnessed the revitalization
of reinforcement learning outperforming humans. The success of the approach stems from
the agent's ability to automate the acquisition of problem features and complete end-to-end
learning. Articial neural networks (ANN) and gradient descent further enhance RL's explo-
ration and exploitation capabilities. This makes it easier for RL to handle time-consuming
manual work or challenging tasks.
Each type of RL has unique advantages and inevitably has some limitations. For exam-
ple, deep reinforcement learning (DRL) requires extensive training to obtain a policy [4].
Additional problems often occur during training, including overtting [6], error propagation
[7], and imbalance between exploration and exploitation [8]. These problems motivate re-
searchers to design their models or training algorithms. Implementing ensemble learning
to the RL framework is a new way to enhance the learning and representation of algo-
rithms. This method is called ensemble reinforcement learning (ERL) and has excellent
performance. Marquis de Condorcet [9] rst demonstrated that average voting outperforms
individual model decisions. Krogh and Vedelsby [10], Breiman [11] and a series of other
studies have theoretically demonstrated the great advantages of ensemble methods from
other perspectives. The ensemble idea has been able to achieve such great success in the
eld of deep learning and reinforcement learning due to the decomposition of datasets [12],
powerful learning capabilities [13] and diverse ensemble methods [11].
The classication of ERL is diverse according to dierent criteria. According to the
constituent elements in the ensemble framework, ERL can be classied as a high-level en-
semble [14] and a low-level ensemble [15]. ERL can also be classied as single-agent ERL
2 [16] and multi-agent ERL [17] according to the number of agents. Centralized ERL [18]
and distributed ERL [19], on the other hand, are classications of ERLs based on how the
agents work. In this paper, we present a detailed description of ERL methods according to
the improvement strategies used and discuss their applications to guide the design of new
methods.
Existing related work of ERL on the use of training algorithms, ensemble strategies, and
application areas are diverse. The motivation of this paper is to provide readers with a
systematic overview of the existing related research and the current research progress and
the valuable conclusions achieved. Readers can quickly nd the corresponding studies and
follow up on the research according to their concerns. To the best of our knowledge,
this is the rst survey focusing solely on ensemble reinforcement learning. We
present the strategies used in ERL and related applications, discuss several open questions
and give a guide for future exploration in the ERL area.
The remainder of this paper is structured as follows. Section 2 presents the background
of ensemble reinforcement learning methods. Section 3 introduces implementation strategies
in ERL. Section 4 discusses the application of ERL to dierent domains. Section 5 discusses
several open questions and possible future research directions. Section 6 gives the conclusion
of this paper (see Figure 1).
2. Background
To facilitate the readers' better understanding of ensemble reinforcement learning meth-
ods, this section briey introduces reinforcement learning and ensemble learning.
2.1. Reinforcement Learning
The reinforcement learning method is an articial intelligence method in which the agent
interacts with the environment and makes decisions to continuously correct errors to obtain
3 Figure 1: Structure of the paper
4 optimal decisions. Markov Decision Process (MDP) is the basis for using RL to solve prob-
lems [33]. RL can be used when the agent decision is only related to the current state and
not to the previous state. Figure 2 illustrates the agent-environment interaction process. A
tuplehS;A;P;R;ican be used to represent the MDP, where Sdenotes the state, Adenotes
the action, P:SA!P(S) denotes the state transfer matrix with the probability value
p(s0js) =p(St+1=s0jSt=s),R:SA!Rdenotes the reward function, and 2[0;1]
denotes the discount factor. The state of the agent at time step tisst, and it will take action
at. The combination of all states and actions denes a policy . Here, Q-value is used to
evaluate the expected return obtained by the agent following policy .
Q(s;a) =E""1X
t=0tR(st;at)js0=s;a 0=a#
(1)
The goal of solving a problem using RL methods is to nd an optimal policy that
maximizes Q. For nite-state MDPs, the most typical RL is the Q-learning method [20],
which uses Q-table records the combinations of hstate,actioni. Subsequently, a series of RL
methods using articial neural networks were proposed to cope with the innite state space.
Figure 2: Interaction process between agent and environment
Training algorithms can be divided into model-based RL and model-free RL according
to whether the environment model in RL is given in advance or can be obtained through
learning, and the training algorithms can be divided according to state-based or policy-
based, or state-policy combination based. Detailed research progress on RL can be found in
5 ref. [21].
2.2. Ensemble Learning
Ensemble learning (EL) methods occupy an essential position in the eld of machine
learning (ML). The core idea of EL methods is to train multiple predictors, combine them,
and make a decision from all predictions as the nal result of an ensemble model. This EL
method can harness the characteristics of various types of models compared to individual
basic models, and the prediction performance of EL models will be improved and the results
obtained will be more robust. The main types of ensemble learning methods include bagging
[22], boosting [23], and stacking [24]. Figure 3 gives a schematic diagram of these three types
of EL methods, where Ddenotes the dataset, D1toDndenote the sample selection from
the dataset, M1toMndenote the model, and FRdenotes the nal result. The dotted line
in Figure 3-(b) indicates that the weights of samples in the dataset are changed as the next
round of the dataset. And the dotted line in Figure 3-(c) indicates that all datasets are
used for model prediction from level 2to levelL. The main dierence between these three
types of methods is the way of sample selection. These original and improved EL methods
have been applied in various areas. And domain knowledge implemented in the improved
EL method achieves outstanding performance. To sum up, the EL method has been proven
to be advantageous in three ways.
Bias{variance Decomposition
Bias-variance decomposition has successfully demonstrated the superiority of EL meth-
ods over individual learning methods. The bagging method mentioned above reduces vari-
ance among base learners, while the other two methods reduce both bias and variance.
Krogh and Vedelsby rst demonstrated that EL is eective for problems with a single data
set using the idea of ambiguity decomposition to reduce the variance [10]. Subsequently,
Brown et al. [25], Geman et al. [26] veried the eectiveness of EL methods for problems
6 (a) Bagging [22]
 (b) Boosting [23]
(c) Stacking [24]
Figure 3: Schematic diagram of three types of EL methods
7 with multiple data sets and is given as [12]:
E[s"," This paper provides an overview of Ensemble Reinforcement Learning (ERL), a combination of reinforcement learning and ensemble learning used to handle complex tasks. It discusses strategies used in ERL, related applications, and open questions to guide future exploration. It also provides a brief introduction to reinforcement learning and ensemble learning, and outlines various combinations of models and training algorithms used in ERL from 2008 to 2022. Additionally, it discusses strategies for designing ERL methods, and provides examples of its application in the energy and environment, IoT and cloud computing, finance, and other areas. Lastly, it outlines three open questions in ERL-based research and suggests potential future research directions."
23," Diffusion Models Generate Images Like Painters:
an Analytical Theory of Outline First, Details Later
Binxu Wang1 2 3 *John J. Vastola1 *
Abstract
How do diffusion generative models convert pure
noise into meaningful images? We argue that gen-
eration involves ï¬rst committing to an outline, and
then to ï¬ner and ï¬ner details. The corresponding
reverse diffusion process can be modeled by dy-
namics on a (time-dependent) high-dimensional
landscape full of Gaussian-like modes, which
makes the following predictions: (i) individual
trajectories tend to be very low-dimensional; (ii)
scene elements that vary more within training data
tend to emerge earlier; and (iii) early perturba-
tions substantially change image content more
often than late perturbations. We show that the
behavior of a variety of trained unconditional and
conditional diffusion models like Stable Diffu-
sion is consistent with these predictions. Finally,
we use our theory to search for the latent image
manifold of diffusion models, and propose a new
way to generate interpretable image variations.
Our viewpoint suggests generation by GANs and
diffusion models have unexpected similarities.
1. Introduction
Imagine an artist painting a picture of a natural landscape.
We generally expect higher-level scene elements to appear
ï¬rst, and lower-level details later: the borders of the land and
sky might be drawn, then the largest objects (like mountains
and trees) might be placed, then minor objects (like rocks
and small animals) might be placed, and ï¬nally ï¬ne details
(like textures and shading) might be ï¬lled in. Do diffusion
generative models (Sohl-Dickstein et al., 2015; Song &
Ermon, 2019; Song et al., 2021), which can generate natural
landscapes like those of an artist, also construct images like
*Equal contribution1Department of Neurobiology, Har-
vard Medical School, Boston, MA, USA2Department of
Neuroscience, Washington University in St Louis, St Louis,
MO, USA3Artiï¬cio, Cambridge, USA. Correspondence to:
Binxu Wang <binxu wang@hms.harvard.edu >, John Vastola
<John Vastola@hms.harvard.edu >.
Preprint. Work in Progress.this? If not, how do they work?
By visualizing images throughout a reverse diffusion
trajectoryâ€”from pure noise to the ï¬nal imageâ€”the naive
answer appears to be no. One gets the impression of an
image emerging fully-formed from the noise; one is â€˜un-
coveringâ€™ the image, or â€˜opening oneâ€™s eyesâ€™ to reveal an
image that was always there. But this naive answer is highly
misleading, and we will later argue that it is entirely wrong.
One signiï¬cant step towards understanding this question
was provided by Hertz et al., who found that modelsâ€™
cross-attention maps substantially control scene composi-
tion (2022). They noted that different parts of an image
may be â€˜attended toâ€™ at different times in a reverse diffusion
trajectory. But it is unclear if attention mechanisms are nec-
essary for image generation to be like painting, or if this is
a generic property of diffusion models.
Understanding image generation is important for a few rea-
sons. As Hertz et al. show, improving understanding can
make the process more controllable, and hence more precise,
efï¬cient, and useful. These improvements may be crucial
for generalizing image generation to stable video generation,
as some early work has attempted (Ho et al., 2022). Beyond
AI, these details could have some bearing on the brain; in
the same way convolutional neural networks (CNNs) are
used to test hypotheses about how early visual areas in the
brain might behave, diffusion models may also be useful as
a toy model of human visual imagination. Some research
in psychology suggests that humans imagine visual scenes
hierarchically, with important scene elements imagined ï¬rst
and details imagined later (Kosslyn & Shwartz, 1977).
Motivated by a variety of salient observations, in this pa-
per we propose a simple but insightful theory of reverse
diffusion based on approximating image distributions as Motivated by a variety of salient observations, in this pa-
per we propose a simple but insightful theory of reverse
diffusion based on approximating image distributions as
Gaussian mixtures. It suggests an outline-ï¬rst, details-later
view of image generation that begins with a prototype and
gradually reï¬nes it. This theoretical view yields several
interesting predictions for how real generation proceeds,
including that: (i) individual trajectories tend to be very
low-dimensional; (ii) scene elements that vary more within
training data tend to emerge earlier; and (iii) early pertur-
bations substantially change image content more often thanarXiv:2303.02490v1  [cs.CV]  4 Mar 2023 Diffusion Models Generate Images Like Painters
Figure 1. Characteristics of image generation by diffusion models .A. Tracking latent states G(xt)(top row), differences between
nearby time steps G(k(xt"," This paper examines the use of diffusion models to generate images, similar to how a painter would, and explores the dynamics of the endpoint estimate, the low-dimensional latent manifold, and the effects of perturbations on image generation. It also discusses the similarities between the generative processes of diffusion models and GANs, and how the Woodbury matrix inversion identity can be used to project the outcome of the reverse diffusion onto the image manifold."
24," Conï¬‚ict-driven Structural Learning Towards Higher
Coverage Rate in ATPG
Hui-Ling Zhen1, Naixing Wang2, Junhua Huang1, Xinyue Huang2, Mingxuan Yuan1and Yu Huang2
1. Noahâ€™s Ark Lab, Huawei; 2. Hisilicon, Huawei
Abstract â€”Due to the increasing challenges posed by the
relentless rise in the design complexity of integrated circuits,
Boolean Satisï¬ability (SAT) has emerged as a robust alternative
to structural APTG techniques. However, the high cost of trans-
forming a circuit testing problem to a Conjunctive Normal Form
(CNF) limits the application of SAT in industrial ATPG scenarios,
resulting in a loss of test coverage. In Order to address this
problem, this paper proposes a conï¬‚ict-driven structural learning
(CDSL) ATPG algorithm ï¬rstly, in which the conï¬‚ict-driven
heuristic methods in modern SAT solver are implemented on the
logic cone of fault propagation and activation directly. The pro-
posed CDSL algorithm is composed of three parts: (1) According
to the implication graph, various conï¬‚ict constraints have been
learned to prune search space. (2) Conï¬‚ict-driven implication
and justiï¬cation have been applied to increase decision accuracy
and solving efï¬ciency. (3) A conï¬‚ict-based diagnosis method is
further proposed in the case of low coverage debug, leading to
making the aborted faults testable by relaxing or modifying some
constraints on primary inputs. Extensive experimental results on
industrial circuits demonstrate the effectiveness and efï¬ciency
of the proposed CDSL algorithm. It is shown that compared
with the SAT-based ATPG, the proposed CDSL can on average
decrease 25:6%aborted faults with 94:51% less run time. With
a two-stage computational ï¬‚ow, it has shown that the proposed
CDSL can lead to 46:37% less aborted faults than a one-stage
structural algorithm, further with the 3:19% improvement on
fault coverage. In addition, the conï¬‚ict diagnosis can lead to
8:89% less aborted faults on average, and 0:271% improvement
in fault coverage rate.
Index Terms â€”Conï¬‚ict-driven, ATPG, Conï¬‚ict Diagnosis
I. I NTRODUCTION
Continuous progress in decreasing device sizes and in-
creasing design complexity has brought increasing demand
for high product quality and low defective parts-per-million
(DPPM) goals. Thus, scan-based structural testing has become
even more important than ever, and Automatic Test Pattern
Generation (ATPG) has served as an essential procedure for
generating appropriate test patterns for testing logical faults
that model physical defects.
Given a targeted fault of the circuit-under-test, the goal of
ATPG is to either generate a test pattern for the targeted
fault (i.e., ï¬nding the test vector that can differentiate the
good and faulty machines and that such fault is detectable)
or prove that it is undetectable (i.e. there is no test vector
that can differentiate the good and faulty machines). There
have been several structural algorithms for ATPG, such as D-
algorithm [1] and its advanced variants [2], [3].
There are two core problems in ATPG. One is how to
improve decision efï¬ciency under a given backtrack limit,
especially considering a large number of hard-to-detect faults
in todayâ€™s complex designs. There mainly exist two methods
to solve this problem. One is to utilize Boolean Satisï¬ability
(SAT) solver directly [4], [5]. Unlike structural ATPG working
on a circuit network, SAT-based ATPG makes use of symboliccalculation techniques to implement efï¬cient conï¬‚ict-driven
search on the Conjunctive Normal Form (CNF). Many SAT-
based ATPG algorithms have been proposed, such as TG-
Pro [6], TIGUAN [7], and PASSAT [8]. Similar SAT-based
techniques have been applied, so as to insert test points for
low-capture-power testing while maintaining the same fault
coverage [9].
Fig. 1. A hybrid computational ï¬‚ow
in ATPG, which begins at the struc-
tural ATPG and ends with the SAT.A hybrid computational
ï¬‚ow composed of struc-
tural ATPG and SAT-based
algorithms has been pro-
posed, as shown in Fig- in ATPG, which begins at the struc-
tural ATPG and ends with the SAT.A hybrid computational
ï¬‚ow composed of struc-
tural ATPG and SAT-based
algorithms has been pro-
posed, as shown in Fig-
ure 1 [4]. Here, the struc-
tural ATPG algorithm is
adopted ï¬rstly under a
given backtrack limit and
it targets relatively easy-
to-detect faults, which can
be detected via a test
pattern or proved to be
undetectable. Then SAT
targets the hard-to-detect
faults which are aborted
by the structural ATPG.
Unlike structural ATPG,
which is performed directly on the circuit, SAT-based algo-
rithms rely on the CNF transformed from the logic cone of
fault propagation and activation. This transformation is an
extra step in SAT-based algorithms.
Fig. 2. Comparison between the CNF generation time vs. solving
time (in CPU microseconds). The horizontal axis is the fault index,
while the vertical axis is the respective runtime.
Take one circuit Stuck 4as an example (with additional
details provided in Section IV), we demonstrate a signiï¬cant
challenge for SAT in Figure 2. The ï¬gure examines the time
required for the transformation from the circuit to CNF in
comparison to the related solving time. All targeted faults are
stuck-at, and the SAT-based framework follows TG-Pro [6].
The chosen SAT Solver is Kissat [10], a reference SAT solverarXiv:2303.02290v1  [cs.AI]  4 Mar 2023 in SAT competition 2022. It is revealed that the transforma-
tion process requires more runtime than solving itself. This
indicates that despite the signiï¬cant advancements made in
SAT solver, which have displayed considerable potential in
solving ATPG problems [5], the additional overhead required
for CNF transformation limits SATâ€™s applications in industrial
ATPG. Several works have been done to alleviate this problem.
An incremental SAT-based framework has been proposed
which aims to generate CNF incrementally and ï¬nd the ï¬nal
solutions, or prove UNSAT, via partial CNF, hence decreasing
the transformation time as well as solving time on average [4].
Preprocessing methods have been utilized to simplify the logic
cone of fault propagation and activation, leading to a decrease
in the generation and solving time by solving an equivalent
substitute [11].
Nevertheless, the CNF transformation on large-scale circuits
remains a big bottleneck, resulting in utilizing SAT solver
being directly limited. Thus, the second method is to attempt
to utilize SATâ€™s heuristics on the circuit. A conï¬‚ict-driven
recursive learning which combines with a dynamic decision
ordering technique has been proposed to resolve hard-to-
resolve faults [12]. A conï¬‚ict-driven implication method has
been proposed to improve the justiï¬cation efï¬ciency and avoid
the over-speciï¬cations of test vectors [13]. An untestable
debug algorithm has also been utilized for low test coverage
analysis [14]. However, the method of constructing learning
conï¬‚icts in modern SAT solvers, like the unique implication
point (UIP), has not been considered.
The other problem is that the ATPG constraints are usually
conservative during the early stage of the design [14]. The
conservatism often results in the implementation not being
sufï¬ciently mature in practice. Therefore, in the early stages,
the DFT engineers have some degree of freedom to relax or
modify certain constraints, making that some of the aborted
faults as well as untestable faults which are not led by the
circuit structure can be potentially resolved. To address this
issue, we employ a conï¬‚ict diagnosis approach after running
ATPG engine to resolve low test coverage. Take one aborted
fault as an example. We consider that the reason for abortion
is due to the encountered conï¬‚icts exceeding the backtrack
limit. Finally, the statistical analysis for the learnt conï¬‚icts
would provide meaningful suggestions to the DFT engineer,
leading to a decrease in the number of aborted or untestable
faults and improving the coverage rate.
Motivated by the aforementioned discussions, this paper
proposes a conï¬‚ict-driven structural learning (CDSL) ATPG
algorithm, which aims to utilize the advantages brought by
the structural ATPG and SAT-based algorithms. To summarize,
our contributions include:
(i)We ï¬rst build learnt conï¬‚ict-based constraints di-
rectly on circuit, aiming to prune the searching space by using
the optimization process data. According to the implication
graph which is directly related to the decision-making process,
we construct two kinds of conï¬‚ict constraints, i.e., decision-
variable-based constraint and UIP-based constraint, leading to
avoiding meaningless searching in subsequent iterations.
(ii)We adopt the conï¬‚ict-driven decision rules to im-
prove the decision accuracy. After accumulating the learnt
conï¬‚icts, we construct new implications and justiï¬cation
approaches based on those conï¬‚icts. Extensive experiments
demonstrate the effectiveness of conï¬‚ict constraints on impli-cation efï¬ciency with fewer backtracks and aborted faults.
(iii)We further construct the conï¬‚ict diagnosis accord-
ing to the learnt conï¬‚icts in the case of low coverage debug.
In this method, we utilize the learnt conï¬‚icts to analyze the
reason from PIsâ€™ constraints and relax or modify certain of
them, aiming at further improving the test coverage rate.
The remainder of this paper is organized as follows. After reason from PIsâ€™ constraints and relax or modify certain of
them, aiming at further improving the test coverage rate.
The remainder of this paper is organized as follows. After
some preliminaries in Section II, Section III presents our new
SAT-based ATPG approach. Experimental results are demon-
strated in Section IV, in which we show the effectiveness of
the proposed framework both on solution quality and runtime.
Finally, we conclude this work in Section V.
II. P RELIMINARIES
A. Conï¬‚ict-Driven-Clause-Learning (CDCL) in SAT
SAT-based ATPG makes use of efï¬cient SAT solvers to
solve APTG problems. It begins with building a CNF format
SAT model which represents the fault condition and prop-
agation between the PIs and the POs. In general, a CNF
formulaconsists of a conjunction of clauses !, each of
which denotes a disjunction of literals. A literal is either a
variablexior its complement. Each variable can be assigned
a logic value, either 0or1. Any general Boolean problems
can be represented as a CNF formula model. A SAT solver
either ï¬nds an assignment such that is satisï¬ed, or proves
that no such assignment exists, i.e., UNSAT. A key heuristics
in modern SAT solver is Conï¬‚ict-Driven-Clause-Learning
(CDCL) algorithm [5]. In general, CDCL is a Branch-and-
Bound (BB) search framework, in which each step a literal and
a propositional value (either 0 or 1) are selected for branching
purposes. A key characteristic of CDCL is to learn new clauses
from conï¬‚icts during backtrack searches.
B. Structural ATPG Algorithm
Different from SAT-based algorithms, the structural ATPG
algorithm is performed on the circuit directly. Until now,
several kinds of algorithms like D-algorithm, PODEM, and
FAN have been proposed. In practice, D-algorithm tries to
propagate the stuck-at-fault value denoted by D(for Stuck-
at-0) orD(for Stuck-at-1) to a primary output (PO) [1].
The conventional D-algorithm generates a decision structure
to evaluate the value of every node in the circuit to obtain
the test vectors. PODEM and FAN are the advanced variants
by limiting the searching space and accelerating backtracing,
while PODEM limits the searching space only to Primary
Inputs (PIs) [15], and FAN limits the searching space to
headlines [16].
C. Comparison between Structural ATPG and CDCL
There exists a certain difference between CDCL and
structural ATPG algorithm. The ï¬rst difference must root
in the branching rules. The structural ATPG algorithm is
requirement-driven [1], which denotes that the decision or-
der accords with the fault propagation and circuit structural
characteristics. Unlike this, the initial decision order in CDCL
accords to the input literal order which is random, and this
order is modiï¬ed based on the literalâ€™s frequency in learnt
conï¬‚ict constraints after some backtracks. The second differ-
ence roots the backtrack rules after conï¬‚ict occurs. We take an
example to discuss other differences, as shown in Figure 3. All
the decision variables ( x0,x2,x3, andx4) are in square boxes, while all the implicated variables are in oval boxes. Each
decision variable is assigned with a decision level according
to the decision order. The direction of the arrow is consistent
with the direction of the implication.
Fig. 3. An example of a decision-
making process. All decision vari-
ables are in square boxes, and
implications in are in oval boxes.
The related decision level is also
labeled.Figure 3 shows that, af-
ter the fourth decision vari-
able, a conï¬‚ict occurs (i.e.,
x8cannot be 0and1at the
same time). In the structural
ATPG algorithm, the deci-
sion pointer will backtrack
to the last decision variable
(i.e.,x3), but without analy-
sis of the reason for the oc-
currence of conï¬‚icts. In the
given conï¬‚ict-driven meth-
ods [12]â€“[14], there will be
added one learnt conï¬‚ict
constraintx4 6= 1 , which
limits the following impli-
cations under new searching
rules. Apparently, a better
searching strategy must combine both advantages of struc-
tural ATPG and CDCL, i.e., the branching rules follow the
structural ATPG algorithm which aims to decrease the cost of
wrong decisions, while once conï¬‚ict occurs, the reasons for
conï¬‚ict should be considered like CDCL to avoid same wrong
searching path.
III. P ROPOSED CDSL A LGORITHM
Fig. 4. New proposed CDSL algorithm. Different from the conven-
tional structural ATPG algorithm, we incorporate SATâ€™s heuristics
such as learnt conï¬‚ict constraints, conï¬‚ict-driven implication, and
conï¬‚ict-driven branch/decision, aiming to prune the searching space
based on data from the optimization process and ï¬nd solutions
or prove UNSAT, with fewer backtracks. After the new ATPG
computation, we propose to add the conï¬‚ict diagnosis in case of
low coverage.
Considering the above, we propose a conï¬‚ict-driven struc-
tural learning (CDSL) ATPG algorithm which combines two
methods, as shown in Figure 4. Compared with the con-
ventional structural ATPG and SAT-based ATPG algorithms,
the CDSL algorithm has two advantages: (1) It accumulatesconï¬‚ict constraints after backtracks, with the aim of avoiding
the same wrong decisions and ï¬nding solutions with fewer
backtracks. (2) It employs conï¬‚ict-driven implications to prune
the searching space and conï¬‚ict-driven branching rules, with
a score heuristics, to improve decision accuracy.
Given a fault site, we ï¬rst trace the circuit to get the logic
cone related to fault propagation and activation. The decision
rules begin at the fault site and follow the conventional struc-
tural ATPG algorithm until one conï¬‚ict occurs. In the process,
all structural ATPG algorithms like D-algorithm, PODEM, and
FAN can be used.
A. Implication Graph
Firstly, we construct an implication graph according to the
decision-making process:
(1) We construct a directed acyclic graph in which each
vertex represents a variableâ€™s assignment, and each incident
edge to a vertex represents the reason leading to that assign-
ment. If one implication is inferred via other implications,
there also exists an edge among different implications. Thus,
decision variables have no incident edges in contrast to implied
variables that have assignments forced during propagation.
(2) Each decision variable is assigned a decision level ac-
cording to the related decision-making order, while its related
implications have the same decision level.
Note that each variable in CDSLâ€™s implication graph denotes
a logic gate. Once a conï¬‚ict occurs, the proposed CDSL
algorithm would trace the implication graph to ï¬nd all the his-
torical assignments which result in the conï¬‚ict and construct
learnt conï¬‚ict constraint.
B. Learnt Conï¬‚ict Constraints
Take Figure 3 as an example, in which a conï¬‚ict occurs
throughx8, we construct two kinds of learnt conï¬‚ict con-
straints in the proposed CDSL algorithm.
(1) Decision Variable-based Conï¬‚ict. The basic principle
is that the current conï¬‚ict, at least, is caused by all historical
decision variables. As shown in Figure 3, before the conï¬‚ict (1) Decision Variable-based Conï¬‚ict. The basic principle
is that the current conï¬‚ict, at least, is caused by all historical
decision variables. As shown in Figure 3, before the conï¬‚ict
occurs, there are four decision variables, i.e., x0= 1,x1= 1
x2= 1 ,x3= 1 andx4= 1 , thereby we can add a
learnt conï¬‚ict constraint as x0+x1+x2+x3+x4that
is constructed via the decision variables. It denotes that in
the following decision-making process, even though the four
variables can serve as decision variables, they cannot repeat
the same assignments, in other words, when it is found that
three of these variables repeat the historical assignments, the
fourth variable must take the opposite assignment.
(2) Unique Implication Point (UIP)-based Conï¬‚ict. A
UIP is a special node that any node at the current decision
level such that any path from the decision variable to the
conï¬‚ict node must pass through it [17]. As shown in Figure 3,
the conï¬‚ict occurs in node x8whose decision level is 4. The
inference of UIP-based learnt conï¬‚ict constraints can be given
as follows:
(i) We ï¬rst ï¬nd the direct reason for the conï¬‚ict node.
Figure 3 exhibits that one x8â€™s direct reasons are x4andx7,
and the other x8â€™s direct reason is x0andx2. Hereby, both
x0,x2, andx4are decision variables and their decision level
is0,2, and 4, respectively. x7is implications from x4,x5,
andx9. Thus, the direct learnt conï¬‚ict constraint can be given
asx0+x2+x4+x7. (ii) Check the decision level, and we should decide whether
some of the reason nodes are replaced by the corresponding
parents. The evaluation rule is that in the ï¬nal learnt conï¬‚ict
constraint, there exists only one variable whose decision level
is the same as the conï¬‚ict node, and this variable is UIP.
(ii-a) Consider x0+x2+x4+x7, since both x7,x9, and
x4are in decision level 4andx4is a decision variable, we
utilizex7â€™s parent nodes (i.e., x4,x5andx9) to replace it.
After deduplication, the learnt conï¬‚ict constraint is updated
asx0+x2+x4+x5+x9, in which the decision levels of x5
andx9are3and4, respectively.
(ii-b) Since x9andx4are in the same decision level, we
utilizex9â€™s parents (i.e., z1,x3andx4) to replace it, and then
the learnt conï¬‚ict is updated as x0+x2+x4+x5+z1+x3.
Finally, we can obtain the UIP-based learnt conï¬‚ict con-
straint asx0+x2+x4+x5+z1+x3. Considering that the
only variable whose decision level is the same as the conï¬‚ict
node isx4, thus,x4serves as the UIP node. Note that we
only show the learnt relationship among different variables,
not including the logic values. After accumulating different
learnt conï¬‚ict constraints, the proposed CDSL algorithm will
utilize those in the following three aspects:
C.Conï¬‚ict-driven Implications
All learnt conï¬‚ict constraints are applied for the implication
phase, aiming to avoid repeating the wrong searching paths.
Take the UIP-based learnt conï¬‚ict constraint x0+x2+x4+
x5+z1+x3of Figure 3 as an example, if we ï¬nd that ï¬ve of
the related variables (i.e., x0,x2,x4,x5andz1) have the same
assignments with historical ones, the sixth must be assigned as
the opposite value. To avoid the extra computational overhead
when too many learnt conï¬‚ict constraints are accumulated,
we also add a forgotten rule in the implication phase: if one
learnt conï¬‚ict constraint is not utilized in recent Nloops,
this constraint is considered to be no longer relevant and
it would be deleted in the following loops. Hereby, Nis a
hyperparameter.
D.Conï¬‚ict-driven Branch Heuristics
The learnt conï¬‚ict constraints can also be applied through
Variable State Independent Decaying Sum (VSIDS) heuristic,
aiming to improve the decision accuracy in the following
decision phase. There are three steps in the VSIDS strategy:
a) We start by assigning each variable a ï¬‚oating point
score. When a conï¬‚ict occurs, the activity of some variables
is increased by 1. In general, the initial score is set to 0.
b) After each conï¬‚ict, the variable activity is decayed
periodically, aiming to trade off the historical decisions and
following ones. Such decay factor is set [0;1].
c) To balance VSIDS and structural strategies, we would
check each variableâ€™s score during branching. The variable
with the highest score is selected under a given probability.
Further, different from the structural ATPG algorithm which
requires backtracking to the last decision variable, we adopt
anon-chronological backtrack rule in the proposed CDSL
algorithm. This rule accords with the UIP-based conï¬‚ict con-
straint, and the backtrack point is the variable that is with the
largest decision level except for the UIP node. Take Figure 3
as an example, the scores of x0,x5,x3andx4are higher
than othersâ€™ after both decision-variable-based and UIP-based
conï¬‚ict constraints are accumulated, and once one conï¬‚ict
occurs, the backtrack point is chosen as x3.E. Conï¬‚ict Diagnosis for Low Coverage Debug
Except for the implications and branching, we also explore
adopting the conï¬‚ict diagnosis to beat the low test coverage
in the initial phase of design:
(i) Compute each logic gateâ€™s score according to the fre-
quency in the learnt conï¬‚ict constraints.
(ii) Choose the top-k gates according to the scoreâ€™s rank.
Then trace the circuit to ï¬nd the related external constraints.
Usually, those constraints are put on either primary inputs or
the fan-in gates of decision level 0.
In conï¬‚ict diagnosis, we choose to relax or modify the Usually, those constraints are put on either primary inputs or
the fan-in gates of decision level 0.
In conï¬‚ict diagnosis, we choose to relax or modify the
identiï¬ed external ATPG constraints, which would provide an
opportunity to make the aborted or untestable fault testable.
IV. E XPERIMENTAL RESULTS
A. Experiments Setup
In this section, we aim to evaluate the proposed CDSL
algorithm from the following three aspects:
RQ1 : Can it have a performance advantage over the traditional
SAT-based algorithms?
RQ2 : Can it be beneï¬cial for improving test coverage compared
to the structural algorithm?
RQ3 : Can the conï¬‚ict diagnosis be exploited to debug the
aborted or untestable faults?
In the following, the CDSL framework is implemented on the
structural D-algorithm. and its performance is evaluated from
two perspectives, one is the number of aborted faults (unob-
served faults, abbreviated as UO) under the set aborted limit,
the other one is fault coverage rate, i.e., Fault Coverage =
NTestable
NTotal, whereNTotal andNTestable are the number of
total faults and testable faults, respectively. All experiments
are carried out for industrial circuits, and their designs are
shown in Table I.
TABLE I
DESIGN CHARACTERISTICS
Circuit Fault Type #gates #State Circuit Fault Type #gates #State
Stuck 1 Stuck-at 246078 14979 Tran 1 Transition 139871 9644
Stuck 2 Stuck-at 246078 14979 Tran 2 Transition 785559 26288
Stuck 3 Stuck-at 221004 18190 Tran 3 Transition 785559 383963
Stuck 4 Stuck-at 78600 12047 Tran 4 Transition 785559 357483
Stuck 5 Stuck-at 221004 18190 Tran 5 Transition 221004 357483
Stuck 6 Stuck-at 206221 15772 Tran 6 Transition 221004 331291
Stuck 7 Stuck-at 56586 8194 Tran 7 Transition 221004 374009
Stuck 8 Stuck-at 221004 357483 Tran 8 Transition 206221 331291
Stuck 9 Stuck-at 246078 331291 Tran 9 Transition 206221 331291
Stuck 10 Stuck-at 785559 26288 Tran 10 Transition 221004 331291
B. Evaluation on Run Time
To answer RQ1 , we choose stuck-at faults to compare
the proposed CDSL with SAT-based methods, as shown in
Table II. The ï¬rst column is the circuit name. The second
and third columns show the number of aborted faults led by
the proposed CDSL algorithm and related run time (in CPU
seconds), respectively. Hereby, the aborted limit is set as 100.
Then from left to right, there are four different baselines to
evaluate the CDSL algorithm:
i) A basic SAT-based framework, TG-Pro [6]. It is also the
latest open-source framework. The SAT solver is chosen as
Kissat2022 [10]. ii) The basic D-algorithm. It is also a module of the
proposed CDSL algorithm.
iii) An incremental SAT-based ATPG method with prepro-
cessing procedure [4].
iv) A SAT-based ATPG method with a fault analysis mod-
ule [18], which is a trained neural network and predicts the
fault classiï¬cation for appropriate algorithm selection.
It is shown that compared with the conventional SAT-
based ATPG and structural D-algorithm, the proposed CDSL
algorithm can decrease the aborted faults by 25:6% and
49:88% on average, while the run time is decreased by 94:51%
and25:88%, respectively. Although the two new variants, i.e.,
the SAT-based ATPG with preprocessing or with the learnt
network-based fault analysis can lead to fewer aborted faults
and better run time, the proposed CDSL can also decrease the
UO by 45:23% and12:35%, respectively, and the related run
time can be decreased 58:79% and93:09%.
It is worth mentioning that when the backtrack limit is the
same, both the conventional structural ATPG and the proposed
CDSL algorithm can lead to fewer aborted faults than SAT-
based methods. It is because the SATâ€™s heuristics, such as
branching, restart, and local search, totally rely on the score
based on accumulated conï¬‚icts. It denotes that the limited
conï¬‚ict constraints may affect the performance of heuristics.
TABLE II
PERFORMANCE OF CDSL ONUO AND RUNTIME
CircuitCDSL TG-Pro Structural Incre Neural
UO time UO time UO time UO time UO time
Stuck 1 147 229 174 10952 226 814 162 1528 162 9125
Stuck 2 352 167 559 1722 793 128 638 218 475 1522
Stuck 3 253 33 195 780 271 58 139 678 175 672
Stuck 4 1 53 7 1103 8 101 12 206 7 856
Stuck 5 144 18 119 393 158 36 105 79 110 326
Stuck 6 1343 365 1318 5165 1949 1307 2125 806 986 4238
Stuck 7 236 97 485 1389 453 92 383 234 429 1109
Stuck 8 601 550 518 10543 664 498 836 631 492 7692
Stuck 9 514 75 987 977 1303 812 1189 235 836 901
Stuck 10 545 878 1197 11931 1028 984 1963 1368 975 9312
Average 414 247 556 4496 825 333 755 598 465 3569
Improvement / / 25.6%94.51%49.88%25.88%45.23%58.79%12.35%93.09%
C. Evaluation on Coverage Rate
To further compare the proposed CDSL with the structural
algorithm, we construct a two-stage ATPG framework on
transition faults. (i) In the ï¬rst stage, we set a relatively
small backtrack limit and close the conï¬‚ict-driven modules.
We aim at handling the easy-to-detect faults with a relatively
small aborted limit (The aborted limit is set 20). (ii) In the
second stage, we set a relatively large aborted limit and the
proposed CDSL algorithm targets the aborted faults (The
aborted limit is set at 100). There are two baselines in the
following experiments: (1) The ï¬rst baseline is the one-stage
conventional D-algorithm. (2) The second is also a two-stage
algorithm, but the conï¬‚ict-driven modules are closed in both
two stages. The results are shown in Table III.It is found that the one-stage conventional D-algorithm
results in 8702 aborted faults on average, and the fault cov-
erage rate is 92:95%. However, when the same D-algorithm
is armed with a two-stage setting, the aborted fault can be
decreased to 5975 and the fault coverage rate can reach
95:21%. Further, when the proposed CDSL is implemented
with a two-stage setting, aborted faults can be decreased to
4667 , and the fault coverage rate can be increased to 96:14%.
In other words, compared with the D-algorithm, the aborted
faults can be decreased via 46:37% and the fault coverage
rate can be increased via 3:19%, while compared with the
two-stage algorithm which is without conï¬‚ict-driven modules,
the aborted faults can be decreased via 21:89% and the fault
coverage rate is increased via 0:93%.
TABLE III
EVALUATION IN A TWO-STAGE FRAMEWORK
CircuitOne-Stage without Conï¬‚ict Prop Model
UO coverage UO coverage UO coverage
Tran 1 505 95.57% 402 96.785% 353 97.149%
Tran 2 32319 98.71% 22710 99.109% 17154 99.325%
Tran 3 105 97.86% 119 98.867% 98 99.029%
Tran 4 604 97.59% 320 98.611% 214 98.928%
Tran 5 5414 91.71% 3769 94.678% 2943 95.795% Tran 2 32319 98.71% 22710 99.109% 17154 99.325%
Tran 3 105 97.86% 119 98.867% 98 99.029%
Tran 4 604 97.59% 320 98.611% 214 98.928%
Tran 5 5414 91.71% 3769 94.678% 2943 95.795%
Tran 6 13211 90.55% 9110 93.548% 7339 94.777%
Tran 7 14037 90.15% 9462 93.383% 7615 94.634%
Tran 8 13436 90.50% 9152 93.603% 7364 94.819%
Tran 9 1641 88.34% 671 91.342% 526 93.011%
Tran 10 5757 88.53% 4043 92.25% 3067 93.97%
Average 8702 92.95% 5975 95.21% 4667 96.14 %
Improvement 46.37% 3.19% 21.89% 0.93% / /
D. Evaluation on Conï¬‚ict Diagnosis
Finally, we evaluate the conï¬‚ict diagnosis in the case of low
coverage analysis. As described in Section III-E, according to
the accumulated learnt conï¬‚icts, we ï¬rst mark the top 5logic
gates. After tracing the circuits from the labeled logic gates,
the conï¬‚ict-related PI nodes are found, and the corresponding
logic value is marked as N(supposing that there are N
related PI nodes). If there exist constraints on the found PI
nodes, we would relax such constraints. Otherwise, if there are
not any constraints on one of the found PI nodes, we prefer
to add a constraint on this node and the logic value is the
opposite of. Finally, we recall the ATPG engine to generate
the test pattern or prove the untestability. The results are given
in Table IV. It is shown that after the conï¬‚ict diagnosis, the
aborted faults decrease 8:89% on average, while the fault
coverage rates increase by 0:271% .
V. C ONCLUSIONS
Aiming at addressing the efï¬ciency problem brought by
the SAT-based framework but exploiting efï¬cient heuristics
of modern SAT solver, we have proposed conï¬‚ict-driven
structural learning (CDSL) ATPG algorithm in this paper,
which allows the structural ATPG to beneï¬t from the SATâ€™s TABLE IV
EVALUATION ON CONFLICT DIAGNOSIS
Circuit UO Coverage Circuit UO Coverage
Stuck 1 554 99.120% Tran 1 306 97.337%
Stuck 2 522 99.010% Tran 2 14928 99.505%
Stuck 3 920 98.606% Tran 3 82 99.210%
Stuck 4 8 99.803% Tran 4 126 98.600%
Stuck 5 852 97.679% Tran 5 2812 96.004%
Stuck 6 35 99.786% Tran 6 7002 95.232%
Stuck 7 392 98.938% Tran 7 7213 94.887%
Stuck 8 2356 96.022% Tran 8 6579 94.872%
Stuck 9 5910 95.931% Tran 9 442 93.859%
Stuck 10 3827 99.873% Tran 10 2913 93.953%
techniques such as conï¬‚ict management and conï¬‚ict-driven
branching. The proposed CDSL algorithm is composed of
three parts: (1) Learnt conï¬‚ict constraints before each back-
track has been constructed, aiming to learn from the mistakes
and utilize the optimization process data to prune search
space. (2) Conï¬‚ict-driven implication and justiï¬cation have
been applied for decisions and implications, aiming to further
increase the solving efï¬ciency and decision effectiveness. (3)
Conï¬‚ict diagnosis based on the analysis of the learnt conï¬‚icts
has been attempted to improve test and fault coverage rate
by relaxing some of the external ATPG constraints. Extensive
experimental results on industrial circuits have demonstrated
the advantage of the proposed CDSL ATPG algorithm in three
aspects: (i) Comparing with the conventional SAT-based ATPG
and structural D-algorithm, the proposed CDSL algorithm
has decreased the aborted faults by 25:6%and49:88% on
average, while the run time is decreased by 94:51% and
25:88%, respectively. (ii) With a two-stage setting, compared
with the D-algorithm, the aborted faults can be decreased via
46:37% and the fault coverage rate can be increased via 3:19%,
while compared with the two-stage algorithm which is without
conï¬‚ict-driven modules, the aborted faults can be decreased
via21:89% and fault coverage rate is increased via 0:93%.
(iii) Conï¬‚ict diagnosis has been shown to decrease the aborted
faults via 8:89% on average while increasing the fault coverage
rate0:271% . Future work includes the development of more
SAT heuristics on structural ATPG heuristics.
REFERENCES
[1] J. P. Roth, â€œDiagnosis of automata failures: A calculus
and a method,â€ IBM J. Res. Develop. , vol. 10, pp. 278â€“
291, 1966.
[2] N. Wang, C. Wang, K.-H. Tsai, W.-T. Cheng, X. Lin,
M. Kassab, and I. Pomeranz, â€œTea: A test generation
algorithm for designs with timing exceptions,â€ Asian Test
Symposium , pp. 19â€“195, 2019.
[3] M. Schulz, E. Trischler, and T. Sarfert, â€œSocrates: A
highly efï¬cient automatic test pattern generation system,â€
International Test Conference , pp. 1016â€“1026, 1987.
[4] J. Huang, H. L. Zhen, N. Wang, M. Yuan, H. Mao,
Y . Huang, and J. Tao, â€œAccelerate sat-based atpg via
preprocessing and new conï¬‚ict management heuristics,â€
27th Asia and South Paciï¬c Design Automation Confer-
ence (ASP-DAC) , pp. 365â€“370, 2022.[5] B. Becker, R. Drechsler, and M. Sauer, â€œRecent advances
in sat-based atpg: Non-standard fault models, multi
constraints and optimization,â€ International Conference
on Design and Technology of Integrated Systems in
Nanoscale Era , pp. 1â€“10, 2014.
[6] H. Chen and J. Marques-silva, â€œTg-pro: A sat-based
atpg system system description,â€ Journal on Satisï¬ability,
Boolean Modeling and Computation , vol. 8, no. 1-2, pp.
83â€“88, 2011.
[7] A. Czutro, I. Polian, M. Lewis, P. Engelke, S. M. Reddy,
and B. Becker, â€œTiguan: Thread-parallel integrated test
pattern generator utilizing satisï¬ability analysis,â€ Inter-
national Conference on VLSI Design , pp. 227â€“232, 2009.
[8] S. Eggersgl Â¨uÃŸ, K. Schmitz, R. Krenz-B ËšaËšath, and
R. Drechsler, â€œOn optimization-based atpg and its appli-
cation for highly compacted test sets.â€ IEEE Transactions
on Computer-Aided Design of Integrated Circuits and
Systems. , pp. 2104â€“2117, 2016.
[9] S. Eggersgl Â¨uÃŸ, S. Holst, D. Tille, K. Miyase, and
X. Wen., â€œFormal test point insertion for region-based
low-capture-power compact at-speed scan test.â€ IEEE
Asian Test Symposium (ATS) , pp. 173â€“178, 2016. X. Wen., â€œFormal test point insertion for region-based
low-capture-power compact at-speed scan test.â€ IEEE
Asian Test Symposium (ATS) , pp. 173â€“178, 2016.
[10] M. S. Cherif, D. Habet, and C. Terrioux, â€œKissat mab:
Upper conï¬dence bound strategies to combine vsids and
chb,â€ SAT COMPETITION , 2022.
[11] D. Tille, S. Eggersgluss, and R. Drechsler, â€œIncremental
solving techniques for sat-based atpg,â€ IEEE Transac-
tions on Computer-Aided Design of Integrated Circuits
and Systems , vol. 29, no. 7, pp. 1125â€“1130, 2010.
[12] C. Wang, S. M. Reddy, I. Pomeranz, X. Lin, and J. Ra-
jski, â€œConï¬‚ict driven techniques for improving determin-
istic test pattern generation.â€ IEEE/ACM international
conference on Computer-aided design , pp. 87â€“93, 2002.
[13] S. Bommu, K. Chandrasekar, R. Kundu, and S. Sengupta,
â€œConcat: Conï¬‚ict driven learning in atpg for industrial
designs.â€ IEEE International Test Conference (ITC) , pp.
1â€“10, 2008.
[14] C. Kameshwar, S. Bommu, and S. Sengupta., â€œLow
coverage analysis using dynamic un-testability debug in
atpg.â€ IEEE VLSI Test Symposium (VTS) , pp. 291â€“296,
2011.
[15] P. Goel, â€œAn implicit enumeration algorithm to gener-
ate tests for combinational logic circuits,â€ IEEE Trans.
Comput. , vol. C-30, pp. 215â€“222, 1981.
[16] K. T. and M. R. Mercer, â€œA topological search algorithm
for atpg.â€ In 24th ACM/IEEE Design Automation Con-
ference , pp. 502â€“508, 1987.
[17] M.-S. Joao, I. Lynce, and S. Malik., â€œConï¬‚ict-driven
clause learning sat solvers. handbook of satisï¬ability.â€
IOS Press , pp. 133â€“182, 2021.
[18] J. Huang, H. L. Zhen, N. Wang, M. Yuan, H. Mao,
and Y . Huang, â€œNeural fault analysis for sat-based atpg.â€
IEEE International Test Conference (ITC) , pp. 36â€“45,
2022."," This paper proposes a Conflict-Driven Structural Learning (CDSL) ATPG algorithm which combines the efficient heuristics of modern SAT solvers with the SAT-based framework to address the efficiency problem. The algorithm builds conflict-based constraints on the circuit to prune the search space, and adopts conflict-driven decision rules to improve decision accuracy. Additionally, a conflict diagnosis approach is used to analyze the reason for low coverage debug and modify certain constraints to improve the test coverage rate. Extensive experimental results demonstrate the effectiveness and efficiency of the proposed CDSL algorithm."
25," TopSpark: A Timestep Optimization Methodology for Energy-Efï¬cient
Spiking Neural Networks on Autonomous Mobile Agents
Rachmad Vidya Wicaksana Putraand Muhammad Shaï¬quey
Abstract â€” Autonomous mobile agents (e.g., mobile ground robots
and UA Vs) typically require low-power/energy-efï¬cient machine learn-
ing (ML) algorithms to complete their ML-based tasks (e.g., object
recognition) while adapting to diverse environments, as mobile agents
are usually powered by batteries. These requirements can be fulï¬lled
by Spiking Neural Networks (SNNs) as they offer low power/energy
processing due to their sparse computations and efï¬cient online learning
with bio-inspired learning mechanisms for adapting to different envi-
ronments. Recent works studied that the energy consumption of SNNs
can be optimized by reducing the computation time of each neuron
for processing a sequence of spikes (i.e., timestep). However, state-of-
the-art techniques rely on intensive design searches to determine ï¬xed
timestep settings for only the inference phase, thereby hindering the
SNN systems from achieving further energy efï¬ciency gains in both the
training and inference phases. These techniques also restrict the SNN
systems from performing efï¬cient online learning at run time. Toward
this, we propose TopSpark, a novel methodology that leverages adaptive
timestep reduction to enable energy-efï¬cient SNN processing in both
the training and inference phases, while keeping its accuracy close to
the accuracy of SNNs without timestep reduction. The key ideas of
our TopSpark include: (1) analyzing the impact of different timestep
settings on the accuracy; (2) identifying neuron parameters that have
a signiï¬cant impact on accuracy in different timesteps; (3) employing
parameter enhancements that make SNNs effectively perform learning
and inference using less spiking activity due to reduced timesteps; and
(4) developing a strategy to trade-off accuracy, latency, and energy to
meet the design requirements. The experimental results show that, our
TopSpark saves the SNN latency by 3.9x as well as energy consumption
by 3.5x for training and 3.3x for inference on average, across different
network sizes, learning rules, and workloads, while maintaining the
accuracy within 2% of that of SNNs without timestep reduction. In this
manner, TopSpark enables low-power/energy-efï¬cient SNN processing
for autonomous mobile agents.
I. I NTRODUCTION
Autonomous mobile agents (e.g., UGVs and UA Vs) usually
require low-power ML algorithms to complete their ML-based tasks
(e.g., object recognition through images/videos), since these agents
are typically powered by batteries [1]; see Fig. 1(a). Furthermore,
these mobile robots also require to continuously adapt to different
operational environments (so-called dynamic environments ) since
the ofï¬‚ine-trained knowledge is typically learnt from limited sam-
ples and may be obsolete at run time, hence leading to accuracy
degradation; see Fig. 1(a). These requirements can be fulï¬lled
by Spiking Neural Networks (SNNs) because of the following
two reasons. First, advancements in neuromorphic computing have
led SNNs to achieve ultra-low power/energy processing and high
accuracy by leveraging their bio-inspired spike-based operations
[2]â€“[4]. Second, SNNs employ bio-inspired learning rules locally in
each synapse, such as Spike-Timing-Dependent Plasticity (STDP),
which are suitable for efï¬cient online learning (i.e., training at run
time for updating the knowledge of systems using unlabeled data1),
thereby adapting to dynamic environments [5]â€“[7]. Furthermore,
Rachmad Vidya Wicaksana Putra is with the Institute of Computer
Engineering, Technische Universit Â¨at Wien (TU Wien), Vienna, Austria
rachmad.putra@tuwien.ac.atyMuhammad Shaï¬que is with the Division of Engineering, New York
University Abu Dhabi (NYUAD), Abu Dhabi, United Arab Emirates (UAE)
muhammad.shafique@nyu.edu
1Unlabeled data from environments can be leveraged for efï¬cient SNN University Abu Dhabi (NYUAD), Abu Dhabi, United Arab Emirates (UAE)
muhammad.shafique@nyu.edu
1Unlabeled data from environments can be leveraged for efï¬cient SNN
training at run time using STDP-based unsupervised learning.
(b)
input
â€¦excitatory 
neurons
weights learned 
using STDP inhibition
output5 neurons 
can recognize 
5 classesinput: 51
5
3
2
41
5
33 neurons 
can recognize 
3 classesinput: 5An autonomous mobile agent with 
a spiking neural network model
(e.g., mobile robot and UGV)
Volcanoes
(Environment 3)
The agent moves across different environments
â€¦
Adaptive to different operational environments
Deserts
(Environment 1)Forests
(Environment 2)(a)
Low -power /
energy -efficient  
processingrequires requires
Fig. 1. (a) Autonomous mobile agents typically require low-power pro-
cessing and capabilities for adapting to different operational environments to
complete ML-based tasks. (b) SNN architecture that supports STDP-based
unsupervised learning, i.e., fully-connected network. A larger SNN model
has a higher number of excitatory neurons to recognize more features than
a smaller one.
SNNs are also expected to provide high accuracy that meets the
applicationsâ€™ requirements. To achieve higher accuracy, larger-sized
SNN models are usually employed as they have a larger number
of neurons to recognize more input features than the smaller-sized
models; see Fig. 1(b). For instance, the work of [8] studied that
a network with 3600 excitatory neurons achieves 90% accuracy
for the MNIST, while a network with 100 excitatory neurons only
achieves 75%. However, SNN hardware platforms for embedded
applications (e.g., mobile robots) typically have limited memory
and compute capabilities [9], thereby making it challenging to
achieve both high energy efï¬ciency and high accuracy for SNNs
at the same time. To address this, previous works have explored
different optimization methodologies [8] [10]â€“[13]. However, most
of them have not optimized the computational time of a neuron
for processing input spikes (i.e., timestep) , which also has the
potential to substantially reduce the energy consumption of SNN
processing, while preserving the excitatory neurons to recognize
diverse features.
Targeted Research Problem: How can we improve the energy
efï¬ciency of SNN processing in both the training and inference
phases through timestep optimizations, while maintaining the ac-
curacy high. An efï¬cient solution to this problem will enable low-
latency and energy-efï¬cient autonomous mobile agents/robots that
can adapt to different environments.
A. State-of-the-Art and Their Limitations
State-of-the-art works have employed different timestep reduction
techniques to optimize the energy consumption of SNN inference,
while achieving acceptable accuracy [14]â€“[17]. For instance, thearXiv:2303.01826v1  [cs.NE]  3 Mar 2023 020406080100
0 50 100 150 200 250 300 350Accuracy [%]
TimestepBaseline 
accuracyAccuracy is comparable to the baseline accuracy
Notable accuracy degradation(a)
(b)
0.00.20.40.60.81.0
10
20
30
40
50
100
150
175
200
250
350Latency Energy
0.00.20.40.60.81.010
20
30
40
50
100
150
175
200
250
350
TimestepTraining InferenceLatency
(Normalized to 
Timestep 350)
Energy 
(Normalized to 
Timestep 350)Latency & energy are saved as the timestep is reduced Fig. 2. Experimental results considering an SNN with 400 excitatory
neurons with a fully-connected architecture in Fig. 1(a), rate coding, and
pair-based STDP [10] under different timesteps in training and inference:
(a) accuracy proï¬les; (b) latency and energy consumption normalized to
timestep 350.
work of [14] trained binary-weighted SNNs and then studied the
impact of different timesteps on accuracy. Another work performed
a gradient descent-based retraining method to learn the parameter
values while considering reduced timesteps [15]. Similarly, the
work of [16] gradually reduced the timesteps while retraining the
network. Meanwhile, a recent work employed search algorithms to
ï¬nd the appropriate timestep reduction [17].
Limitations: State-of-the-art works only employed ï¬xed
timesteps for SNN inference, through costly (re)training [14]â€“[16]
and costly intensive searches [17]. Therefore, the existing tech-
niques limit the SNN systems from further energy efï¬ciency gains
in both the training and inference phases. These techniques also hin-
der the SNN systems from performing efï¬cient online learning/ï¬ne-
tuning through training at run-time. Furthermore, smart AI-based
systems usually need to adjust their accuracy for better battery
life at run time [18], thereby requiring adaptive trade-offs between
accuracy, latency, and energy, which cannot be accommodated by
the existing techniques.
To address these limitations, a timestep optimization technique
for both the training and inference phases is required . This solution
will enable efï¬cient SNN training and inference with smaller
timesteps (i.e., lower latency) and lower energy consumption.
Moreover, this efï¬cient training can also be leveraged at run time
to enable efï¬cient online learning mechanisms.
To highlight the potential of timestep reduction in SNN pro-
cessing, we present an experimental case study in the following
Section I-B.
B. Motivational Case Study and Key Challenges
We study the accuracy, latency, and energy consumption proï¬les
of an SNN model considering different timesteps. To do this, we
perform experiments employing a fully-connected SNN with 400
neurons, rate coding, and pair-wise STDP in unsupervised learning
settings [10]. For each timestep setting, we perform training and
inference using the MNIST dataset2. Detailed information on the
experimental setup will be discussed in Section IV. The experimen-
tal results are shown in Fig. 2, from which we draw the following
key observations .
Accuracy scores are typically proportional to timestep settings
due to the spiking activity, i.e., smaller timestep leads to lower
2The MNIST dataset is commonly used in SNN community for evaluating
SNNs with unsupervised learning settings [2] [8] [10].accuracy, and larger timestep leads to higher accuracy; see
Fig. 2(a).
Accuracy proï¬le of an SNN with timestep reduction may have
two regions, compared to the baseline accuracy (i.e., an SNN
without timestep reduction): (1) a region with comparable ac-
curacy, and (2) a region with notable accuracy degradation; see
Fig. 2(a).
Timestep reduction can effectively save the latency and energy
consumption of SNN processing in both the training and infer-
ence phases due to reduced neuron and learning operations; see
Fig. 2(b).
Although reducing timesteps can effectively curtail the latency
and energy consumption of SNN processing, aggressive reductions
in the timestep may signiï¬cantly decrease the accuracy , thereby
limiting the applicability of timestep reduction techniques for and energy consumption of SNN processing, aggressive reductions
in the timestep may signiï¬cantly decrease the accuracy , thereby
limiting the applicability of timestep reduction techniques for
improving the efï¬ciency gains of SNNs.
Research Challenges: Our experiments and observations expose
several design challenges that should be solved to address the
targeted problem, as discussed in the following.
The solution should maximally reduce the timestep in the train-
ing and the inference to signiï¬cantly optimize the computation
latency and energy consumption of SNN processing, but without
noticeably degrading the accuracy.
The solution should effectively learn from reduced spiking activity
to maintain the learning quality as compared to the original SNNs
(i.e., without timestep reduction).
The optimization techniques should incur minimum overheads
(e.g., energy) to accommodate efï¬cient online learning and better
battery life management.
C. Our Novel Contributions
To address the research challenges, we propose TopSpark ,
a novel T imestep op timization methodology for energy efï¬cient
Spiking neura l network s in training and inference on autonomous
mobile agents . To the best of our knowledge, our TopSpark is the
ï¬rst work that optimizes timesteps of SNNs in both the training
and inference phases. Following are the novel steps performed in
the TopSpark methodology (see the overview in Fig. 3).
1)Analyzing the accuracy under different timesteps to investi-
gate the impact of timestep reduction in the SNN training and
inference on the accuracy proï¬les.
2)Analyzing the impact of neuron parameters to investigate the
role of neuron parameters and the inï¬‚uence of their values on
the accuracy proï¬les under different timesteps.
3)Devising parameter enhancement rules to maintain accuracy
by leveraging the knowledge from previous analysis steps,
thereby providing effective yet simple solutions with minimum
overheads.
4)Devising a strategy to trade-off accuracy, latency, and energy
to meet the constraints (i.e., target accuracy, target latency, and
energy budget), hence enabling a better battery life management.
Key Results: We evaluate TopSpark methodology using Python
simulations [19] on GPU machines to get the accuracy proï¬les and
leverage the computation time and power to estimate the latency and
energy consumption of SNN training and inference. Experimental
results with different workloads and STDP-based learning rules
show that, our TopSpark saves the latency by 3.9x and energy
consumption by 3.5x for training and 3.3x for inference on average,
while keeping the accuracy close to the SNNs without timestep
reduction.
II. P RELIMINARIES OF SNN S
Spiking neural networks (SNNs) are the neural networksâ€™ class
that employs bio-plausible computation models based on action â€¦
Enhanced SNN
Optimized timestepOur Novel Contributions
TopSpark Methodology (Section III)
Analysis of Accuracy Profiles (Section III -A)
Analysis of the Impact of Neuron 
Parameters on Accuracy (Section III -B)
Parameter Enhancements (Section III -C)
Design Trade -off Strategy (Section III -D)â€¦
Baseline SNN
Baseline timestep
Constraints (accuracy, 
latency, and energy)Fig. 3. An overview of our novel contributions (shown in blue boxes).
potentials (i.e., spikes) [2]. An SNN model has a speciï¬c neuron
model, network architecture, learning rule, and spike coding [8].
Neuron model deï¬nes how a neuron operates, updates its internal
dynamics (e.g., membrane potential), and generates output spikes
over time. The operational time of a neuron to process a sequence
of input spikes from a single input (e.g., an image pixel) is
deï¬ned as timestep [17]. Here, we consider the Leaky Integrate-
and-Fire (LIF) neuron model because it has been widely used
in the SNN community because of its simple yet highly bio-
plausible operations [8]; see an overview in Fig. 4. The LIF neuron
updates its membrane potential ( Vmem ) each timestep. Vmem is
increased each time an input spike comes, and otherwise, Vmem
is decreased. If Vmem reaches a deï¬ned threshold voltage ( Vth),
the neuron generates an output spike. Then, Vmem goes to the
reset potential ( Vmem ) and the neuron cannot generate spikes in
a deï¬ned refractory period ( Tref).
timestep
timestepVmem
VresetVth
incoming /input spikestimestepgenerated output spikes
Vth+ Î¸
Trefneuronal dynamics
Fig. 4. The neuronal dynamics of a LIF neuron model.
Network architecture determines the connections among neu-
rons, synapses, as well as inputs and outputs. In this work, we
consider a fully-connected network in Fig. 1(b) since it supports
unsupervised learning, which is required for enabling efï¬cient
online learning mechanisms. In such a network, each input (e.g.,
an image pixel) is connected to all excitatory neurons. Each
excitatory neuron is expected to recognize a speciï¬c class. Hence,
the connecting synapses are trained to learn the corresponding
features. For the learning rules , we consider the bio-plausible STDP
rules (i.e., pair-based weight-dependent STDP [10] and adaptive
learning rate STDP [8]) since they support unsupervised learning
scenarios to train the synaptic weights using unlabeled data from
operational environments, thus enabling efï¬cient online learning
mechanisms [5] [12]. To perform SNN processing, the input data
is converted into a sequence of spikes (i.e., spike train) using a
speciï¬c neural/spike coding . Here, we consider the rate coding
as it can be coupled with different STDP-based learning rules
for achieving high accuracy [10]. This rate coding uses Poisson
distribution to generate the spike train of each input (e.g., a pixel)
whose probability mass function ( Ppmf) is given by Eq. 1, with 
denotes the rate parameter, kdenotes the number of occurrences,
andedenotes the Eulersâ€™ number.
Ppmf =ke"," This paper presents TopSpark, a novel methodology for reducing the latency and energy consumption of spiking neural networks (SNNs) while maintaining high accuracy. Experiments show that TopSpark can reduce latency by 3.9x and energy consumption by 3.5x (training) and 3.3x (inference) on average, while keeping accuracy within 2% of SNNs without timestep reduction. This work may enable low-latency and energy-efficient SNN training and inference for autonomous mobile agents/robots, including their efficient online learning process."
26," arXiv:2303.01695v1  [cs.NE]  3 Mar 2023EVOLUTIONARY MULTI -OBJECTIVE ALGORITHMS FOR THE
KNAPSACK PROBLEMS WITH STOCHASTIC PROFITS
A P REPRINT
Kokila Perera
Optimisation and Logistics
School of Computer and Mathematical Sciences
The University of Adelaide
Adelaide, AustraliaAneta Neumann
Optimisation and Logistics
School of Computer and Mathematical Sciences
The University of Adelaide
Adelaide, Australia
Frank Neumann
Optimisation and Logistics
School of Computer and Mathematical Sciences
The University of Adelaide
Adelaide, Australia
ABSTRACT
Evolutionary multi-objective algorithms have been widely shown to be successful when utilized
for a variety of stochastic combinatorial optimization pro blems. Chance constrained optimization
plays an important role in complex real-world scenarios, as it allows decision makers to take into
account the uncertainty of the environment. We consider a ve rsion of the knapsack problem with
stochastic proï¬ts to guarantee a certain level of conï¬dence in the proï¬t of the solutions. We in-
troduce the multi-objective formulations of the proï¬t chan ce constrained knapsack problem and
design three bi-objective ï¬tness evaluation methods that w ork independently of the speciï¬c conï¬-
dence level required. We evaluate our approaches using well -known multi-objective evolutionary
algorithms GSEMO and NSGA-II. In addition, we introduce a ï¬l tering method for GSEMO that
improves the quality of the ï¬nal population by periodically removing certain solutions from the in-
terim populations based on their conï¬dence level. We show th e effectiveness of our approaches on
several benchmarks for both settings where the knapsack ite ms have ï¬xed uniform uncertainties and
uncertainties that are positively correlated with the expe cted proï¬t of an item.
Keywords Multi-objective optimization, stochastic knapsack probl em, chance constrained problems
1 Introduction
Real world optimization problems involve often uncertain p roperties imposed by some stochastic components in the
problem or noise in its environment Peng (2019); He and Shao ( 2009). Such uncertainties must be considered in the
optimization to ï¬nd reliable and useful solutions to proble ms. Chance constraints are a natural way to model uncer-
tainties in problems. They can capture the effects of uncert ain variables on the inequality constraints and formulate
the optimization problems under uncertainties Peng (2019) ; Neumann et al. (2020); Doerr et al. (2020). A chance
constraint is usually an inequality constraint on some stoc hastic variable of the problem, which can be violated by a
slight chance (a small probability) when optimizing the problem Neumann a nd Sutton (2019); Neumann and Neumann
(2020). Chance constraints enable one to set the desired con ï¬dence level of getting the maximal proï¬t when implement-
ing a solution, unlike using a solution from a deterministic approach. The study of problems with chance constraints
leads to developing efï¬cient applications to solve complex optimization problems and is crucial in developing real
world solutions for complex problems, such as in the mining i ndustry Xie et al. (2021a); Mohtasham et al. (2021),
power systems Geng and Xie (2019), communication systems Ab e et al. (2020) and transportation Kepaptsoglou et al.
(2015). Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
This work considers a variation of the classical knapsack pr oblem (KP), where the items have stochastic proï¬ts and
deterministic weights. As the weights of items are determin istic, the constraint on the weights remains the same
as in the classical KP. An additional constraint is introduc ed to this problem to capture the uncertainty of the proï¬t
variable, which is a chance constraint on the proï¬t Neumann e t al. (2022). This constraint guarantees that the solution
has maximal proï¬t P and only drops below P for a small probabil ity (Î±). In summary, the optimization process for
this problem is to ï¬nd the solution(s) that maximize the proï¬ t P, subjected to the weight constraint and proï¬t chance
constraint, which guarantees that the proï¬t P is obtained wi th probability at least Î±.
In the literature, the KP with a chance constraint on the weig ht (as elements have deterministic proï¬ts and stochastic
weights) is more prevalent Xie et al. (2019, 2020). On the con trary, the proï¬t chance constrained KP is explored
only in one study, which appears in recent literature Neuman n et al. (2022). This work considers single-objective
evolutionary approaches to address this problem Neumann et al. (2022). This scenario makes it possible to identify
the risk of not achieving the expected proï¬t by implementing a particular solution for the problem and making better
decisions in planning. This problem reï¬‚ects a beneï¬cial and valid real-world problem scenario like mine planning as
mentioned in Neumann et al. (2022).
Evolutionary algorithms (EAs) perform well in addressing s tochastic optimization problems Doerr and Neumann
(2021); Singh and Branke (2022). Also, they can produce opti mal or feasible solutions in a reasonable amount of
time for complex combinatorial optimization problems like chance constrained knapsack and job shop scheduling
problems. EAs may consider a different number of objectives depending on how the deï¬nition of the underlying
problem. Usually, when an EA considers a single objective, i t generates a single solution that optimizes the objective
value. In contrast, a multi-objective EA generates a set of s olutions that gives a trade-off between given objectives.
Such a solution set makes it possible to have more insights in to improving the algorithms and search space than having
a single solution as the outcome Coello et al. (2013); Deb (20 01). Therefore, multi-objective algorithms help one to
make informed decisions on selecting a solution to implemen t.
In this work, we explore the use of the multi-objective evolu tionary approaches for the chance constrained KP with
stochastic proï¬ts introduced in Neumann et al. (2022). Here we introduce multi-objective ï¬tness evaluation for EAs
to address this problem and methods to enhance their perform ance.
1.1 Related Work
The use of evolutionary computation for chance constrained problems appears in the early literature He and Shao
(2009); Loughlin and Ranjithan (1999); Liu et al. (2013); Ma sutomi et al. (2013). Those works consider computation-
ally expensive methods like simulations and sampling to cat er for chance constraints. More recent studies have looked
into tail-bound inequalities, which more efï¬ciently deal w ith chance constraints Neumann et al. (2022); Xie et al.
(2019); Assimi et al. (2020).
The chance constrained KP where the proï¬ts are deterministi c and weights are stochastic is considered in several
papers Xie et al. (2019, 2020). Xie et al. (2019) presents how to use well-known deviation inequalities: Chebyshevâ€™s
inequality and Hoeffding bound to estimate the probability of constraint violation. In Xie et al. (2020), where the same
KP variation is considered, they introduce problem-speciï¬ c operators for EAs with both single- and multi-objective
formulations. In the study Assimi et al. (2020), dynamic cha nce constrained KP with stochastic proï¬ts is studied. formulations. In the study Assimi et al. (2020), dynamic cha nce constrained KP with stochastic proï¬ts is studied.
In addition to the objective function on the proï¬t of a given s tochastic solution, a second objective is introduced to
address the dynamic capacity constraint. It captures the mi nimal capacity bound for the solution that meets the chance
constraints.
Run-time analysis is an essential topic in studying problem s with chance constraints. The ï¬rst paper on run time
analysis for chance constraint problems considers the KP wi th stochastic weights Neumann and Sutton (2019). This
work considers different cases of that problem and studies t he run time of (1+1) EA for them. In Xie et al. (2021b),
they perform the run time analysis of simple EAs for chance co nstrained KPs with uniform weights. The papers
Neumann and Witt (2022) and Shi et al. (2022) study the run tim e of simple EAs for different chance constrained
problems. InNeumann and Witt (2022), the authors consider s ingle- and multi-objective EAs for chance constrained
problems with normally distributed random problem variabl es. They also show how to use the proposed evolutionary
approaches for chance constrained minimum spanning tree pr oblems Neumann and Witt (2022). In Shi et al. (2022),
they analyze the run time of random local search and (1+1) EA f or the chance constrained makespan problem.
In the study Neumann et al. (2022), the authors simple EAs for the proï¬t chance constrained KP. Those algorithms
include (1+1) EA with standard bit-ï¬‚ip mutation and heavy-t ail mutation operators and population based ( Âµ+1) EA,
which uses a speciï¬c crossover operator for the KP. This stud y evaluates the performance of all these algorithms
using the single objective ï¬tness evaluation. The overall r esults show that (1+1) EA with heavy tail mutation operator
signiï¬cantly improved over other algorithms.
2 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
This work is motivated by the recent study on evolutionary mu lti-objective algorithms that compute trade-offs with
respect to the expected value and the variance of solutions p resented in Neumann and Witt (2022). Here we explore the
multi-objective formulations for the proï¬t chance constra ined KP based on that work. In addition to the variance of the
solutions, we consider the standard deviation and also the c ount of elements in the solutions (under certain conditions )
to introduce ï¬tness evaluations for the problem. The signiï¬ cance of these ï¬tness functions is that they can evaluate the
ï¬tness of a solution independent of any speciï¬c conï¬dence le vel of its proï¬t (i.e. independent of speciï¬c value for Î±).
Since this generates a set of solutions that gives a trade-of f of speciï¬c objectives for each ï¬tness formulation with eac h
algorithm, it allows one to make more informed decisions whe n selecting a solution to implement. For example, to
identify the solution that gives the best proï¬t with a partic ularÎ±value, we can calculate the proï¬t of all the solutions
for that value and select the solution that gives the best pro ï¬t among the ï¬nal population.
This study considers two well-known multi-objective EAs: G SEMO Giel (2003) and NSGA-II Deb et al. (2002).
Furthermore, we introduce a ï¬ltering method for GSEMO which aims to improve the quality of the ï¬nal population
resulting from the algorithm. This ï¬ltering method is appli ed regularly after a ï¬xed number of evaluations in the
evolutionary process. It considers whether a solution can b e the best solution for any Î±âˆˆ[0.0,1/2]considering the
interim population at the time and, otherwise, removes it fr om the population. For all experimental settings, in additi on
to the two algorithms, GSEMO and NSGA-II, we consider this ï¬l tering method combined with GSEMO as a separate
algorithm.
The structure of this paper is as follows. Section 2 introduc es the problem formulation, and Section 2 discusses the
algorithms we consider in this study. Section 3 discusses th e multi-objective formulation, including the objective
function on proï¬t, ï¬tness functions and how to use the probab ility bounds to estimate the conï¬dence level of the
solutions. Section 4 and 5 discuss the EAs considered in this paper and the new Filtering method introduced in this
work. Section 6 presents the details of the experimental set tings and the results. Finally, Section 7 gives the conclusi ons
of this study.
2 Problem Deï¬nition
In the classical KP, the proï¬t and weight values of the items a re deterministic. Let the KP has n items
{x1,...,x i,...,x n}with proï¬t piand weight wiand weight bound B. A solution to the problem can be represent ed as
{0,1}nsuch that xi= 1only when xiis selected in the solution. Given the proï¬t of solution xasp(x) =/summationtextn
i=1pi.xi
and weight w(x) =/summationtextn
i=1wi.xi, the classical KP is to ï¬nd the solution xâˆ—that maximize p(xâˆ—)subjected to the
weight constraint w(xâˆ—)â‰¤B.
In this work, we consider a stochastic version of the classic al KP where the proï¬ts of the knapsack items are stochastic
while weights remain deterministic. Therefore the proï¬t of a solution will be uncertain and may vary from the expected
maximal proï¬t value. A chance constraint on the proï¬t is used to capture the stochastic behaviour of the problem. This
constraint ensures that for each feasible solution x, the maximum probability that the proï¬t will drop below proï¬ t value
P is only a small probability 0< Î± <1/2.
We can formally present this problem as follows:
maxP (1)
s. t.Pr(p(x)< P)â‰¤Î± (2)
and w (x)â‰¤B (3)
whereÎ±is a parameter determining the allowed failure probability which is a small value <= 1/2. Equation 2
speciï¬es the chance constraint on the proï¬t.
2.1 Estimating Proï¬t of a Solution whereÎ±is a parameter determining the allowed failure probability which is a small value <= 1/2. Equation 2
speciï¬es the chance constraint on the proï¬t.
2.1 Estimating Proï¬t of a Solution
Computing the probability of violating a given chance const raint is intractable in general Doerr and Neumann (2021).
Therefore, it is not straightforward to estimate the proï¬t o f a solution under uncertainties. However, tail bounds can
be used to upper bound the probability of chance constraint v iolationDoerr and Neumann (2021). In Neumann et al.
(2022), the authors present proï¬t estimates for the problem based on the tail bounds: Chebyshevâ€™s inequality and
Hoeffding bound. Each of these applies to the problem under c ertain conditions.
If the expectation and variance of the solutionsâ€™ proï¬ts are known for a given problem instance, we can use Cheby-
shevâ€™s inequality to calculate the proï¬t of a solution for it Doerr (2020). Neumann et al. (2022) present a proï¬t estimate
in Equation 4, that ensure the proï¬t chance constraint Pr(p(x)< P)â‰¤Î±is held. We can guarantee that the solution
3 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
xwill give the proï¬t Ë†pCheb(x,Î±)except for a small probability Î±as follows:
Ë†pCheb(x,Î±) =Âµ(x)âˆ’/radicalbig
(1âˆ’Î±)/Î±Â·/radicalbig
v(x). (4)
The above equation gives a very general setting for the proï¬t of a solution that can be used in any scenario where the
expected value and the variance are known. For example, we ca n consider that the proï¬ts pitake a uniform distribution
such that piâˆˆ{Âµiâˆ’Î´,Âµi+Î´}which gives the expected value Âµiand varianceÎ´2
3.|x|1.
The Hoeffding bound can be used to formulate a proï¬t estimate if the proï¬ts are taken randomly from a uniform
random distribution independent of each other Doerr (2020) . From Neumann et al. (2022), we get the formulation for
the proï¬t of solution xusing the Hoeffding bound ( Ë†pHoef(x,Î±)) as follows:
Ë†pHoef(x,Î±) =Âµ(x)âˆ’Î´Â·/radicalbig
ln(1/Î±)Â·2Â·|x|1. (5)
3 Multi-Objective Formulation
In this section, we introduce the multi-objective formulat ions of the proï¬t chance constrained KP. As presented in
Section 2, the optimal solution for the KP maximizes the proï¬ t subjected to the weight bound constraint. For the proï¬t
chance constrained KP with deterministic weights, the mult i-objective formulation needs to consider the uncertainty
of the proï¬ts of knapsack items. In the following subsection s, we present the multi-objective formulations and the
functions to estimate proï¬ts.
3.1 Fitness Functions
In general, we need to ensure that the expectation of proï¬t is maximized while the variance is minimized to maximize
the proï¬t of the solution. Considering this, we introduce th e ï¬tness function g(x) = (Âµ(x),v(x))that will produce
a set of solutions that gives a trade-off between the two obje ctives, irrespective of Î±the guarantee of the proï¬t of the
individual solutionâ€™s proï¬t value. The formula for the two o bjectives is given in Equation 6 and 7 where vmax=/summationtextn
i=1vi.
Âµ(x) =/braceleftbigg/summationtextn
i=1Âµixiw(x)â‰¤B
Bâˆ’w(x)w(x)> B(6)
v(x) =/braceleftbigg/summationtextn
i=1Ïƒ2
ixi w(x)â‰¤B
vmax+(w(x)âˆ’B)w(x)> B(7)
When evaluating the ï¬tness of solutions, we need to determin e their dominance concerning the different objectives.
For two solutions A and B, we say that Adominates B(denoted as A/{ollowsequalB)iffÂµ(A)â‰¥Âµ(B)âˆ§v(A)â‰¤v(B), andA
strongly dominates B(denoted as Aâ‰»B)iffA/{ollowsequalBandÂµ(A)> Âµ(B)âˆ¨v(A)< v(B). For an infeasible solution
that violates the weight capacity constraint ( w(A)> B ), the above formula penalises the two objective values (see
Equation 6 and 7). This formulation ensures that any feasibl e solution dominates the infeasible solution instances.
Next, we consider the ï¬tness function gâ€²(x) = (Âµ(x),s(x)). Only the second objective of this ï¬tness function differs
fromgâ€²(x)while the ï¬rst objective Âµremains the same and can be deï¬ned as given in Equation 6. We de note the
maximal standard deviation as smax=/summationtextn
i=1Ïƒiin Equation 8 which deï¬nes the second objective of this ï¬tnes s
functiongâ€²(x).
s(x) =/braceleftbigg/radicalbig/summationtextn
i=1Ïƒ2
ixi w(x)â‰¤B
smax+(w(x)âˆ’B)w(x)> B.(8)
For simple EAs like GSEMO, the ï¬nal population when optimizi ngg(x)is equivalent to when optimizing gâ€²(x)as
the difference between the two is that the second objective o f the latter is the square root of the second objective of the
former. Therefore it does not change the order of search poin ts of such algorithms. However, it should be noted that
some popular EMO algorithms like NSGA-II would encounter a d ifference in the diversity mechanism when working
withv(x)instead of s(x). Therefore, we investigate both g(x)andgâ€²(x)in this work.
4 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
3.2 Fitness Function for Proï¬ts with Same Dispersion
When the value for Î´is the same for all elements, we can consider the number of ite ms selected in the solution ( |x|1)
as the second objective. This objective enables the deï¬niti on of a ï¬tness function that performs independent of both
the conï¬dence level of the solution ( Î±) and the uncertainty level of the individual proï¬t values ( Î´). We denote the
ï¬tness function for this scenario as gâ€²â€²(x) = (Âµ(x),c(x)). The ï¬rst objective of the new ï¬tness function is based on
the expectation of the proï¬t of xÂµ(x), similar to previous functions and calculated as given in Eq uation 6. The second
objective c(x)is calculated as follows,
c(x) =/braceleftbigg/summationtextn
i=1xi w(x)â‰¤B
n+(w(x)âˆ’B)w(x)> B.(9)
3.3 Estimating the Best Proï¬t Value
As the ï¬nal output of the multi-objective evolutionary appr oaches, we get a set of solutions that gives a trade-off of
the objectives independent of the conï¬dence level of the pro ï¬ts. We need to identify the solution with the best proï¬t
for a given conï¬dence level Î±using these ï¬nal solutions. We can use Equations 4 and 5 from N eumann et al. (2022)
and calculate the proï¬t of all the solutions in the ï¬nal popul ation for the required conï¬dence levels ( Î±). The solution
giving the highest proï¬t value for each Î±is the best solution for that particular setting.
3.4 Conï¬dence Level of a Solutionâ€™s Proï¬t
Different solutions in the ï¬nal population produced by mult i-objective approaches become the best solution for differ -
ent conï¬dence levels. We can identify the conï¬dence level of each solution in the ï¬nal population for which it gives
the highest proï¬t value. First, we obtain the Î±threshold for a pair of solutions such that one becomes bette r than the
other by comparing the proï¬t estimates mentioned in Subsect ion 2.1. Based on the threshold Î±value between solution
pairs in the ï¬nal population, we deï¬ne a conï¬dence level inte rval for each solution such that they give the best proï¬t
value for any Î±in that interval.
3.4.1 Conï¬dence Level Threshold using Chebyshevâ€™s Inequal ity
Let the solutions xandysuch that Âµ(x)> Âµ(y)andv(x)> v(y), then we can say that the proï¬t of the solution xis
better than ywhen the minimum required conï¬dence level( Î±x,y) is as follows:
Î±Cheb(x,y)=1
1+(R(x,y))2s.t. R(x,y) =Âµ(x)âˆ’Âµ(y)/radicalbig
v(x)âˆ’/radicalbig
v(y)(10)
For the conï¬dence level Î±â‰¥1/(1+(R(x,y))2), the solution Xwill have a better proï¬t value than the solution Y.
Theorem 3.1. Let0< Î± <1,and x andybe two feasible solutions such that Âµ(x)> Âµ(y)andv(x)> v(y), holds.
IfÎ±â‰¥1
1+(R(x,y))2holds such that R(x,y) =Âµ(x)âˆ’Âµ(y)âˆš
v(x)âˆ’âˆš
v(y)thenË†pCheb(x,Î±)â‰¥Ë†pCheb(y,Î±).
Proof. We have
Î±â‰¥1
1+(R(x,y))2
â‡â‡’ Î±+Î±(R(x,y))2â‰¥1
â‡â‡’ (R(x,y))2â‰¥(1âˆ’Î±)/Î±
5 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
As we assume 0< Î± <1,Âµ(x)> Âµ(y)andv(x)> v(y), we have R(x,y)>0and1âˆ’Î±
Î±>0.
This implies,
R(x,y)â‰¥/radicalbig
(1âˆ’Î±)/Î±
â‡â‡’Âµ(x)âˆ’Âµ(y)/radicalbig
v(x)âˆ’/radicalbig
v(y)â‰¥/radicalbig
(1âˆ’Î±)/Î±
â‡â‡’ Âµ(x)âˆ’Âµ(y)â‰¥/radicalbigg
1âˆ’Î±
Î±Â·/parenleftBig/radicalbig
v(x)âˆ’/radicalbig
v(y)/parenrightBig
â‡â‡’ Âµ(x)âˆ’/radicalbigg
1âˆ’Î±
Î±Â·/radicalbig
v(x)â‰¥Âµ(y)âˆ’/radicalbigg
1âˆ’Î±
Î±Â·/radicalbig
v(y)
â‡â‡’ Ë†pCheb(x,Î±)â‰¥Ë†pCheb(y,Î±)
3.4.2 Conï¬dence Level Threshold using Hoeffding Bound
Consider the solutions xandysuch that Âµ(x)> Âµ(y)andv(x)> v(y). From the Ë†pHoef we can derive the minimum
conï¬dence level Î±x,yfor which solution xgives a better proï¬t than yw.r.t.Ë†pHoef as follows:
Î±Hoef(x,y)=eâˆ’(S(x,y))2s.t. S(x,y) =Âµ(x)âˆ’Âµ(y)
Î´/parenleftBig/radicalbig
2|x|1âˆ’/radicalbig
2|y|1/parenrightBig (11)
Theorem 3.2. Let0< Î± <1,and x andybe two feasible solutions such that Âµ(x)> Âµ(y)andv(x)> v(y), holds.
IfÎ±â‰¥eâˆ’(S(x,y))2holds then Ë†pHoef(x,Î±)â‰¥Ë†pHoef(y,Î±).
Proof. We have,
Î±â‰¥eâˆ’(S(x,y))2
â‡â‡’ e(S(x,y))2â‰¥1/Î±
â‡â‡’ (S(x,y))2â‰¥ln(1/Î±)
As we assume 0< Î± <1,Âµ(x)> Âµ(y)andv(x)> v(y), we have S(x,y)>0andln1
Î±>0.
This implies,
S(x,y)â‰¥/radicalbig
ln(1/Î±)
â‡â‡’Âµ(x)âˆ’Âµ(y)
Î´/parenleftBig/radicalbig
2|x|1âˆ’/radicalbig
2|y|1/parenrightBigâ‰¥/radicalbig
ln(1/Î±)
â‡â‡’ Âµ(x)âˆ’Âµ(y)â‰¥Î´Â·/radicalBigg
2ln/parenleftbigg1
Î±/parenrightbigg/parenleftBig/radicalbig
|x|1âˆ’/radicalbig
|y|1/parenrightBig
â‡â‡’ Âµ(x)âˆ’Î´Â·/radicalBigg
ln/parenleftbigg1
Î±/parenrightbigg
Â·2Â·|x|1â‰¥Âµ(y)âˆ’Î´Â·/radicalBigg
ln/parenleftbigg1
Î±/parenrightbigg
Â·2Â·|y|1
â‡â‡’ Ë†pHoef(x,Î±)â‰¥Ë†pHoef(y,Î±)
3.4.3 Conï¬dence Level Interval for Solutions in the Final Po pulation
We can use the Î±threshold value in the previous subsections, to introduce t he conï¬dence level range for solutions in
a population as follows. As the Î±threshold we can use either Î±Cheb(x,y)orÎ±Hoef(x,y). Despite the speciï¬c equation
to estimate the Î±threshold, we can introduce the Î±interval for a solution.
First, we sort all the solutions in the given population P as {x1,...xn}such that Âµ(x1)â‰¥Âµ(x2)â‰¥...â‰¥Âµ(xn). Then,
we can deï¬ne a (n+1)Ã—(n+1) symmetric matrix of conï¬dence level thresholds as:
6 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
Algorithm 1 GSEMO
1:Choosexâˆˆ{0,1}nuniformly at random ;
2:Sâ†{x};
3:while stopping criterion not met do
4: choosexâˆˆSuniformly at random;
5:yâ†ï¬‚ip each bit of xindependently with probability of1
n;
6: if(/\e}atio\slashâˆƒwâˆˆS:wâ‰»y)then
7:Sâ†(Sâˆª{y})\{zâˆˆS|y/{ollowsequalz};
8: end if
9:end while
Î±(i,j)=/braceleftbigg
1 i= 0orj= 0
Î±Cheb(i,j)orÎ±Hoef(i,j)i= 1,...,n(12)
Finally, using the conï¬dence level threshold values, we can get the conï¬dence level range for solution k as given
in Equation 13. If there exists a valid Î±interval for a particular solution, then for the Î±values in that interval, that
solution will give the best proï¬t value. If the Î±interval is empty for a particular solution, then that solut ion wonâ€™t be
the best solution for any Î±value.
kâˆ’1
min
j=0Î±i,kâ‰¤Î±kâ‰¤nâˆ’1max
j=kÎ±i,j (13)
4 Algorithms
In this study, we consider two widely used multi-objective E As: GSEMO and NSGA-II. GSEMO is the most basic EA
that addresses multi-objective optimization problems. It has been proven to be effective in solving chance constraine d
multi-objective optimization problems in many studies Neu mann et al. (2022). The steps of GSEMO are given in
Algorithm 1.
The population S initially contains a solution that is gener ated randomly. Over the iterations, a parent solution xis
selected uniformly at random from S and an offspring solutio nyis generated by ï¬‚ipping each bit of xwith a probability
of1
n. Ifyis not dominated by any of the existing solutions in S, it is ad ded to S replacing all the existing solutions in S
that are dominated by y. This guarantees at the end of any iter ation, population S will contain a set of non-dominating
solutions that are equally efï¬cient with respect to the give n objective functions.
NSGA-II is the most prominent multi-objective EA that focus es on diversity by ï¬nding near optimal solutions
Deb et al. (2002). If we consider one iteration of the evoluti onary process of NSGA-II, it creates an offspring pop-
ulation from the parent population. First, we use the binary tournament for the selection of two parent solutions and
apply single point crossover to generate two offspring solu tions which are mutated by ï¬‚ipping each bit with a proba-
bility of1
n. When the offspring population is full, all the solutions fr om parent and offspring solutions are considered
together and divided into non-dominating solution fronts ( i.e., the solutions in a front do not dominate other solution s
in it). Starting with the front with the lowest rank, these ar e added to the new population until it reaches capacity. If
only a part of a front is to be taken into the new population, cr owding distance-based sorting is used to decide the
selection. This improves the better spread (diversity) amo ng the solutions. In one iteration of this algorithm, a new
ï¬tness evaluation equal to the size of the offspring populat ion is considered. The number of iterations of the algorithm s
depends on the offspring population size and the maximum num ber of evaluations as considered in the experimental
setup.
5 Filtering for Problems with Chance Constraints
Here we propose a ï¬ltering method for GSEMO to improve its out come by removing solutions that do not have a valid
Î±interval from the interim populations. The ï¬nal population of GSEMO contains solutions that do not give the best
proï¬t value for any probability value for Î±. Such solutions do not add value to the optimization goal of ï¬ nding the
best solutions with given conï¬dence levels. For instance, F igure 1 presents a ï¬nal population from GSEMO using 10
million ï¬tness evaluation of g(x)on uncorr-100: an instance used in the experiments. The plot showsÂµ(x)versus
v(x)for all solutions in the ï¬nal population. Blue star markers i ndicate that the solution has a valid conï¬dence level
interval. These solutionsâ€™ Î±intervals compose the complete probability range [0.0,1.0 ]. At the end of the optimization interval. These solutionsâ€™ Î±intervals compose the complete probability range [0.0,1.0 ]. At the end of the optimization
7 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
0.0 2.0 4.0 6.0 8.0
Âµ(x)[in 1000â€™s]0.0 1.0 2.0 3.0v(x) [in 1000â€™s]Î±1
Î±2
Î±3
Î±4
Î±8
Î±10
Î±12
Î±18
Î±19
Figure 1: A sample of a ï¬nal population from GSEMO
Algorithm 2 Filtering Method
0:Input: Population P0=x1,...,xnordered by the decreasing order of Âµ(xi);
1:setkâ†1;
2:whilekâ‰¤ndo
3: setupperâ†minkâˆ’1
j=0Î±i,k
4: setlowerâ†maxnâˆ’1
j=kÎ±i,j
5: ifupperâ‰¥lower then
6:P1âˆª{xk}
7: end if
8: setkâ†k+1
9:end while
10:returnP1
process, interest is in solutions with these blue markers. I t is one of these solutions that become the best solution for
a givenÎ±value. On the contrary, other solutions marked in black do no t become the best solution for any conï¬dence
level.
The ï¬ltering method removes these solutions that do not beco me the best solution for any conï¬dence level. It is
applied to the interim populations of GSEMO regularly after a certain amount of ï¬tness evaluations. This process
removes the solutions from interim populations, consideri ng theÎ±intervals they represent according to Equation 13.
As the ï¬ltering method keeps only the solutions with valid Î±interval, it increases the change of the evolutionary
optimization to improve on these solutions. Therefore, thi s method helps to improve the quality of the solutions in the
ï¬nal population.
The steps of the ï¬ltering method are given in Algorithm 2. It t akes the population P0as the input, which can be either
the ï¬nal population or an interim population created during the execution of GSEMO. Population P0needs solutions
in the decreasing order of the Âµ(x). For each solution xk, we consider Î±i,kand select the interval for conï¬dence level,
using the inequality given in Equation 13. The solution xkis added to the resulting population P1iff the interval for
Î±kis non-empty.
6 Experiments
In this work, we evaluate the ï¬tness functions introduced pr eviously in different chance constraint settings using mul ti-
objective EAs on different benchmarks; and we use multiple e xperiments for that. Here we present the experimental
settings and the results of these experiments.
8 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINTTable 1: Results for same dispersion using Chebyshevâ€™s ineq uality
BÎ±Î´GSEMO with g(x) (1) GSEMO+Filtering with g(x) (2) NSGA-II with g(x) (3) NSGA-II with gâ€²(x) (4) NSGA-II with gâ€²â€²(x) (5)
mean std stat mean std stat mean std stat mean std stat mean std statuncorr-100
24070.12511029.6826 76.3191 2âˆ’5+11085.6072 0.00001+3+4+5+11007.6251 88.8419 2âˆ’10998.7574 50.6310 2âˆ’11007.7624 52.5740 1âˆ’2âˆ’
5010862.4750 61.4080 2âˆ’5+10907.0000 0.00001+3+4+5+10837.2841 53.1386 2âˆ’10811.4832 80.3604 2âˆ’10832.9581 50.1309 1âˆ’2âˆ’
0.012510620.5264 71.0446 2âˆ’5+10672.3379 0.00001+3+4+5+10602.1969 81.4896 2âˆ’10594.9482 45.5447 2âˆ’10602.8065 46.9209 1âˆ’2âˆ’
5010044.4941 49.7668 2âˆ’5+10079.9649 0.00001+3+4+5+10025.8881 41.6418 2âˆ’10004.2550 67.4364 2âˆ’10023.0463 38.8802 1âˆ’2âˆ’
0.00125 9345.9245 55.2560 2âˆ’5+9384.5150 0.00001+3+4+5+9338.8078 59.0630 2âˆ’5+9336.6045 30.1889 2âˆ’9340.8894 29.5604 1âˆ’2âˆ’3âˆ’
50 7495.5153 17.9630 2âˆ’5+7502.7716 0.00001+3+4+5+7498.7722 13.1282 2âˆ’5+7488.8368 31.6085 2âˆ’7499.2121 9.5267 1âˆ’2âˆ’3âˆ’strong-100
41870.125 8507.0584 130.1420 2âˆ’8606.3413 87.2952 1+3+4+5+8525.5561 125.6131 2âˆ’8500.0805 149.4958 2âˆ’8499.3632 124.5506 2âˆ’
50 8368.0306 94.0118 2âˆ’8422.6322 67.2273 1+3+5+8326.9385 114.3897 2âˆ’8364.0549 124.7364 8319.3263 115.3753 2âˆ’
0.0125 8083.9678 106.1983 2âˆ’8170.3360 69.5792 1+4+5+8102.4388 104.2026 8082.3479 124.2002 2âˆ’8082.2853 103.3765 2âˆ’
50 7502.9361 59.8544 2âˆ’7549.4937 41.2749 1+3+5+7489.7223 73.5765 2âˆ’7513.5174 78.6964 7485.1707 73.8490 2âˆ’
0.00125 6770.3193 41.1347 2âˆ’6814.1197 20.7669 1+4+5+6787.5739 42.8885 6782.2797 48.8989 2âˆ’6784.1694 42.0052 2âˆ’
50 4957.5449 36.7770 2+3âˆ’4âˆ’4894.0039 60.2107 1âˆ’3âˆ’4âˆ’5âˆ’4990.7637 17.9608 1+2+5+4989.4145 13.2248 1+2+5+4991.4701 11.0454 2+3âˆ’4âˆ’uncorr-300
68530.12533935.4067 205.6247 2âˆ’34286.1802 147.5309 1+3+4+5+33681.6883 534.3217 2âˆ’33671.7620 555.4450 2âˆ’33615.8492 489.0223 2âˆ’
5033571.9980 260.8593 2âˆ’33967.3813 159.2433 1+3+4+5+33418.4882 512.5693 2âˆ’33284.5989 450.6255 2âˆ’33319.4651 483.5459 2âˆ’
0.012533237.8865 200.4641 2âˆ’33577.9421 141.7536 1+3+4+5+32992.6756 521.4969 2âˆ’32984.2543 541.8390 2âˆ’32929.2384 476.3437 2âˆ’
5032180.0106 245.8773 2âˆ’32551.5342 144.8963 1+3+4+5+32039.6829 487.7705 2âˆ’31913.5405 429.4896 2âˆ’31946.2435 458.2449 2âˆ’
0.0012531066.6084 186.3571 2âˆ’31372.5619 122.8614 1+3+4+5+30846.1243 482.1829 2âˆ’30841.9917 499.6822 2âˆ’30789.6329 437.0386 2âˆ’
5027843.2948 203.7335 2âˆ’28141.7188 105.9385 1+3+4+5+27745.1612 411.5637 2âˆ’27641.0702 364.7302 2âˆ’27668.0494 380.2576 2âˆ’strong-300
138210.12523809.6581 433.2506 2âˆ’3âˆ’5âˆ’24369.6211 216.9574 1+3+4+24099.5570 327.0870 1+2âˆ’23986.4018 344.2409 2âˆ’24176.0891 232.7994 1+
5023594.2993 335.6481 2âˆ’3âˆ’5âˆ’24135.2769 220.4491 1+3+4+5+23867.9086 293.6342 1+2âˆ’23695.2127 304.2994 2âˆ’23899.3116 223.8869 1+2âˆ’
0.012523176.9548 406.2664 2âˆ’3âˆ’5âˆ’23703.0401 197.3436 1+3+4+23464.5667 299.1984 1+2âˆ’23360.1013 318.6357 2âˆ’23534.8995 212.1891 1+
5022322.7651 282.0126 2âˆ’3âˆ’5âˆ’22797.4912 177.4246 1+3+4+5+22588.5433 240.6771 1+2âˆ’22446.1950 255.5942 2âˆ’22616.9323 182.9564 1+2âˆ’
0.0012521208.9163 322.7908 2âˆ’3âˆ’5âˆ’21626.7053 138.6421 1+4+21486.9475 214.2326 1+21411.6675 240.6127 2âˆ’21536.8345 149.2069 1+
5018388.5805 159.4458 2âˆ’3âˆ’4âˆ’5âˆ’18647.0894 70.1852 1+4+18623.6627 98.1567 1+18569.9473 110.1685 1+2âˆ’18638.7270 63.3870 1+uncorr-500
112430.12557076.8361 748.9305 2âˆ’3+4+58431.4168 311.5788 1+3+4+5+55850.4588 1249.6235 1âˆ’2âˆ’55869.0104 1408.3737 1âˆ’2âˆ’56037.4884 1287.2936 2âˆ’
5056690.8982 859.2445 2âˆ’3+4+5+58120.8249 314.3063 1+3+4+5+55563.0878 1044.9051 1âˆ’2âˆ’54981.1206 1223.7431 1âˆ’2âˆ’55667.0434 1278.2837 1âˆ’2âˆ’
0.012556197.0249 738.3354 2âˆ’3+4+57528.4355 304.4306 1+3+4+5+54995.4516 1230.9769 1âˆ’2âˆ’55013.2733 1387.3025 1âˆ’2âˆ’55179.3063 1266.4267 2âˆ’
5054931.1821 829.5866 2âˆ’3+4+5+56312.8274 298.8610 1+3+4+5+53851.9927 1009.2563 1âˆ’2âˆ’53287.7928 1187.2402 1âˆ’2âˆ’53950.6793 1236.5882 1âˆ’2âˆ’
0.0012553456.0312 705.5039 2âˆ’3+4+54715.2628 282.5314 1+3+4+5+52331.0919 1172.9610 1âˆ’2âˆ’52346.6392 1321.7096 1âˆ’2âˆ’52505.0533 1201.5375 2âˆ’ 0.0012553456.0312 705.5039 2âˆ’3+4+54715.2628 282.5314 1+3+4+5+52331.0919 1172.9610 1âˆ’2âˆ’52346.6392 1321.7096 1âˆ’2âˆ’52505.0533 1201.5375 2âˆ’
5049451.2762 737.5644 2âˆ’3+4+50683.8705 252.3483 1+3+4+5+48521.4630 900.6466 1âˆ’2âˆ’48012.1505 1072.2455 1âˆ’2âˆ’48602.1733 1107.2660 2âˆ’strong-500
222230.12538822.1695 692.1198 2âˆ’3âˆ’4âˆ’5âˆ’40391.0362 449.8195 1+3+4+5+39792.1607 415.5621 1+2âˆ’39754.0904 424.9780 1+2âˆ’39769.7011 392.0549 1+2âˆ’
5038444.0651 620.4975 2âˆ’3âˆ’4âˆ’5âˆ’40078.0983 348.7030 1+3+4+5+39442.9758 605.5909 1+2âˆ’39485.7055 483.2892 1+2âˆ’39416.6356 382.3801 1+2âˆ’
0.012538026.4154 657.3621 2âˆ’3âˆ’4âˆ’5âˆ’39525.2027 425.9579 1+3+4+5+38973.8435 390.8087 1+2âˆ’38936.9771 399.8035 1+2âˆ’38951.8432 369.6260 1+2âˆ’
5036864.1232 555.3952 2âˆ’3âˆ’4âˆ’5âˆ’38332.2087 312.3534 1+3+4+5+37800.5870 535.4997 1+2âˆ’37839.6026 424.3667 1+2âˆ’37781.3920 337.2743 1+2âˆ’
0.0012535546.6995 551.6446 2âˆ’3âˆ’4âˆ’5âˆ’36827.5418 352.7810 1+3+4+5+36424.1740 315.3111 1+2âˆ’36391.1536 322.1788 1+2âˆ’36404.2919 299.3640 1+2âˆ’
5031947.2385 360.7027 2âˆ’3âˆ’4âˆ’5âˆ’32899.2694 206.7434 1+32685.3625 321.9032 1+32727.4059 242.3192 1+32688.8779 201.6241 1+
9 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
6.1 Experimental Setup
For experimental investigations, we use the same benchmark s as the ones that are used in Neumann et al. (2022).
The set of benchmarks includes three correlated instances a nd three bounded strongly correlated instances with the
numbers of knapsack items nâˆˆ{100,300,500}. We consider that the proï¬ts of the knapsack items have a unif orm
distribution, such that the proï¬t of element iis chosen uniformly at random as piâˆˆ{Âµiâˆ’Î´,Âµi+Î´}. This allows to
use bothË†pCheb andË†pHoef when the proï¬ts have the same uncertainty level ( Î´). The experimental investigation covers
two uncertainty levels for each benchmark, Î´âˆˆ{25,50}. Additionally, we consider the scenario where the proï¬ts
have different dispersion such that each item ihas an uncertainty level Î´i, which is chosen uniformly at random as
Î´iâˆˆ[0.0,Âµi]. The benchmarks with different uncertainties are consider ed only with Ë†pCheb sinceË†pHoef requires the
same uncertainty level for all elements.
This study mainly considers three algorithms: two well-kno wn multi-objective evolutionary algorithms GSEMO and
NSGA-II and the third is GSEMO with the ï¬ltering method intro duced in Section 4. The latter is referred to as
GSEMO+Filtering hereafter in this paper. These algorithms are combined with ï¬tness functions as appropriate, to
use in the experiments. For the benchmarks with ï¬xed uncerta inties, using GSEMO or GSEMO+Filtering with any
ï¬tness function ( g(x)orgâ€²(x)orgâ€²â€²(x)) will produce equivalent results as the ï¬nal populations. T herefore, GSEMO
and GSEMO+Filtering are only considered with the ï¬tness eva luationg(x). The ï¬tness function gâ€²â€²(x)considers the
number of items selected in the solution for the scenario whe re proï¬ts have the same dispersion. Therefore, we do
not consider algorithms with that ï¬tness function for the be nchmarks with different uncertainties for proï¬ts. Only
GSEMO and GSEMO+Filtering with g(x), and NSGA-II with g(x)andgâ€²(x)are considered for those benchmarks.
Every algorithm considers the 10 million ï¬tness evaluation and produces a population of solutions that gives a trade-
off concerning the objectives used for ï¬tness evaluation. T he quality of the output of these methods is evaluated
by analyzing the best proï¬t value for different conï¬dence le vels considering Î±âˆˆ{0.1,0.01,0.001}. Each method
generates a ï¬nal population independent of Î±, and we select the best solution from that population for dif ferentÎ±
values using proï¬t estimations Ë†pCheb orË†pHoef as applicable. The results summarise the best proï¬t value gi ven by 30
experimental results for each Î±. This summary requires running the method 30 times for each Î´for benchmarks with
the same proï¬t dispersion and 30 times for benchmarks with di fferent proï¬t dispersion. However, when using gâ€²â€²(x),
as algorithms run independent of Î´value, it is possible to get the best proï¬t values for differe ntÎ´from the same ï¬nal
population.
Finally, we test for the statistical signiï¬cance validity o f the results using the Kruskal-Wallis test with 95% conï¬den ce
with the Bonferroni post-hoc statistical procedure. The st atistical comparison is indicated as X+orXâˆ’to indicate that
the method in the column outperforms Xor vice versa. If there is no signiï¬cant difference between t he two methods,
respective numbers do not appear. For each method, the summa ry of the best proï¬t values is given as mean, std and
stat, which represent the mean and standard deviation of the results and statistical comparison with the corresponding
results from other methods, respectively.
6.2 Results
Table 1 and 2 present the results for the benchmarks with ï¬xed uncertainty levels proï¬ts of elements. According to the
mean values GSEMO with the ï¬ltering method outperforms othe r methods in most of the settings in both tables. The mean values GSEMO with the ï¬ltering method outperforms othe r methods in most of the settings in both tables. The
statistical comparisons give more insights into the perfor mance of the methods when applied to each instance. Results
for uncorr-100 in Table 1 show that GSEMO+Filtering perform s the better than other four methods, and GSEMO
performs better than NSGA-II with gâ€²â€²(x). For smaller conï¬dence levels Î±= 0.001, NSGA-II with g(x)outperforms
that withgâ€²â€²(x). Strong-100 instance gets very different results for Î±= 0.001andÎ´= 50 , than other cases of the same
instance. There, GSEMO with g(x)and NSGA-II with g(x)andgâ€²(x)perform well and GSEMO+Filtering gives the
lowest result. However, the second method performs well in o therÎ±andÎ´settings and NSGA-II with g(x)andgâ€²(x)
also perform similarly in certain settings.
For all settings of uncorr-300, GSEMO+Filtering outperfor ms the other four methods while performing similarly to
each other. For strong-300 instance, GSEMO gives lower resu lts than GSEMO+Filtering and NSGA-II with g(x)
andgâ€²â€²(x). Also, NSGA-II with g(x)produces results as good as GSEMO+Filtering for Î±= 0.001. For uncorr-
500, GSEMO+Filtering gives the best results and GSEMO outpe rforms most of the NSGA-II results. However,
when using gâ€²â€²(x)with NSGA-II on this instance, results show equal performan ce except for Î±={0.1,0.01}con-
ï¬dence levels when considering uncertainty level Î´= 50 . Experiments on strong-500 also get the best results from
GSEMO+Filtering. However, GSEMO is outperformed by other m ethods for all settings considered for this instance.
In comparison, the NSGA-II gives the second best results acr oss settings when Î´= 50 andÎ±= 0.001NSGA-II
methods also perform as well as GSEMO+Filtering.
10 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
Table 2: Results for same dispersion using Hoeffding bound
BÎ±Î´GSEMO with g(x) (1) GSEMO+Filtering with g(x) (2) NSGA-II with g(x) (3) NSGA-II with gâ€²(x) (4) NSGA-II with gâ€²â€²(x) (5)
mean std stat mean std stat mean std stat mean std stat mean std statuncorr-100
24070.12510987.3004 75.7683 2âˆ’11042.7989 0.00001+3+4+5+10965.6291 88.0780 2âˆ’10956.9290 50.1020 2âˆ’10965.9887 51.9898 2âˆ’
5010778.0078 60.1974 2âˆ’10821.5978 0.00001+3+4+5+10753.4968 51.9386 2âˆ’10728.1263 79.0134 2âˆ’10749.4108 48.9647 2âˆ’
0.012510896.5878 74.5928 2âˆ’10951.1744 0.00001+3+4+5+10875.7430 86.4446 2âˆ’10867.4019 48.9713 2âˆ’10876.2792 50.7360 2âˆ’
5010596.7649 57.6057 2âˆ’10638.3488 0.00001+3+4+5+10573.7130 49.3723 2âˆ’10549.2659 76.1316 2âˆ’10569.9917 46.4640 2âˆ’
0.0012510826.9815 73.6938 2âˆ’10880.8684 0.00001+3+4+5+10806.7709 85.1930 2âˆ’10798.7053 48.1051 2âˆ’10807.4426 49.7746 2âˆ’
5010457.6924 55.6226 2âˆ’10497.7369 0.00001+3+4+5+10435.7601 47.4116 2âˆ’10412.0216 73.9290 2âˆ’10432.3187 44.5489 2âˆ’strong-100
41870.125 8463.1467 127.6172 2âˆ’8561.1573 85.4504 1+3+4+5+8481.7278 123.3848 2âˆ’8456.8099 146.8670 2âˆ’8456.3390 122.3538 2âˆ’
50 8278.6327 90.2553 2âˆ’8332.4692 64.4783 1+3+5+8240.4850 110.0787 2âˆ’8276.2257 119.9424 8233.2780 111.0076 2âˆ’
0.0125 8369.3409 122.2698 2âˆ’8464.4621 81.5096 1+3+4+5+8387.9199 118.6225 2âˆ’8364.1958 141.2465 2âˆ’8363.9441 117.6448 2âˆ’
50 8086.8101 82.3211 2âˆ’8139.0049 58.6173 1+3+5+8054.9801 100.8829 2âˆ’8087.7692 109.6779 8048.4883 101.6750 2âˆ’
0.00125 8297.3868 118.1961 2âˆ’8390.2653 78.4972 1+3+4+5+8315.9386 114.9756 2âˆ’8293.1306 136.9396 2âˆ’8293.0470 114.0400 2âˆ’
50 7939.6195 76.3766 2âˆ’7990.5545 54.1630 1+3+5+7912.6372 93.8879 2âˆ’7943.1615 101.8268 7906.6941 94.5672 2âˆ’uncorr-300
68530.12533863.1544 205.0835 2âˆ’34212.8177 146.9244 1+3+4+5+33610.2955 532.9802 2âˆ’33600.5469 554.0346 2âˆ’33545.0211 487.7131 2âˆ’
5033428.2570 259.2905 2âˆ’33821.1723 157.7349 1+3+4+5+33276.1084 510.0035 2âˆ’33143.0191 448.4365 2âˆ’33177.8089 480.9303 2âˆ’
0.012533708.5096 203.9304 2âˆ’34055.7967 145.6324 1+3+4+5+33457.5385 530.1364 2âˆ’33448.1219 551.0166 2âˆ’33392.9168 484.9026 2âˆ’
5033119.8295 255.9406 2âˆ’33507.4493 154.5170 1+3+4+5+32970.6017 504.5017 2âˆ’32839.2289 443.7443 2âˆ’32873.6003 475.3176 2âˆ’
0.0012533589.8465 203.0502 2âˆ’33935.3102 144.6467 1+3+4+5+33340.3278 527.9571 2âˆ’33331.1621 548.7016 2âˆ’33276.2031 482.7469 2âˆ’
5032883.1649 253.3855 2âˆ’33266.7212 152.0660 1+3+4+5+32736.1783 500.2836 2âˆ’32606.1226 440.1485 2âˆ’32640.1729 471.0147 2âˆ’strong-300
138210.12523744.0892 430.4747 2âˆ’3âˆ’5âˆ’24300.5479 214.9589 1+3+4+24033.7421 324.1660 1+2âˆ’23921.4833 341.5510 2âˆ’24109.9465 230.6676 1+
5023462.9510 329.9513 2âˆ’3âˆ’5âˆ’23997.1125 215.9394 1+3+4+5+23735.7246 288.1238 1+2âˆ’23566.2352 299.2535 2âˆ’23767.0263 219.6354 1+2âˆ’
0.012523603.7492 424.5461 2âˆ’3âˆ’5âˆ’24152.7138 210.6726 1+3+4+23892.9269 317.9729 1+2âˆ’23782.5354 335.8005 2âˆ’23967.9043 226.0936 1+
5023181.2241 317.9412 2âˆ’3âˆ’5âˆ’23700.6927 206.3054 1+3+4+5+23452.1877 276.3622 1+2âˆ’23289.4860 288.4378 2âˆ’23482.9419 210.5250 1+2âˆ’
0.0012523496.0973 420.0184 2âˆ’3âˆ’5âˆ’24039.3181 207.2892 1+3+4+23784.9190 313.2317 1+2âˆ’23675.9269 331.3992 2âˆ’23858.9115 222.5879 1+
5022965.0474 308.7926 2âˆ’3âˆ’5âˆ’23473.2418 198.9571 1+3+4+5+23234.6394 267.3758 1+2âˆ’23077.1290 280.1499 2âˆ’23264.9563 203.5545 1+2âˆ’uncorr-500
112430.12556985.6975 747.8288 2âˆ’3+4+58337.8820 310.8352 1+3+4+5+55761.8933 1247.6913 1âˆ’2âˆ’55780.3693 1406.1906 1âˆ’2âˆ’55948.9616 1285.1401 2âˆ’
5056509.1689 856.1817 2âˆ’3+4+5+57934.0703 312.7435 1+3+4+5+55386.3718 1041.2515 1âˆ’2âˆ’54806.2623 1219.9708 1âˆ’2âˆ’55489.9899 1273.9787 1âˆ’2âˆ’
0.012556790.6294 745.4714 2âˆ’3+4+58137.6851 309.2459 1+3+4+5+55572.3326 1243.5564 1âˆ’2âˆ’55590.6468 1401.5183 1âˆ’2âˆ’55758.8493 1280.5162 2âˆ’
5056119.2292 849.6132 2âˆ’3+4+5+57533.3999 309.3150 1+3+4+5+55007.2442 1033.3396 1âˆ’2âˆ’54431.0658 1211.8786 1âˆ’2âˆ’55109.7653 1264.7366 1âˆ’2âˆ’
0.0012556640.9485 743.6632 2âˆ’3+4+57984.0686 308.0287 1+3+4+5+55426.8776 1240.3841 1âˆ’2âˆ’55445.0676 1397.9335 1âˆ’2âˆ’55612.9710 1276.9688 2âˆ’ 0.0012556640.9485 743.6632 2âˆ’3+4+57984.0686 308.0287 1+3+4+5+55426.8776 1240.3841 1âˆ’2âˆ’55445.0676 1397.9335 1âˆ’2âˆ’55612.9710 1276.9688 2âˆ’
5055820.0179 844.5763 2âˆ’3+4+5+57226.0199 306.6676 1+3+4+5+54716.3294 1027.2713 1âˆ’2âˆ’54143.1674 1205.6714 1âˆ’2âˆ’54818.0086 1257.6477 1âˆ’2âˆ’strong-500
222230.12538739.7417 688.5044 2âˆ’3âˆ’4âˆ’5âˆ’40301.3374 447.3446 1+3+4+5+39707.3872 412.9829 1+2âˆ’39669.4439 422.3664 1+2âˆ’39685.3277 389.7418 1+2âˆ’
5038280.9153 613.7020 2âˆ’3âˆ’4âˆ’5âˆ’39897.8123 344.8981 1+3+4+5+39273.3775 598.3347 1+2âˆ’39315.7031 477.1865 1+2âˆ’39247.8886 377.7601 1+2âˆ’
0.012538563.3178 680.7776 2âˆ’3âˆ’4âˆ’5âˆ’40109.3511 442.0526 1+3+4+5+39525.9425 407.4683 1+2âˆ’39488.2712 416.7806 1+2âˆ’39504.1345 384.7767 1+2âˆ’
5037930.8422 599.1733 2âˆ’3âˆ’4âˆ’5âˆ’39510.9695 336.7709 1+3+4+5+38909.4678 582.7780 1+2âˆ’38950.9755 464.0994 1+2âˆ’38885.5815 367.8049 1+2âˆ’
0.0012538427.9430 674.8592 2âˆ’3âˆ’4âˆ’5âˆ’39962.0501 437.9920 1+3+4+5+39386.7151 403.2421 1+2âˆ’39349.2525 412.4983 1+2âˆ’39365.1001 380.9688 1+2âˆ’
5037662.2216 588.0761 2âˆ’3âˆ’4âˆ’5âˆ’39214.1346 330.5707 1+3+4+5+38630.2301 570.8539 1+2âˆ’38671.1102 454.0722 1+2âˆ’38607.6080 360.1434 1+2âˆ’
Table 3: Results for different dispersion using Chebyshevâ€™ s inequality
Instance BÎ±GSEMO with g(x) (1) GSEMO+Filtering with g(x) (2) NSGA-II with g(x) (3) NSGA-II with gâ€²(x) (4)
mean std stat mean std stat mean std stat mean std stat
uncorr-100 24070.1 8546.7015 322.7956 8562.9620 323.1475 8565.8942 324.9223 8564.2549 323.8494
0.01 4682.2710 799.1875 4675.9295 795.5029 4674.8735 797.5334 4677.1350 799.3174
0.001 1967.4965 880.0104 1962.3962 886.0726 1919.2445 917.6798 1953.6975 894.4411
strong-100 41870.1 7100.1631 245.6990 7099.8604 250.2445 7122.7698 249.2182 7123.3386 250.5080
0.01 5315.4258 326.6578 5308.5248 343.0757 5329.4856 326.9290 5333.3263 325.5847
0.001 3746.9429 732.1072 3746.1213 731.9397 3734.2093 731.9080 3743.5859 731.6689
uncorr-300 68530.1 29089.9230 479.0749 2âˆ’3âˆ’4âˆ’29580.8035 355.6388 1+29735.0392 358.7213 1+29676.9763 388.6763 1+
0.01 19396.8836 1128.3967 19431.8036 1126.0478 19589.0418 1131.0819 19580.3092 1131.0342
0.001 8910.0087 1370.4531 8850.8254 1381.8863 8899.5025 1378.4832 8971.3050 1383.6696
strong-300 138210.1 21789.9295 335.7672 2âˆ’3âˆ’4âˆ’22171.9138 358.9991 1+22345.3397 309.3574 1+22297.4300 307.0689 1+
0.01 18172.8378 560.3248 18195.2974 615.1645 18338.0359 588.6787 18342.4421 576.7652
0.001 14629.7944 809.3377 14617.5558 794.6289 14643.0814 808.6424 14667.4349 812.9751
uncorr-500 112430.1 50266.4398 709.0211 2âˆ’3âˆ’4âˆ’52494.0984 556.8082 1+52468.0194 532.9634 1+52149.3408 700.4027 1+
0.01 37753.4240 1566.1944 38510.4882 1564.4777 38746.1887 1539.8167 38686.7230 1555.8618
0.001 18969.0800 2144.1783 18880.7433 2144.3506 19153.0886 2137.5579 19190.4696 2134.7447
strong-500 222230.1 35919.5415 631.8822 2âˆ’3âˆ’4âˆ’37833.8138 352.1352 1+37832.1320 332.8651 1+37690.0363 317.8082 1+
0.01 30977.9111 679.1163 2âˆ’3âˆ’4âˆ’31554.3119 682.8664 1+31822.0362 649.7576 1+31805.6899 637.4521 1+
0.001 25041.2112 721.5121 25018.0126 704.1720 25131.2311 723.9024 25193.7178 741.8816
Table 2 gives the results from the experiments that use Ë†pCheb to estimate the proï¬t values of solutions. uncorr-100,
strong-100, and uncorr-300 results are highest when using G SEMO+Filtering. It outperforms all the other methods
except NSGA-II with gâ€²(x)on strong-100 instance for uncertainty level Î´= 50 . Experiments on strong-300 instance
show that NSGA-II with gâ€²â€²(x)performs equally as the GSEMO+Filtering when considering a lower uncertainty level
(25) for the knapsack items. GSEMO and NSGA-II with gâ€²(x)methods give the lowest results for this instance. On the
contrary, GSEMO performs better than most NSGA-II methods f or uncorr-500. When using gâ€²â€²(x), NSGA-II performs
equally as GSEMO for lower uncertainty level value 25. For al lÎ±andÎ´values, NSGA-II methods are outperformed
by GSEMO+Filtering in the experiments on strong-500 in Tabl e 2. However, NSGA-II methods perform better than
GSEMO on that benchmark.
11 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
GSEMO+Filtering performs signiï¬cantly well when applied t o benchmarks with the same dispersion for proï¬ts. The
ï¬ltering method allows the interim populations to contain m ore solutions that yield a valid conï¬dence level interval.
Therefore, improving upon these solutions eventually give s better results in the ï¬nal outcome. Considering NSGA-II
results,g(x)andgâ€²(x)tends to produce better results than gâ€²â€²(x). This can be due to the fact the crowding distance
assignment is better when considering the variance or the st andard deviation of solutionsâ€™ proï¬ts.
We can compare the results for benchmarks with the same dispe rsion for proï¬ts (given in Table 1 and 2) with the
previous work in Neumann et al. (2022) as it also considers th e same benchmarks and similar experimental setup. The
experimental settings are the same in both works except for t he number of ï¬tness evaluations the algorithms consider.
For each Î±andÎ´value, methods in Neumann et al. (2022) run for one million ï¬t ness evaluations. On the contrary,
we run the multi-objective methods on benchmarks for each Î´value for 10 million ï¬tness evaluations which yield
results for all Î±values from the same algorithm output. The results show that for Chebyshev results 14 out of the
36 settings, the highest mean proï¬t values given in Table 1 ou tperform all the three methods used in Neumann et al.
(2022) and for Hoeffding results in 15 out of the 36 settings g ets better proï¬ts according to Table 2. Generally, most
of these cases are from experiments on uncorrelated benchma rks. For the cases where the new methods perform better
on bounded strongly correlated instances, it is for higher u ncertainty level Î´= 50 and lower conï¬dence values like
Î±={0.01,0.01}.
Table 3 presents results for benchmarks with different disp ersion for proï¬ts of elements. The highest mean values
reported for each case show, for smaller instances, GSEMO an d NSGA-II give the highest mean proï¬ts, and for in-
stances with 300 or 500 elements, GSEMO+Filtering with gâ€²(x)and NSGA-II give the highest mean proï¬t. Although
the highest mean values can be identiï¬ed from different meth ods, the results are similar in most of the settings. Based
on the statistical comparisons, we can see that smaller inst ances: strong-100 and uncorr-100, do not signiï¬cantly diff er
between each methodâ€™s results. Results from other instance s show that for Î±= 0.1GSEMO+Filtering and NSGA-II
methods outperform the GSEMO. In addition, strong-500 inst ance shows better results from GSEMO+Filtering with
gâ€²(x)and NSGA-II with both ï¬tness functions for Î±= 0.01. However, in other settings with Î±={0.01,0.001}, all
methods show similar results for the instances with 300 and 5 00 items.
Compared to the benchmarks with the same dispersion for proï¬ ts, the ones with different dispersion can give higher
variance for the proï¬t of some elements. Therefore, it is cru cial to have a good spread of the solutions in the ï¬nal
population as more solutions tend to give negative proï¬t val ues when considering certain conï¬dence levels. NSGA-
II using crowding distance based sorting appears to achieve this when use with selected objectives in the ï¬tness
evaluations. In comparison, GSEMO+Filtering is also able t o achieve similarly good results by ignoring the solutions
without a valid Î±interval and eventually improving the ï¬nal population.
7 Conclusion
This paper explores multi-objective evolutionary approac hes to solve the proï¬t chance constrained KP. We introduce
ï¬tness evaluations for EAs to cater for this problem. These ï¬ tness functions can evaluate the solutions irrespective
of the required conï¬dence level of the solutions. Therefore , the outcome of EAs gives us a population that includes
solutions giving the best proï¬t value for different conï¬den ce levels. So it is unnecessary to decide on the required solutions giving the best proï¬t value for different conï¬den ce levels. So it is unnecessary to decide on the required
conï¬dence level before executing the algorithms, and no nee d to have multiple executions to investigate solutions
for different conï¬dence levels. After considering the avai lable solutions and risks associated with their proï¬ts, it i s
possible to make more informed decisions on what solutions t o implement for the problem instance. Furthermore, we
introduce a ï¬ltering method, which is applied at regular int ervals of ï¬tness evaluations. It keeps only the solutions wi th
a validÎ±interval in the interim populations, enabling the new offsp ring solutions in the next generations to improve
upon these solutions. The performance of these methods is ev ident in the experimental investigations.
Acknowledgements
This work has been supported by the Australian Research Coun cil (ARC) through grant FT200100536, and by the
South Australian Government through the Research Consorti um ""Unlocking Complex Resources through Lean Pro-
cessing"". This work was also supported with supercomputing resources provided by the Phoenix HPC service at the
University of Adelaide.
References
Yuma Abe, Masaki Ogura, Hiroyuki Tsuji, Amane Miura, and Shu ichi Adachi. 2020. Resource and Network Manage-
ment for Satellite Communications Systems: A Chance-Const rained Approach. IFAC 53 (2020), 3304â€“3309. Issue
12 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
2.
Hirad Assimi, Oscar Harper, Yue Xie, Aneta Neumann, and Fran k Neumann. 2020. Evolutionary Bi-Objective Opti-
mization for the Dynamic Chance-Constrained Knapsack Prob lem Based on Tail Bound Objectives. In ECAI 2020 ,
V ol. 325. IOS Press, 307â€“314.
C.C. Coello, D.A. Van Veldhuizen, and G.B. Lamont. 2013. Evolutionary Algorithms for Solving Multi-Objective
Problems . Springer US.
Kalyanmoy Deb. 2001. Multi-Objective Optimization using Evolutionary Algorit hms. John Wiley & Sons.
Kalyanmoy Deb, Samir Agrawal, Amrit Pratap, and T. Meyariva n. 2002. A fast and elitist multiobjective genetic
algorithm: NSGA-II. IEEE Trans. Evol. Comput. 6, 2 (2002), 182â€“197.
Benjamin Doerr. 2020. Probabilistic Tools for the Analysis of Randomized Optimiz ation Heuristics . Springer, Chap-
ter 1, 1â€“87.
Benjamin Doerr, Carola Doerr, Aneta Neumann, Frank Neumann , and Andrew M. Sutton. 2020. Optimization of
Chance-Constrained Submodular Functions. In The Thirty-Fourth AAAI Conference on Artiï¬cial Intelligen ce, AAAI
2020 . AAAI Press, 1460â€“1467.
Benjamin Doerr and Frank Neumann. 2021. A Survey on Recent Pr ogress in the Theory of Evolutionary Algorithms
for Discrete Optimization. ACM Trans. Evol. Learn. Optim. 1, 4, Article 16 (oct 2021), 43 pages.
Xinbo Geng and Le Xie. 2019. Data-driven decision making in p ower systems with probabilistic guarantees: Theory
and applications of chance-constrained optimization. Annual Reviews in Control 47 (2019), 341â€“363.
O. Giel. 2003. Expected runtimes of a simple multi-objectiv e evolutionary algorithm. In The 2003 Congress on
Evolutionary Computation, 2003. CEC â€™03. , V ol. 3. 1918â€“1925 V ol.3.
Fangguo He and Guiming Shao. 2009. An Evolutionary Algorith m for Uncertain Optimization Problems. In 2009
International Conference on Information Engineering and C omputer Science . IEEE, 1â€“4.
Konstantinos Kepaptsoglou, Grigorios Fountas, and Matthe w G. Karlaftis. 2015. Weather impact on containership
routing in closed seas. Transportation Research Part C: Emerging Technologies 55 (2015), 139â€“155.
Bo Liu, Qingfu Zhang, Francisco V . FernÃ¡ndez, and Georges G. E. Gielen. 2013. An Efï¬cient Evolutionary Algorithm
for Chance-Constrained Bi-Objective Stochastic Optimiza tion. IEEE Trans. Evol. Comput. 17, 6 (2013), 786â€“796.
Daniel H. Loughlin and S. Ranji Ranjithan. 1999. Chance-Con strained Genetic Algorithms. In GECCO â€™99 . Morgan
Kaufmann Publishers Inc., 369â€“376.
Kazuyuki Masutomi, Yuichi Nagata, , and Isao Ono. 2013. An Ev olutionary Algorithm for Black-Box Chance-
Constrained Function Optimization. Journal of Advanced Computational Intelligence and Intell igent Informatics
17, 2 (2013), 272â€“282.
Mehrnaz Mohtasham, Hossein Mirzaei-Nasirabad, and Behroo z Alizadeh. 2021. Optimization of truck-shovel alloca-
tion in open-pit mines under uncertainty: a chance-constra ined goal programming approach. Mining Technology
130 (2021), 81â€“100.
Aneta Neumann and Frank Neumann. 2020. Optimising Monotone Chance-Constrained Submodular Functions Using
Evolutionary Multi-objective Algorithms. In Parallel Problem Solving from Nature - PPSN XVI - 16th Intern ational
Conference, PPSN 2020, Proceedings, Part I (Lecture Notes i n Computer Science, Vol. 12269) . Springer, 404â€“417.
Aneta Neumann, Yue Xie, and Frank Neumann. 2022. Evolutiona ry Algorithms for Limiting the Effect of Uncertainty
for the Knapsack Problem with Stochastic Proï¬ts. In PPSN XVII . Springer, Cham, 294â€“307.
Frank Neumann, Mojgan Pourhassan, and Vahid Roostapour. 20 20.Analysis of Evolutionary Algorithms in Dynamic
and Stochastic Environments . Springer, Chapter 7, 323â€“357.
Frank Neumann and Andrew M. Sutton. 2019. Runtime Analysis o f the (1 + 1) Evolutionary Algorithm for the
Chance-Constrained Knapsack Problem. In FOGA â€™19 (FOGA â€™19) . ACM, 147â€“153.
Frank Neumann and Carsten Witt. 2022. Runtime Analysis of Si ngle- and Multi-Objective Evolutionary Algorithms Chance-Constrained Knapsack Problem. In FOGA â€™19 (FOGA â€™19) . ACM, 147â€“153.
Frank Neumann and Carsten Witt. 2022. Runtime Analysis of Si ngle- and Multi-Objective Evolutionary Algorithms
for Chance Constrained Optimization Problems with Normall y Distributed Random Variables. In IJCAI-22 . 4800â€“
4806.
Shen Peng. 2019. Chance constrained problem and its applications . Theses. UniversitÃ© Paris Saclay (COmUE) ; Xiâ€™an
Jiaotong University.
Feng Shi, Xiankun Yan, and Frank Neumann. 2022. Runtime Anal ysis of Simple Evolutionary Algorithms for the
Chance-Constrained Makespan Scheduling Problem. In PPSN XVII . Springer, 526â€“541.
13 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
Hemant Kumar Singh and JÃ¼rgen Branke. 2022. Identifying Sto chastically Non-dominated Solutions Using Evolu-
tionary Computation. In PPSN (2) (Lecture Notes in Computer Science, Vol. 13399) . Springer, 193â€“206.
Yue Xie, Oscar Harper, Hirad Assimi, Aneta Neumann, and Fran k Neumann. 2019. Evolutionary Algorithms for the
Chance-Constrained Knapsack Problem. In GECCO â€™19 . ACM, 338â€“346.
Yue Xie, Aneta Neumann, and Frank Neumann. 2020. Speciï¬c Sin gle- and Multi-Objective Evolutionary Algorithms
for the Chance-Constrained Knapsack Problem. In GECCO â€™20 . ACM, 271â€“279.
Yue Xie, Aneta Neumann, and Frank Neumann. 2021a. Heuristic Strategies for Solving Complex Interacting Stockpile
Blending Problem with Chance Constraints. In GECCO â€™21 . ACM, 1079â€“1087.
Yue Xie, Aneta Neumann, Frank Neumann, and Andrew M. Sutton. 2021b. Runtime Analysis of RLS and the
(1+1) EA for the Chance-Constrained Knapsack Problem with C orrelated Uniform Weights. In GECCO â€™21 . ACM,
1187â€“1194.
14"," This paper reviews five studies on evolutionary multi-objective algorithms for knapsack problems with stochastic profits. It introduces multi-objective formulations of the problem and three bi-objective fitness evaluation methods, and evaluates them using two multi-objective evolutionary algorithms. It also introduces a filtering method to improve the quality of the final population. The effectiveness of the approaches is demonstrated on several benchmarks, showing that GSEMO+Filtering and NSGA-II methods outperform the GSEMO in most settings."
27," Linear CNNs discover the statistical structure of the dataset
using only the most dominant frequencies
Hannah Pinson1Joerie Lenaerts1Vincent Ginis1 2
Abstract
Our theoretical understanding of the inner work-
ings of general convolutional neural networks
(CNN) is limited. We here present a new stepping
stone towards such understanding in the form of a
theory of learning in linear CNNs. By analyzing
the gradient descent equations, we discover that
using convolutions leads to a mismatch between
the dataset structure and the network structure.
We show that linear CNNs discover the statisti-
cal structure of the dataset with non-linear, stage-
like transitions, and that the speed of discovery
changes depending on this structural mismatch.
Moreover, we ï¬nd that the mismatch lies at the
heart of what we call the â€œdominant frequency
biasâ€, where linear CNNs arrive at these discover-
ies using only the dominant frequencies of the dif-
ferent structural parts present in the dataset. Our
ï¬ndings can help explain several characteristics
of general CNNs, such as their shortcut learning
and their tendency to rely on texture instead of
shape.
In addition to a neural networkâ€™s pre-deï¬ned architecture,
the parameters of the network obtain an implicit structure
during training. For example, it has been shown that weight
matrices can exhibit structural patterns, such as clusters and
branches (V oss et al., 2021; Casper et al., 2022). On the
other hand, the input dataset also has an implicit structure
arising from patterns and relationships between the samples.
E.g., in a classiï¬cation task, dogs are more visually similar
to cats than to cars. A general theory on how the implicit
structure in the network arises and how it depends on the
structure of the dataset has yet to be developed. Here we
derive such a theory for the speciï¬c case of two-layer, linear
CNN. Our approach is inspired by previous work on the
1Data Lab/Applied Physics, Vrije Universiteit Brussel, Plein-
laan 2, 1050 Brussel, Belgium2Harvard John A. Paulson School of
Engineering and Applied Sciences, Harvard University, 29 Oxford
Street, Cambridge, Massachusetts 02138, USA. Correspondence
to: Hannah Pinson <hannah.pinson@vub.be >.learning dynamics in linear fully connected neural networks
(FCNN) (Saxe et al., 2014; 2019). We study the different
involved structures in terms of singular value decomposi-
tions (SVD): of the input-output correlation matrix of the
dataset on the one hand (sec. 2.1), and of the SVD of the
constrained network structure induced by the convolutions
on the other hand (sec. 2.2). We subsequently consider the
equations of gradient descent in the slow learning regime,
yielding a set of differential equations (sec. 2.3). These
equations describe the evolution of the implicit network
structure, given the statistical dataset structure. Our analysis
reveals that the constraints in the network structure of a
CNN give rise to additional factors in those gradient descent
equations: these factors represent a mismatch between the
singular vectors of the data and those of the network (sec.
2.4). This mismatch inï¬‚uences the dynamics of learning,
changing the speed of discovery of the different parts of the
dataset structure (sec. 3) with respect to the speed of dis-
covery in a FCNN. Internally, this mismatch also leads to a
dominant frequency bias: only the dominant frequency com-
ponents of each singular vector of the dataset are used by the
CNN (sec. 4). Experiments conï¬rm the overall dynamics of
learning and the existence of the dominant frequency bias
(sec. 5).
Our results can be put in the context of the implicit reg-
ularisation resulting from training with gradient descent.
Neural networks used in practice contain much more train-
able weights than there are input samples. Therefore, the
target mapping between input and output could potentially
be realised by a lot of different weight settings. However,
using gradient descent yields speciï¬c outcomes for the (evo- target mapping between input and output could potentially
be realised by a lot of different weight settings. However,
using gradient descent yields speciï¬c outcomes for the (evo-
lution of the) network weights (Du et al., 2019; Arora et al.,
2019; Gidel et al., 2019; Advani et al., 2020; Satpathi &
Srikant, 2021). In (Saxe et al., 2014; 2019) the authors show
that the structure of the ï¬nal weights of linear FCNN reï¬‚ect
the dataset structure, at least when starting from random ini-
tial conditions and when using gradient descent. They ï¬nd
analytical solutions for the learning dynamics in a two-layer,
linear FCNN. These solutions indicate the stage-like discov-
ery of different structural parts of the dataset. The authors
assume a small learning rate, and the analytical solutions
are derived from a continuous time approximation to the
update equations of gradient descent. In (Gidel et al., 2019),arXiv:2303.02034v1  [cs.CV]  3 Mar 2023 Linear CNNs discover the statistical structure of the dataset using only the most dominant frequencies
the discrete dynamics are studied and in (Braun et al., 2022;
Atanasov et al., 2022), the authors develop the theory for dif-
ferent initialisation regimes. The relationship with a.o. early
stopping and learning order constancy for both CNN and
FCNN is further studied in (Hacohen & Weinshall, 2022)
as the principal component bias or PC-bias. Furthermore,
similar theories exist for linear and shallow non-linear auto-
encoders (Bourlard & Kamp, 1988; Pretorius et al., 2018;
Reï¬netti & Goldt, 2022). Finally, it has been shown that
linear CNN trained with gradient descent exhibit an implicit
bias in the form of sparsity in the frequency domain (Gu-
nasekar et al., 2018). We here show which mechanism gives
rise to this sparsity in the frequency domain, and we ï¬nd
which frequencies are developed over time.
1. Prerequisites
Notation The input consists of nnimages denoted Xs
wheresis the sample index. We will omit this index when
the context is clear. Often, we will need a vectorized (or
â€˜ï¬‚attenedâ€™) representation of Xand all other nnmatrices:
we turn those matrices in n21vectors through stacking
all rows one after the other, and transposing the result. The
resulting column vector is denoted with a lower case letter,
e.g.,vec(X) =x. We reverse this operation to show the
vectors as 2D images in ï¬gures. An index linto the vec-
tor which results from vectorizing a 2D matrix, denoted a
â€˜vec-2Dâ€™ index, runs from 0ton2"," This paper examines the use of linear convolutional neural networks (CNNs) to discover the statistical structure of a dataset using the most dominant frequencies. It provides insight into why CNNs are sensitive to adversarial perturbations, shortcut learning, and why they tend to learn surface statistical regularities instead of higher level abstractions. Experiments are implemented with TensorFlow/Keras and the results are discussed."
28," Magnetic Stochastic Synapses
Machine learning using magnetic stochastic synapses
Matthew O. A. Ellis,1,a)Alexander Welbourne,2,a)Stephan J. Kyle,2Paul W. Fry,3Dan A. Allwood,2Thomas J.
Hayward,2and Eleni Vasilaki1
1)Department of Computer Science, University of Sheeld, Sheeld, S1 4DP,
United Kingdom
2)Department of Materials Science and Engineering, University of Sheeld, Sheeld, S1 3JD,
United Kingdom
3)Department of Electronic and Electrical Engineering, University of Sheeld, Sheeld, S1 3JD,
United Kingdom
(Dated: 3rd March 2023)
The impressive performance of articial neural networks has come at the cost of high energy usage and CO 2
emissions. Unconventional computing architectures, with magnetic systems as a candidate, have potential as
alternative energy-ecient hardware, but, still face challenges, such as stochastic behaviour, in implementa-
tion. Here, we present a methodology for exploiting the traditionally detrimental stochastic eects in magnetic
domain-wall motion in nanowires. We demonstrate functional binary stochastic synapses alongside a gradient
learning rule that allows their training with applicability to a range of stochastic systems. The rule, utilising
the mean and variance of the neuronal output distribution, nds a trade-o between synaptic stochasticity and
energy eciency depending on the number of measurements of each synapse. For single measurements, the
rule results in binary synapses with minimal stochasticity, sacricing potential performance for robustness.
For multiple measurements, synaptic distributions are broad, approximating better-performing continuous
synapses. This observation allows us to choose design principles depending on the desired performance and
the device's operational speed and energy cost. We verify performance on physical hardware, showing it is
comparable to a standard neural network.
INTRODUCTION
The meteoric rise of articial intelligence (AI) as a part
of modern life has brought many advantages. However, as
AI programs become increasingly more complex, their en-
ergy footprint becomes larger1,2, with the training of one
of today's state-of-the-art natural language processing
models now requiring similar energy consumption to the
childhood of an average American citizen3. Several non-
traditional computing architectures aim to reduce this
energy cost, including non-CMOS technologies4{7. How-
ever, competitive performance with non-CMOS technolo-
gies requires overcoming the latent advantage of years of
development in CMOS.
In biological neural networks, synapses are considered
all-or-none or graded and non-deterministic, unlike the
fully analogue synapses modelled in articial networks8.
Inspired by biology, several approaches have considered
networks with binary synapses and neurons, with the
view that binary operations are simpler to compute and
thus lower energy9{12. However, while these binarised
neural networks are more robust to noise, they suer
from lower performance than analogue versions. In con-
trast, networks with stochastic synapses provide sam-
pling mechanisms for probabilistic models13and can ri-
val analogue networks at the expense of long sampling
times14{19. Adapted training methods are required to
provide higher performance for a lower number of sam-
ples, while implementations require hardware that can
a)These authors contributed equally to this work.natively (with low energy cost) provide the stochastic-
ity required. Magnetic architectures are one possible
route for unconventional computing. They have long
promised a role in computing logic following the strong
interest in the eld stemming from the data storage
market6,7,20{26. The non-volatility of magnetic elements
naturally allows for the data storage, while ultra-low-
power control mechanisms, such as spin-polarised cur-
rents or applied strain27,28oer routes towards energy-
ecient logic-in-memory computing. Ongoing develop-
ments have shown how to manipulate magnetic domains rents or applied strain27,28oer routes towards energy-
ecient logic-in-memory computing. Ongoing develop-
ments have shown how to manipulate magnetic domains
to both move data and process it22,29{31. However, mag-
netic domain wall logic is limited by stochastic eects,
particularly when compared to the low error tolerance
environment of CMOS computing32,33.
Here we propose a methodology where, rather than
seeking to eliminate stochastic eects, they become a
crucial part of our computing architecture. As a proof of
concept, we demonstrate how a nanowire is usable as a
stochastic magnetic synapse able to perform handwritten
digit recognition using multiplexing of one of the hard-
ware synapses.
We have developed a learning rule that can eectively
train articial neural networks made of such \noisy""
synapses by considering the synaptic distribution. Sup-
pose we allow a single measurement to identify the state
of the synapse. In that case, the learning rule will ad-
just its parameter, i.e. the eld at which the wall is
propagated, to reduce the synaptic stochasticity. If we
allow multiple measurements, the gradient rule will nd
parameters that allow for a broad synaptic distribution,
mimicking a continuous synapse and improving perfor-
mance. Without the stochasticity, the operation wouldarXiv:2303.01886v1  [cs.ET]  3 Mar 2023 Magnetic Stochastic Synapses 2
be limited to binary operations, which lack the resolu-
tion power of analogue synapses. With stochasticity,
we have a exible system tunable between quick-run-
time approximation and long-run-time performance. Our
learning rule provides ecient network training despite
the high or variable noise environment and diers from
other stochastic neural network computing schemes that
employ mean-eld-based learning rules14,16,19. Here, the
inclusion of the network variance allows the training to
nd better solutions in low sampling regimes, providing a
trade-o between operational speed/energy cost and test
accuracy.
We have veried the model performance experimen-
tally by transferring the trained weights to a network
utilising such a hardware synapse, with excellent agree-
ment between the experimental performance and that of
a simulated network. Our observations allow for a de-
sign framework where we can identify the number of re-
quired measurements (and hence energy requirements)
for a given desired accuracy and vice versa.
This work opens up the prospect of utilising the
low-energy-cost benets of spintronic-based logic5{7,34.
In particular, it enables the use of domain wall-based
nanowire devices24,31,35,36whilst transforming the hith-
erto hindrance of noisy operation32,33into the basis of a
high-performance stochastic machine learning paradigm.
RESULTS
Hardware stochastic synapse
Our proposed elementary computation unit is a binary
stochastic synapse based on a ferromagnetic nanowire
with two favourable magnetic orientations. The tran-
sitions between regions of diering magnetisation orien-
tation are known as domain walls (DWs). While dier-
ent forms of DWs exist, here they form a `vortex' pat-
tern with a cyclical magnetisation texture. Our synapse
was a 400 nm wide, 54 nm thick permalloy nanowire with
notches patterned halfway along its length to create an
articial defect site. Figure 1.a shows an SEM image of
the system, with the inset enlarging the notch. DWs were
nucleated at the left-hand side of the wire (false-coloured
blue) by applying a voltage pulse across a gold current
line (false-coloured orange).
The operation of this system as a stochastic synapse is
described schematically in gure 1.b. A vortex DW37can
be injected into the wire by applying a current pulse in
the line. This corresponds to presenting the synapse with
an input of 1, while no DW injection corresponds to an
input of 0. An applied magnetic eld is used to propagate
the DW along the length of the wire. If the propagation
eld is suciently high, the DW does not pin at the defect
site and can pass to the end of the wire, resulting in an
output of 1. If the propagation eld is low, the DW is
pinned at the notch, resulting in an output of 0. For
intermediate values of the eld, the behaviour becomesstochastic but with a well dened pinning probability.
We can consider the eld control as controlling the weight
in a binary synapse with detecting a DW on the right
hand side of the nanowire as the output of the synapse.
As the propagation eld is tuned, the probability of the
DW passing changes. Figure 1.c shows this passing prob-
ability, as measured using the focused Magneto-Optical
Kerr eect (FMOKE), as a function of the propagation
eld. The probability of passing behaves in a sigmoid-
like manner, and the orange dashed line shows a t using
a logistic sigmoid function f(hij) (see methods).
Therefore, a binary stochastic synapse is determined
by
wij=(
1 with probability f(hij)
0 otherwise,(1)
wheref(hij) is the DW passing probability function, hij
is the propagation eld for the synapse connecting input
neuronjwith output neuron i. Through this denition
our synapses are purely excitatory, which corresponds
to the physical representation of a magnetic DW being
pinned or not, rather than the complementary binary
scheme with values f"," This paper presents a novel learning rule for magnetic stochastic synapses, which allows for weights to be trained that operate better in the low sampling regime compared to the mean-field versions. It covers the use of magnetic stochastic synapses for energy-efficient neuromorphic devices, such as connectionist reinforcement learning, spike-based reinforcement learning, voltage control of domain walls, and more. It also references research studies related to nanomagnetic reservoir computing, reservoir computing with emergent dynamics in a magnetic metamaterial, physical reservoir computing with nanomagnetic devices, and a digital biologically plausible implementation of binarized neural networks with differential hafnium oxide resistive memory arrays. Lastly, the article references the MNIST database of handwritten digits."
29," Reservoir computing based on solitary-like waves dynamics of lm
ows: a proof of concept
Ivan S. Maksymov1andAndrey Pototsky2
1Articial Intelligence and Cyber Futures Institute, Charles Sturt University, Bathurst, NSW 2795, Australia
2Department of Mathematics, Swinburne University of Technology, Hawthorn, Victoria 3122, Australia
Abstract { Several theoretical works have shown that solitons|waves that self-maintain constant
shape and velocity as they propagate|can be used as a physical computational reservoir, a concept
where machine learning algorithms designed for digital computers are replaced by analog physical
systems that exhibit nonlinear dynamical behaviour. Here we propose and experimentally validate
a novel reservoir computing (RC) system that for the rst time employs solitary-like (SL) waves
propagating on the surface of a liquid lm owing over an inclined surface. We demonstrate the
ability of the SL wave RC system (SLRC) to forecast chaotic time series and to successfully pass
essential benchmark tests, including a memory capacity test and a Mackey-Glass model test.
Introduction. { Reservoir computing (RC) [1] and
its foundational concepts of context of reverberated input
histories [2], Liquid State Machine (LSM) [3] and Echo
State Network (ESN) [4] underpin an important class of
machine learning (ML) algorithms that can perform cer-
tain functions of a biological brain [3] and that can be
trained to recognise patterns and to forecast the response
of nonlinear dynamical systems that exhibit chaotic be-
haviour [5]. This functionality enables using RC systems
in many areas of science and technology, including physics,
psychology and nance [6,7].
The ability of an RC system to perform complex fore-
casting tasks originates from its structural organisation
[Fig. 1(a)] that separates a fast linear readout layer from
a much slower articial neural network called the reservoir
[4]. The reservoir consists of a network of randomly con-
nected articial neurons, and it converts a time-varying
input into a spatio-temporal pattern of neural activations
that is then transformed into practical outputs using the
readout layer. While the readout layer is task-specic and
memory-less, the universal reservoir is based on the princi-
ples of nonlinear dynamical systems and has certain mem-
ory [8]. Such a structure enables a reservoir consisting of a
relatively small number of articial neurons to be more ef-
cient in resolving certain practical problems than a com-
puter program run on a supercomputer. Thus, one can
draw an analogy between a reservoir and some biological
brains [3], including the brains of fruit ies and mosquitos
that, on average, have just about 200,000 neurons (in con-
trast to mammalian brains that have tens of billions neu-rons) but enable the insects to perform complicated tasks
while they navigate and nd food [9].
Although in the framework of LSM the analogy between
a reservoir and a liquid was made rather at an abstract
level [3], follow-up research works have demonstrated that
physical liquids inherently possess all characteristics re-
quired for the creation of a reservoir [10{16]. There have
also been theoretical proposals [17{20] of RC systems
based on optical solitons [21]. However, there have been
no experimental demonstrations of soliton-based RC sys-
tem yet.
In this paper, we experimentally demonstrate a physical
RC system that exploits the dynamics of solitary-like (SL)
waves [Fig. 1(b)] that originate from the spatio-temporal
evolution of liquid lms owing over an inclined surface
[22{24]. We conrm the plausibility of the SL waves based
RC (SLRC) system using several standard test protocols
designed to benchmark computer programs that imple-
ment the concept of RC. SL waves are ubiquitous in nature
and can be readily observed in many everyday-life situa-
tions [Fig. 1(c)]. Subsequently, the principles of SLRC
demonstrated in this work should be applicable to nu- and can be readily observed in many everyday-life situa-
tions [Fig. 1(c)]. Subsequently, the principles of SLRC
demonstrated in this work should be applicable to nu-
merous physical system that support roll waves [24, 25],
including microuidic devices [26].
Algorithmic reservoir computing. { A standard
ESN algorithm [Fig. 1(a)] that we employ as a reference
uses the following nonlinear update equation:
xn= (1"," This paper presents a novel reservoir computing system based on solitary-like waves propagating on the surface of a liquid film flowing over an inclined surface. The system is experimentally validated and is shown to be able to forecast chaotic time series and pass essential benchmark tests. It is hypothesized that the use of SL waves in the field of RC may be advantageous due to their unique nonlinear properties. The memory capacity of the SLRC system is an order of magnitude higher than that reported in a previous optical soliton RC system. The article also discusses the use of echo state networks and solitons in reservoir computing, as well as various research studies related to chaos, solitons, and fractals."
30," EVOLUTIONARY AUGMENTATION POLICY OPTIMIZATION FOR
SELF-SUPERVISED LEARNING
A P REPRINT
Noah Barrett1,2,â€ , Zahra Sadeghi1,2,â€ ,*, and Stan Matwin1,2
1Facutly of Computer Science, Dalhousie University, Halifax, Canada
2Institute for Big Data Analytics, Halifax, Canada
*Correspondence: zahras@dal.ca
ABSTRACT
Self-supervised learning (SSL) is a Machine Learning algorithm for pretraining Deep Neural Networks (DNNs)
without requiring manually labeled data. The central idea of this learning technique is based on an auxiliary
stage aka pretext task in which labeled data are created automatically through data augmentation and exploited
for pretraining the DNN. However, the effect of each pretext task is not well studied or compared in the
literature. In this paper, we study the contribution of augmentation operators on the performance of self supervised
learning algorithms in a constrained settings. We propose an evolutionary search method for optimization of
data augmentation pipeline in pretext tasks and measure the impact of augmentation operators in several SOTA
SSL algorithms. By encoding different combination of augmentation operators in chromosomes we seek the
optimal augmentation policies through an evolutionary optimization mechanism. We further introduce methods for
analyzing and explaining the performance of optimized SSL algorithms. Our results indicate that our proposed
method can ï¬nd solutions that outperform the accuracy of classiï¬cation of SSL algorithms which conï¬rms the
inï¬‚uence of augmentation policy choice on the overall performance of SSL algorithms. We also compare optimal
SSL solutions found by our evolutionary search mechanism and show the effect of batch size in the pretext task on
two visual datasets.
Keywords Self-supervised learning, Data Augmentation, Evolutionary Algorithms, Deep Learning, Deep Neural
Networks, Optimization, Explainability, Artiï¬cial Intelligence
1 Introduction
The supreme power of Machine Learning algorithms is founded on supervised learning techniques. However, while
these algorithms have shown to be tremendously successful in solving classiï¬cation problems, they remain entirely
dependent on a large corpus of manually annotated data. As a result, the whole process of learning is not autonomous
and tends to be inï¬‚uenced by the error of annotation. Self-supervised learning (SSL) has been introduced in response
to tackling these limits by making the possibility of training DNNs without relying on labeled data. The core of SSL
is based on an auxiliary phase aka pretext task which focuses on pretraining networks using automatically generated
labeled data. One crucial aspect of pretext tasks is transforming unlabeled images using augmentation operators in
order to produce labeled samples. Although many different SSL paradigms have been developed, there is no speciï¬c
investigation about their level of effectiveness and usefulness. Moreover, there is no speciï¬c study to investigate
the effect of augmentation operators on the performance of each of the proposed self supervised algorithms. In this
yThese authors contributed equally to this workarXiv:2303.01584v1  [cs.CV]  2 Mar 2023 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
study, we show that the choice of augmentation operators can bear an impact on the achievable performance of the
downstream problem. Through a series of experiments, we seek to measure the inï¬‚uence of different augmentation
policies. We formulate an evolutionary search algorithm in order to optimize the transformation settings that lead to
best outputs. To this end, we focus on four state-of-the-art SSL algorithms that have indicated high performance on
various datasets. This paper encompasses the following original contributions. We ï¬rst investigate the best combination
of augmentation operators in four state-of-the-art SSL algorithms through an evolutionary learning algorithm. Then,
we compare the performance of these SSL methods before and after the optimization process. We ï¬nd and evaluate
the best augmentation operators for each SSL method across two different datasets. In the end, we run explanatory
analysis over the optimized chromosomes to understand the impact and importance of augmentation operators for
each SSL algorithm and dataset. This paper is organized as follows: We provide an overview about Self-Supervised
Learning, Auto Augmentation and Search Optimization Algorithms in section 2. In section 3, implementation details
are mentioned. Then, in section 4, our method is described. The experiments and results are provided in section 5. The
explainability methods are presented in section 6. Finally, section 7 concludes the paper.
2 Related work
In this section, we provide a literature survey about related prior work in three subsections. First, we introduce the
paradigm of self-supervised learning algorithms and review ongoing research in this ï¬eld. Secondly, we go over recent
advances in Auto Augmentation. Finally, we provide an overview about Intelligent Search algorithms.
2.1 Self-Supervised Learning
Self-Supervised Learning has increased attention in Machine Learning due to its ability to handle unlabeled data more
efï¬ciently than the traditional unsupervised learning. This is achieved by designing a new phase of learning known as
pretext task, which is an attempt for solving an auxiliary classiï¬cation task. The auxiliary task is focused on classifying
the data into self-labeled categories in order to obtain a pretrained model with rich feature representation about the
underlying structure of data. Various approaches have been proposed for designing the pretext tasks, which can be
classiï¬ed into patch-based, instance-based, and video-based methods. Patch-based methods aim to learn the relative
position between patches of an image Doersch et al. (2015), while instance-based methods utilize the whole image and
take advantage of an augmentation task such as an afï¬ne transformation Doersch et al. (2015) or colorization Isola
and Efros (2016). In contrast, video-based methods design a task that can take advantage of the sequential ordering of
frames in a video clip Misra et al. (2016). Self-supervised learning can also be categorized into generative or contrastive
models. Generative modeling approaches aim to reconstruct the input through the deployment of autoencoders Pathak
et al. (2016) and GANs Donahue et al. (2016) while the contrastive approach includes the attempts to increase the
discrimination between different images and decrease it for similare ones by applying contrastive learning Oord et al.
(2018). Self-supervised learning is highly associated to contrastive models, while the generative approach is often
considered as an unsupervised learning scheme. A variety of different approaches have been proposed in order to solve
the pretext task which are highly focused on different forms of augmentation, such as spatial location and relative
positions of patches Noroozi and Favaro (2016)Dosovitskiy et al. (2014), image transformation including rotation positions of patches Noroozi and Favaro (2016)Dosovitskiy et al. (2014), image transformation including rotation
Gidaris et al. (2018), altering global statistics while preserving local statistics Jenni et al. (2020), data and color jittering,
painting and coloring Isola and Efros (2016). Given the fact that such pretext tasks are intrinsically different, it is
very intriguing to investigate the effect of pretraining process of pretext task in quest of discovering performance
differences in downstream tasks. In this paper, we focus on comparing four state-of-the-art SSL algorithms, namely,
BYOL gri (2020), simsiam Chen and He (2021), NNCLR Dwibedi et al. (2021) and SWA V Caron et al. (2020). All of
these SSL algorithms share fundamental similarities in their architecture and underlying methodology. Speciï¬cally, all
algorithms employ a Siamese architecture at its core. Siamese architectures consist of a shared input network which
feeds into two separate neural networks that share weights, and an architecture that is analogous to siamese twins in
nature. Conventionally, Siamese networks are used for images, where the inputs are different images, and the actual
2 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
comparability of images are determined in a supervised manner Chen and He (2021). BYOL, SimSiam, NNCLR, and
SwA V share the general notion of contrastive learning using a siamese architecture, however the speciï¬c details of
implementation and theoretical motivation creates signiï¬cant differences in the four algorithms. It is of great importance
to note that the authors of these four algorithms highlight, to varying degrees, their invariability to augmentation. The
proposed work looks into the margins of these ï¬ndings and expose that while there is an astounding invariance to
augmentation strategies in the proposed algorithms overall, there still is room for improvement for understanding the
effect of augmentation in contrastive learning. The key idea of BYOL is that from a given representation, called the
target representation, it is possible to train an enhanced representation,i.e., the online representation. BYOL works
iteratively, to improve the learned representation by using a slow moving average of the online network as the target
network gri (2020). BYOL does not require negative samples, and claims to be insensitive to batch sizes and the types of
augmentations used. BYOLâ€™s ability of not requiring a large batch sizes, negative pairs, as well as having a novel level
of robustness to augmentations was what made it a breakthrough algorithm at the time of its release. BYOLâ€™s robustness
to augmentation is in comparison to one of the earliest forms of contrastive SSL SimCLR Chen et al. (2020), it is shown
that BYOL suffers a much smaller performance drop than SimCLR when only using random crops. SimSiam is an SSL
method that opts for simplicity and highlights the signiï¬cance of the Siamese network architecture of SSL methods.
SimSiam shows that the shared weight conï¬guration is key to many core SSL algorithms, and a simple stop gradient
approach can be used to prevent collapse Chen and He (2021) which is a common issue in many algorithms employing
Siamese networks. Collapse occurs when the model maps every image to the same point, maximizing similarity when
comparing, but in turn not learning any important information about problem at hand. SimSiam provided surprising
evidence that meaningful representations can be learned without the use of negative sample pairs, large batches and
momentum encoders. The ï¬rst two of these were already unnecessary in the earlier work shown in BYOL, however,
the momentum encoder component was thought of as a crucial component to its avoidance of collapsed solutions.
Perhaps, the most remarkable discovery produced by SimSiam could be that a simple stop gradient is all that is needed
to successfully train a Siamese architecture. Compared to BYOL and SimSiam, SwA V provides a novel mechanism for
learning. Following the vanilla approach of contrastive learning, BYOL and SimSiam learn by predicting the ""closeness""
of two views of a sample, this is a core concept to Siamese Networks and their impactful discoveries in representation
learning. Simply put, SwA V learns by computing a code from an augmented version of an image and then predicts
this code from other augmented versions of the same image. The method simultaneously clusters data while enforcing
consistent cluster assignments between different views Caron et al. (2021). Additionally, SwA V introduces a novel
augmentation multi-crop, which allows for more memory efï¬cient comparisons by utilizing a small set of large crop
windows and a larger set of small crop windows. This means, despite employing a Siamese architecture, SwA V is not
actually a form of contrastive learning. However, SwA V at its core still aims to learn a strong latent representation of
the problem at hand. The use of this alternate approach yields a new breakthrough unfound by BYOL and SimSiam, the problem at hand. The use of this alternate approach yields a new breakthrough unfound by BYOL and SimSiam,
which is the ability to signiï¬cantly reduce the number of pairwise feature comparisons, reducing the computational
and memory requirements of the algorithm. Compared to the other discussed SSL methods, NNCLR introduces a very
novel concept with respect to the selection of positive pairs. Rather than deriving positive samples for an image via
augmentation, they show that it is possible to use the nearest neighbours of an image of interest in the given data space
as positive samples. Like BYOL and SimSiam, NNCLR is a contrastive learning method, which similar to SimSiam
employs a very simple architecture. The novelty is in the selection of positive samples from the given dataset, rather
than derivation from augmentation. NNCLR samples positive samples by computing the nearest neighbours of a given
sample in the learned latent space of the dataset. This approach provides more semantic class wise variations rather
than pre-deï¬ned transformations which tend to provide more geometric information Dwibedi et al. (2021). Alike all the
above discussed approaches, NNCLR ï¬nds that it is not very reliant on data augmentation.
All four discussed algorithms share the use of a Siamese architecture, SimSiam can be thought of as the simplest version
of these learning approaches using a Siamese architecture. BYOL adds a slight sort of complexity to the learning
method by employing a slow moving average approach for the target component of the Siamese network. Like SimSiam,
NNCLR also opts for simplicity in its architecture, however it refrains from employing only augmentation to generate
3 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
positive samples, and instead, determines the nearest neighbours of a given image to select positive samples. SwA V
differs from all three methods in that it utilizes a swapped prediction mechanism for learning rather than the typical
contrastive mechanism. All four algorithms have recently shown remarkable breakthroughs in the Self-Supervised
Computer vision world, and for this reason they have been chosen as focal points in our work. The four algorithms all
claim to have a varying degree of invariance to data augmentation based on empirical ï¬ndings. However, the contrastive
mechanism of BYOL, SwA V and SimSiam, rely solely on data augmentation. Given the limited discussion on the
effect of data augmentation, the question of its impact to the different SSL algorithms still remains. In this work, we
hypothesize that by picking the best set of augmentation operators, we can boost the performance of SSL algorithms.
2.2 Auto Augmentation
Data Augmentation is a regularization technique that has been mainly developed for dealing with overï¬tting issue
in training DNNs by increasing the diversity of training examples Shorten and Khoshgoftaar (2019). Recently, this
approach has been adopted in contrastive self-supervised learning procedure for creating additional positive samples
while preserving the semantic content of observations V on KÃ¼gelgen et al. (2021). As mentioned in previous section,
the positive samples will be discriminated against negative samples in a training procedure to obtain a rich embedding
that can be used for learning different tasks. While data augmentation is the core basis of self-supervised learning,
little attention has been placed over understanding its impact and there is not many investigations about the theoretical
success of augmentation tasks. To the best of our knowledge there is no systematic study to assess the effect of
employing different augmentation policies in Self-supervised Learning. Some authors have pointed out the important
role of transformation operators in self-supervised feature learning performance. Jenni et al., argued that transformation
function selection is data-speciï¬c and hence each dataset might beneï¬t from a different set of transformations. In
addition, different tasks could require tailored augmentation techniques. For example, for anomaly detection a novel
proxy task has been proposed Li et al. (2021). Along the recent endeavors in AutoML which aim to automate the
Machine Leaning procedure, Auto Augmentation methods are developed in order to seek the optimal augmentation
strategies for training Deep Neural Networks to improve the performance of DNNs. AutoAugment can be regarded as
one of the pioneering approaches for designing an automatic data augmentation learning procedure Cubuk et al. (2019).
This approach is based on employing reinforcement learning to explore search space of augmentation policies. In Lim
et al. (2019) the auto augmentation procedure is accelerated by matching the density between training and validation
data. PBA Ho et al. (2019) is another approach for that uses a hyperparameter search algorithm to learn a schedule of
augmentation polices.
2.3 Search optimization algorithms
Search optimization algorithms are one of the core components for the tremendous success of Machine Learning
techniques and they are increasingly exploited in fundamental problems of parameter and hyperparameter tuning and
model selection Brazdil et al. (2022). An optimization algorithm seeks to adjust the conï¬guration of Machine Learning
algorithms by minimizing a cost function such that it will lead to accurate estimation and prediction. Through iterative
search algorithms, the best conï¬guration that best describes a distribution of observable data can be obtained. There
are a variety of search optimization techniques which are employed for Machine Learning tasks Yang and Shami are a variety of search optimization techniques which are employed for Machine Learning tasks Yang and Shami
(2020). The simplest one is known as exhaustive search which looks for ï¬nding the best parameters by checking
as many possible solution as possible based on the level of desirable performance or computational resources. Two
well-known subcategory of this type are random search which randomly explores the search space, and grid search
which systematically discretizes the search space and checks the solutions that fall on in grid. Other more intelligent
methods which are developed for a more effective search are including Gradient based methods, Reinforcement
Learning and Evolutionary Algorithms. Gradient based approaches are iterative search algorithms which attempt to
ï¬nd the optimal solutions according to gradient value at each step. These algorithms often gets stuck in local optima.
Reinforcement learning algorithms, on the other hand, is a search paradigm that traverses solution space based on taking
4 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
Table 1. All augmentation operators used and the associated intensity ranges. This set of operators is the same as
AutoAugment Cubuk et al. (2019).
Augmentation Intensity Range
HorizontalFlip 0.0, 1.0
VerticalFlip 0.0, 1.0
ShearX 0.0, 0.3
ShearY 0.0, 0.3
TranslateX 0, 14
TranslateY 0, 14
Rotate -30, 30
Color 0.1, 1.9
Solarize 0.0, 1.0
Contrast 0.1, 1.9
Sharpness 0.1, 1.9
Brightness 0.1, 1.9
actions from a predeï¬ned list. Each action changes the state of the agent and induces a reward. The goal is to maximize
the return or the sum of discounted rewards. Evolutionary optimization is referred to bio-inspired methods in which a
population of solutions are created, evolved and evaluated iteratively. Three popular Evolutionary algorithm variants are
Genetic Algorithms (GA), Genetic Programming (GP) and Evolutionary Strategies (ES) Oâ€™Neill (2009). Evolutionary
algorithms have attracted attention of researcher due to multiple unique properties. They can search the space in a
parallel and independent manner, they are not based on gradient calculation and hence do not suffer from exploding or
vanishing gradients Such et al. (2017). Due to these intriguing features, we have applied a Genetic Algorithm in this
paper which is described in the next section.
3 Implementation Details
This work is interested in exploring a massive amount of different conï¬gurations of augmentations in the pretext task of
common SSL algorithms, in order to do so, two standard benchmark which are commonly used for image classiï¬cation
are used. We explore the performance of four SSL algorithms using two different batch sizes of 32 and 256. We carry
out the experiments on CIFAR-10 and SVHN datasets. In the following subsections, we provide more in-depth details
about the outcome of each experiment.
3.1 Dataset
CIFAR-10 . The CIFAR-10 dataset Krizhevsky (2009) is a popular coloured image dataset consisting of 10 classes of
airplane, automobile, bird, cat, deer, dog, frog, horse, ship, and truck. This dataset consists of 60000 32x32 images,
with 50000 train images and 10000 test images. The test set consists of 1000 randomly sampled instances from each
class, and the remaining 50000 are used for the training set. The classes in this dataset are mutually exclusive and the
creators took extra caution to ensure the similar classes of truck and automobile contain no overlap.
SVHN . The Street View House Numbers (SVHN) Dataset Netzer et al. (2011) is an image dataset consisting of real
world images of house numbers taken from Google street view images. This dataset is presented as a more challenging
version of MNIST Deng (2012) consisting of 600,000 32x32 labeled digits which are cropped from street view images.
The classiï¬cation problem posed in SVHN is signiï¬cantly harder than MNIST as it contains real-world images of
numbers.
5 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
3.2 Network Architecture and Training Speciï¬cations
For all experiments, a small and simple convolutional neural network is used as the backbone for both pretraining
and downstream tasks. As illustrated in 1, this network consists of 3 convolutional blocks. Each block contains two
convolutions with a kernel size of 3x3, followed by ReLU activation functions, a max pool and a batch normalization
operation. For each SSL algorithm, i.e., BYOL, NNCLR, SimSiam and SwA V , this backbone is applied in accordance
to the speciï¬c algorithm. All the hyperparameter used for network training of each of the SSL algorithm are according
to the original papers. For the downstream classiï¬cation task, all experiments use an Adam optimizer with a learning
rate of 0.001 and weight decay of 0.0005. Cross entropy is used as loss function. In addition, a three layer linear model
with ReLU activation is used on top of the pretrained networks. We train both the pretext and downstream tasks for
10 epochs. The backbone is ï¬rst pretrained using one of the four SSL algorithms then the linear head is added to the
network for ï¬ne-tuning on the downstream task. For each experiment, we roughly exploit 4GB of GPU and 12 CPUs.
Figure 1. Architecture of Network used for the downstream task.
The implementation of the proposed work relies on several different libraries. For the deep learning components, such
as model architectures, dataset loading, and supervised training, PyTorch is used Paszke et al. (2019). Building on
PyTorch, the python library, Lightly Susmelj et al. (2020), implements cutting edge SSL algorithms, this library is used
for implementing the four SSL algorithms in this research. To implement the evolutionary mechanism in this research,
the python library Deap Fortin et al. (2012) is employed.
4 Method
We propose two evolutionary mechanism for augmentation operator optimization through Genetic algorithm to ï¬nd the
best performing chromosomes and corresponding models. The ï¬rst approach is a single optimization method, in which
augmentation policy of each one of the four SSL algorithm is optimized individually, whereas the second approach
is a multi optimization method through which not only we optimize the augmentation policy but also optimize the
downstream task performance by ï¬nding the best performing algorithm.
4.1 Evolutionary Data Augmentation Optimization
The proposed research aims to apply a Genetic algorithm to optimize augmentation policies for four different cutting-
edge self-supervised algorithms. From a genetic algorithm perspective, the key area that requires the most attention is
the deï¬nition of the ï¬tness function. The proposed ï¬tness function serves as a proxy function that aims to gauge the
impact of changing the augmentation policies for a given self-supervised algorithm. Below, our formulation of the ï¬tness
function is elaborated. To represent the augmentation strategies as chromosomes we employ a value representation. We
experiment with two different ï¬‚avours of evolutionary augmentation optimization, namely single optimization (SO)
and Multiple Optimization (MO) modes. With SO we choose one SSL algorithm and exclusively optimize it with GA,
while with MO all four SSL algorithms are evolved together.
6 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
4.1.1 Chromosome Deï¬nitions and Augmentation Policies
Taking inspiration from AutoAugment and the preceding work in learning augmentation policies, the proposed value
encoding assumes a set of kaugmentations, A=fa1;a2;:::;a kg. For each augmentation aian intensity value i
can be deï¬ned. Authors of Cubuk et al. (2019) deï¬ned a range of values for intensity of each augmentation operator.
For the purpose of this work, these ranges have been borrowed. Table 1 shows all the different operators used in our
experiments along with their possible ivalues. Letikbe the intensity value assigned to augmentation operator akand
Kbe the maximum number of augmentation operators, in SO, we formulate an augmentation policy in a chromosome
asCi=f(a1;i1);(a2;i2);:::; (al;il)g, wherelK. For the purpose of our experiments, we use a value of 3 for
l. In MO, we represent a chromosome as Ci= (algj;f((a1;i1);(a2;i2);:::; (al;il)g)wherealgjis one of the SSL
algorithms infSwAV;NNCLR;Simsiam;Byol g.
4.1.2 Fitness Function
The proposed ï¬tness function aims to evaluate augmentation policies for SSL algorithms based on downstream tasks.
More speciï¬cally, the test accuracy in the downstream supervised task serves as the ï¬tness for augmentation optimization.
It is important to note that in this work we are focused on the augmentation policies for the pretext task, and a ï¬xed
set of augmentations are used for the supervised downstream task. The most crucial part of our ï¬tness function is the
ï¬xing of randomness. By ï¬xing every random component of the deep learning pipeline, the difference between two
augmentation strategies can be soundly compared in relative terms. In order to compensate for bias due to ï¬xing the
random components of the deep learning pipeline we evaluate the our method using Ndifferent random seeds for the
neural network initialization and data shufï¬‚ing. The seed values for each experiment are shown in Table 3.
4.1.3 Selection
There exists a large swath of different selection methods such as Roulette, tournament and Rank ?. Our method opts for
a simple and common approach of Roulette. In this approach, every chromosome has an equal chance of being selected
proportional to their ï¬tness.
4.1.4 Crossover
When selecting a crossover operation caution must be taken to prevent the children chromosomes from having duplicate
augmentations. To handle this issue, Partially Mapped Crossover (PMX) Reeves (2003) is employed. This method
avoids creation of chromosomes with duplicate genes. When performing crossover between two or more chromosomes,
the mechanism for preventing duplicate genes is based purely on the augmentation operator and not the intensity. When
two chromosomes are crossed over, the shared genes are completely copied over to maintain the same intensity as the
parentâ€™s gene. When performing crossover for our MO approach, PMX is applied to the augmentation policy portion of
the chromosome, but for the SSL gene, it is probabilistically swapped with the other chromosome.
4.1.5 Mutation
For mutation, only the intensities of the augmentation operators are mutated. In order to perform this, a custom mutation
function is created. We call this function MutGaussianChoice . This mutation operator probabilistically mutates the
genes intensity values within the acceptable range of intensity for that speciï¬c operator. The intensity is increased or
decreased incrementally by the range of the intensity values (as shown in Table 1) divided by the increment value which
is computed using equation 1. For MO, MutGaussianChoice is applied to the augmentation policy portion of the
chromosome, but for the SSL gene, the gene is randomly mutated to a different SSL algorithm.
7 Evolutionary Augmentation Policy Optimization for Self-Supervised Learning A P REPRINT
increment =max(irange )"," This paper proposes an evolutionary augmentation policy optimization (EAPO) approach for self-supervised learning. It uses a genetic algorithm to optimize the augmentation policies for four different self-supervised learning algorithms (BYOL, SimSiam, NNCLR, and SwA V). Results show that the proposed method can consistently improve the performance of SSL algorithms, with larger batch sizes having a larger impact on the improvement of the accuracy of downstream task classification. Additionally, the paper also presents two explainability methods to analyze the most influential operators for each dataset and self-supervised learning algorithms."
31," Hindsight States:
Blending Sim & Real Task Elements for
Efï¬cient Reinforcement Learning
Simon Guist, Jan Schneider, Alexander Dittrich, Vincent Berenz, Bernhard Sch Â¨olkopf and Dieter B Â¨uchler
Abstract â€”Reinforcement learning has shown great potential
in solving complex tasks when large amounts of data can
be generated with little effort. In robotics, one approach to
generate training data builds on simulations based on dynamics
models derived from ï¬rst principles. However, for tasks that, for
instance, involve complex soft robots, devising such models is
substantially more challenging. Being able to train effectively in
increasingly complicated scenarios with reinforcement learning
enables to take advantage of complex systems such as soft
robots. Here, we leverage the imbalance in complexity of the
dynamics to learn more sample-efï¬ciently. We (i) abstract the
task into distinct components, (ii) off-load the simple dynamics
parts into the simulation, and (iii) multiply these virtual parts
to generate more data in hindsight . Our new method, Hindsight
States (HiS), uses this data and selects the most useful transitions
for training. It can be used with an arbitrary off-policy algorithm.
We validate our method on several challenging simulated tasks
and demonstrate that it improves learning both alone and
when combined with an existing hindsight algorithm, Hindsight
Experience Replay (HER). Finally, we evaluate HiS on a physical
system and show that it boosts performance on a complex table
tennis task with a muscular robot. Videos and code of the
experiments can be found on webdav.tuebingen.mpg.de/his/.
I. I NTRODUCTION
Reinforcement learning (RL) holds great potential for de-
vising optimal behavior for challenging robotics tasks. Dif-
ï¬culties in these tasks often arise from contact in object
manipulation, the requirement to perform fast but accurate
motions, or from hard-to-control systems like soft robots.
While it has been shown that RL can handle such problems,
the major drawback of RL methods to require large amounts
of interactions with the environment remains. This fact makes
learning on real robots challenging.
Training in simulation and transferring the resulting policy
to the real system is one approach to alleviate this challenge.
However, even small inaccuracies in the simulation can cause
the simulated and real system to behave differently, a problem
known as reality gap . This problem is worse for complex
systems like soft robots, which are hard to model accurately.
Sim-to-real techniques attempt to mitigate the impact of the
reality gap. Many popular techniques accomplish more ef-
fective policy transfer by making the learned policies more
robust to variations in the task dynamics through domain
This work was supported by the Max Planck Institute for Intelligent
Systems.
All authors are afï¬liated with the MPI for Intelligent Systems, Max-Planck-
Ring 4, 72076 T Â¨ubingen, Germany.randomization [26, 41]. However, these methods are gen-
erally computationally expensive and require precise ï¬ne-
tuning of the parameters, such as the amount of randomization
on the dynamics parameters. These downsides of sim-to-
real approaches accumulate as tasks advance in complexity,
thus, necessitating learning many complex tasks partly or
completely on the real system.
Hybrid sim and real (HySR) [5] is a way to ease the training
of complex tasks on real systems. The method is based on the
insight that for some tasks, certain parts of the environment
have simpler dynamics than others. For instance, many robotic
ball games consist of a robot, whose dynamics are more
complex compared to those of the ball. The mismatch in mod-
eling complexity is exacerbated if the robot is equipped with
soft components, which render modeling even more difï¬cult.
The idea behind HySR is to keep the complicated parts of
the task real, whereas the simpler parts are simulated. This
strategy yields signiï¬cant practical beneï¬ts, while facilitating The idea behind HySR is to keep the complicated parts of
the task real, whereas the simpler parts are simulated. This
strategy yields signiï¬cant practical beneï¬ts, while facilitating
the transfer to the entirely real system. First, the approach
simpliï¬es setting up the task since fewer real objects have
to be handled that, for instance, are subject to wear-and-
tear or require safety considerations. Second, it can greatly
simplify the reset mechanism in episodic RL tasks. Robots are
actuated and can typically reset themselves, while environment
resets often require manually moving all objects to their initial
positions. Third, data-augmentation techniques can be added
to the virtual objects that would not be feasible on a fully
real system. Lastly, the simulation provides information about,
e.g., the exact positions of virtual objects or about contacts
that occur, which might not be easily attainable for real
objects. This data can be used to generate labels or rewards
that can aid the training process. While HySR can simplify
practical aspects of the training, the large number of real robot
interactions required for training can still cause problems for
real-world RL.
In this work, we present an approach that can signiï¬cantly
reduce the number of interactions with the real system required
for learning. The key idea behind our method, Hindsight
States (HiS), is to pair the data of a single real instance with
additional data generated by concurrently simulating multiple
distinct instances of the virtual part. In the example of robot
ball games, our method simulates the effect of the robotâ€™s
actions on several virtual balls simultaneously. We relabel the
virtual part of each roll-out with this additional virtual data
in hindsight . Intuitively, the agent experiences what wouldarXiv:2303.02234v2  [cs.RO]  9 Mar 2023 (a) Pushing
 (b) Sliding
 (c) Simulated robot table tennis
 (d) Real robot table
tennis
Fig. 1: Visualization of HiS applied to the tasks considered in this work. Rather than training with a single object, HiS uses
multiple virtual objects in parallel to generate more data and experience higher rewards with increased probability early on in
the training.
have happened if it had encountered a different virtual part
but applied the same actions as in the original episode. This
relabeling process enables the RL agent to generate extra
experience without collecting further transitions on the real
system. The hindsight data can then be used in addition to the
regular training data by any off-policy RL algorithm, such as
Soft Actor-Critic (SAC) [12]. Particularly for tasks with sparse
rewards, the additional data is beneï¬cial since it increases the
probability that the agent experiences positive rewards early in
the training. The contributions of this paper are the following:
1)Extending HySR for sample efï¬cient training
Our main contribution is to devise a sample efï¬cient way to
train in the Hybrid Sim and Real (HySR) setting. To that end,
we formalize the HySR training and, based on it, develop a
novel algorithm, called Hindsight States (HiS).
2)Evaluation of the interplay between HER and HiS
Our experiments demonstrate that the combination of HiS
and HER achieves higher sample efï¬ciency than each method
by itself. We argue that HiS and HER improve task perfor-
mance in distinct and complementary manners.
3)Thorough experimental validation of HiS on a variety of tasks
We show improved performance of HiS on the original HySR
real robot table tennis task. Additionally, we investigate to
what extent HiS can be applied to manipulation tasks and
report more efï¬cient training in these regimes (see Fig. 1
for an overview of all experiments). Another ï¬nding is that
HiS allows for more efï¬cient training in entirely simulated
environments w.r.t. wall-clock time.
II. R ELATED WORK
Our new method, HiS, shares some aspects with and takes
inspiration from other works. In the following section, we
discuss these similarities.
Hindsight Experience Replay (HER) [1] improves sample
efï¬ciency for sparse goal-conditioned RL tasks by relabeling
the goal states of transitions in hindsight. The method replaces
the original goal with a state reached by the agent. Then it
trains an off-policy RL agent on a combination of original and
relabeled data. This way, the agent receives additional positive
feedback for reaching the relabeled goal, which can be moreinstructive than the negative feedback for missing the original
goal. Rauber et al. [31] extend the idea to on-policy algorithms
through the use of importance sampling. Dynamic Hindsight
Experience Replay (DHER) [9] is a version of HER that
supports dynamic goals, which change during the episode. The
method makes the idea of relabeled goals applicable to tasks
like grasping moving objects. While HER samples hindsight
goals uniformly, recent methods prioritize goals based on
how instructive the resulting transitions are for the agent.
These approaches sample hindsight goals that guide the agent
toward the true goal [2, 32, 10] or result in a large temporal
difference (TD) error [22]. Other methods sample hindsight
goals uniformly and prioritize more informative transitions
when sampling from the replay buffer, akin to PER [33].
Zhao and Tresp [40] prioritize trajectories that demonstrate
difï¬cult behavior. They quantify difï¬culty by the increase of
the systemâ€™s energy over the course of the trajectory. Beyene
and Han [3] primarily sample hindsight transitions that incur a
large TD error. Similar to HER and its extensions, our method
also relabels in hindsight. However, it focuses on exchanging
the virtual part of the state rather than the goal.
HiS and sim-to-real techniques utilize simulations to devise
a policy that transfers to reality. Different techniques, such as the virtual part of the state rather than the goal.
HiS and sim-to-real techniques utilize simulations to devise
a policy that transfers to reality. Different techniques, such as
domain randomization [26, 28, 23] and domain adaptation [15,
14, 39] were proposed to mitigate the impact of the reality
gap. HiS, on the other hand, assumes the reality gap to be
sufï¬ciently small for certain components of the environment
and devises a way to be more efï¬cient in the hybrid sim and
real setting. Sim-to-real methods could be used on top of HiS
to close the remaining gap.
Other works have investigated leveraging real and simulated
data of the same task to improve learning performance. For
instance, Kang et al. [16] learn a perception system using
simulated and a reward model based on real data. They use
model predictive control with the learned reward model to
solve quadrotor navigation tasks. Di-Castro et al. [8] combine
cheap but imprecise simulated with expensive real transitions
to learn a policy for the real task. HiS, in contrast, investigates
more efï¬cient training by mixing simulated and real compo-
nents in each transition. Algorithm 1 Hindsight States (HiS)
1:Initialize off-policy RL algorithm A, replay buffer R,
choose criterion c
2:forepisode i=1;2;:::do
3: Sample sv
1:TD recand initialize real system to sr
1
4: fort=1;:::; Tdo
5: Sample action atfromAgiven st= [sr
t;sv
t]
6: Apply atto the real system and observe sr
t+1
7: sv
t+1sim([sr
t;sv
t];at)or take sv
t+1from sv
1:T
8: end for
9: fort=1;:::; Tdo .standard replay
10: Store ([sr
t;sv
t];at;r([sr
t;sv
t];at);[sr
t+1;sv
t+1]) inR
11: end for
12: Initialize temporary buffer Rtemp .HiS replay
13: forj=1;2;:::do
14: Sample svm
1:TD rec
15: fort=1;:::; Tdo
16: svm
t+1sim([sr
t;svmt];at)or take svm
t+1from svm
1:T
17: em
t= ([sr
t;svmt];at;r([sr
t;svmt];at);[sr
t+1;svm
t+1])
18: Store relabeled transition em
tinRtemp
19: end for
20: end for
21: Every few episodes:
Add transitions from Rtemp toRusing criterion c
22: Every few steps:
Perform optimization on Awith replay buffer R
23:end for
Utilizing ofï¬‚ine RL [19, 20] can also alleviate some of the
problems related to training on real systems by making use
of existing datasets. The central issue of ofï¬‚ine RL is the
distribution shift between the behavior policy, which collected
the dataset, and the trained policy [20]. Recent works constrain
the trained policy to be similar to the behavior policy [36, 34,
17], modify the objective of the Q-function to be conservative
with respect to samples not in the dataset [18, 38], or penalize
uncertainty in rollouts of learned models [37, 29].
III. M ETHOD
The core components of HiS comprise the generation of
parallel virtual trajectories, as well as the criteria to select
among the additional transitions generated with HiS. This
section introduces each of these components, as well as the
HySR setup that HiS builds upon.
A. RL Preliminaries
We consider tasks formulated as a discounted Markov deci-
sion process, which is deï¬ned by the tuple M= (S;A;P;g;r),
whereSdenotes the state space and Athe action space.
The transition dynamics P(st+1jst;at)represent the probability
of reaching state st+12S after executing action at2A in
state st2S. Furthermore, the agent receives a scalar reward
rt=r(st;at)at each time step. The goal of RL is to ï¬nd anoptimal policy p?, which maximizes the discounted total return
R=Ep""
T
Ã¥
tgtrt#
; (1)
where Tis the time horizon and g2[0;1)is the discount
factor. The agent collects transitions et= (st;at;rt;st+1)by
interacting with the environment and uses them to iteratively
update its policy p. Many popular off-policy RL algorithms,
such as SAC [12] or Deep Q-Networks (DQN) [24], store these
transitions in a buffer D[21] and replay them when updating,
for instance, the action value function Q(st;at). This replay
buffer is ï¬xed-sized and contains the most recent transitions.
A ring buffer, which replaces the oldest with the most recent
transition, is a popular implementation. The Q-function update
involves minimizing a variant of the TD error
d(s;a;r;s0) =r+gmax
a02AQ(s0;a0)"," This paper presents Hindsight States (HiS), an off-policy reinforcement learning algorithm that combines Hindsight Experience Replay (HER) and HiS to achieve higher sample efficiency than either method alone. HiS is evaluated on a variety of tasks in simulation and on a real-world muscular robot task, showing improved sample efficiency and asymptotic performance. Results show that HiS can be beneficial for purely simulated tasks, and combining HER and HiS leads to even better performance than applying each method individually."
32," ChatGPT and Other Large Language Models as Evolutionary
Engines for Online Interactive Collaborative Game Design
Pier Luca Lanzi
pierluca.lanzi@polimi.it
Politecnico di Milano
Milano, ItalyDaniele Loiacono
daniele.loiacono@polimi.it
Politecnico di Milano
Milano, Italy
ABSTRACT
Large language models (LLMs) have taken the scientific world by
storm, changing the landscape of natural language processing and
human-computer interaction. These powerful tools can answer
complex questions and, surprisingly, perform challenging creative
tasks (e.g., generate code and applications to solve problems, write
stories, pieces of music, etc.). In this paper, we present a collabo-
rative design framework that combines interactive evolution and
large language models to simulate the typical human design pro-
cess. We use the former to exploit usersâ€™ feedback for selecting
the most promising ideas and large language models for a very
complex creative taskâ€”the recombination and variation of ideas. In
our framework, the process starts with a brief and a set of candidate
designs, either generated using a language model or proposed by
the users. Next, users collaborate on the design process by pro-
viding feedback to an interactive genetic algorithm that selects,
recombines, and mutates the most promising designs. We evaluated
our framework on three game design tasks with human designers
who collaborated remotely.
CCS CONCEPTS
â€¢Computing methodologies â†’Genetic algorithms ;â€¢The-
ory of computation â†’Interactive computation ;â€¢Human-
centered computing â†’Systems and tools for interaction de-
sign .
KEYWORDS
Collaborative Design, Large Language Models, Interactive Evolu-
tion
1 INTRODUCTION
Design is a collaborative problem-solving activity that begins with
a design brief providing an approximate description of a target
objective. In the opening (divergent) phase, several initial ideas of
possible solutions are proposed. These are the seeds for the next
exploration (emergent) phase in which ideas are modified and com-
bined to create new solutions over a series of iterations. Finally,
in the closing (convergent) phase, developed ideas are critically
examined, assessed, and the process result is synthesized [ 15,37].
Interactive evolution [ 47] can model collaborative design processes
effectively, and it has been widely applied to design and creative ac-
tivities like fashion [ 24,25,34,46], music composition [ 3,18,19,54],
video games [ 17,43] and art in general [ 26,27]. However, its applica-
tion has been limited to domains where admissible design solutions
could be encoded, randomly generated, mutated, and recombined.
For example, it has never been applied to evolve free-form texts thatwould need advanced operators to maintain semantic coherence in
generating the results.
Large Language Models (LLMs) have changed the landscape
of natural language processing and human-computer interaction.
These powerful tools can answer complex questions and perform
challenging creative tasks such as writing screenplays and theater
scripts [ 32], solving complex math problems [ 9], theorem proofing
[41], generating code to solve specific tasks [ 8], generate descrip-
tions from images [ 7], etc. More interestingly, they can also generate
random texts from high-level instructions, combine two or more
texts, and create variations of existing textsâ€”all while maintaining
semantic coherence in the generated texts. These functionalities can
easily map to the genetic operators at the core of most evolution-
ary algorithms. Thus, we can use LLMs to implement evolutionary
operators that can manage free-form text individuals while also
maintaining semantic coherenceâ€”something that would be difficult,
if not impossible, to achieve with traditional representations.
In this paper, we present an online collaborative design frame-
work that combines interactive evolution with large language mod-
els for evolving game design ideas ( game concepts ) represented In this paper, we present an online collaborative design frame-
work that combines interactive evolution with large language mod-
els for evolving game design ideas ( game concepts ) represented
as free-form texts. The online interactive evolutionary algorithm
shows the ideas to the human designers and collects their feedback;
the large language model implements all the operators for the ran-
dom generation, the recombination (crossover), and the variation
(mutation) of ideas. Our framework is very general in that it can
support any design process based on textual information (and could
be easily extended to integrate visuals integrating tools like Dall-E
2 [39]); it can use any viable LLM and therefore, it is intrinsically
multilingual; it can be accessed using any medium that can visualize
texts like a webpage [ 5,6], a 2D-grid displayed on screen [ 1,53],
or any viable messaging platform that supports user polls or other
ways to collect usersâ€™ feedback.
We performed a preliminary evaluation of our framework on
three creative tasks, the design of a board game, the design of a
video game, and the generation of game ideas during the 2023
Global Game Jam. The evaluation involved around 80 users (junior
and senior game designers). The goal of the two game design tasks
was to simulate a typical idea-generation process; accordingly, we
set a fixed time limit of four working days for each task. The in-
teractive evolutionary algorithm communicated with the human
designers using the Telegram messaging platform [ 31] while the
genetic operators were implemented using ChatGPT [ 38]. Each
task was initiated with a design brief [ 15] that was sent to the de-
signers as the first message on a Telegram group. The brief was
followed by a series of initial design ideas (some randomly gener-
ated using the LLM, some collected from existing designs) â€” the
opening (divergent) phase [ 15]. Then, over the next four days, usersarXiv:2303.02155v1  [cs.AI]  9 Feb 2023 Pier Luca Lanzi and Daniele Loiacono
evaluated the design ideas they received using the Telegram poll
system; the evolutionary algorithm employed the usersâ€™ feedback
to select, recombine and mutate the existing ideas into new ones
presented next. Instead, the evaluation performed during the 2023
Global Game Jam was conceived as an open-ended brainstorming
activity that lasted less than 24 hours to fit the tight schedule of
the event.
There are few examples of applications of LLMs to idea gen-
eration and creativity in games. For example, Zhu and Luo [ 56]
explored a generative approach for design ideation combining a lan-
guage model and a knowledge based of existing patents to generate
new ideas. van Stegeren and Myundefinedliwiec [48] investigated
the application of GPT-2 for generating dialogues in role-playing
games for non-player characters while VÃ¤rtinen et al. [ 50] applied
GPT-2 [ 42] and GPT-3 [ 4] to generate description of quests in the
same type of games. Frans [ 12] presented a framework for building
Language Model Games whose main mechanic involved players
manipulating a language model into behaving in a desired manner
with a demo game called AI Charades. However, to the best of our
knowledge, our framework is the first example of interactive evolu-
tionary algorithm that apply large language models to implement
genetic operator and combines them with interactive evolution to
mimic a full-fledged design session from start to end.
2 RELATED WORK
Interactive evolution [ 47] dates back to Richard Dawkinsâ€™s The Blind
Watchmaker andBiomorphs [10]. Over the years, this approach has
been applied to several creative tasks, for which human evaluation
might provide a better (if not the only) alternative to the definition
of an objective (or fitness) function to evaluate candidate solution,
such as fashion [ 24,25,34,46], ergonomics [ 2,51], yacht design [ 23],
visual effects [ 11,21], synthetic images [ 45], music [ 3,18,19,54],
video games [17, 43] and art in general [26, 27].
Interactive evolutionary frameworks collect human evaluations
either implicitly or explicitly. In the former case, the systems track
human actions, sometimes building a model of usersâ€™ behavior and
deriving an assessment of their preferences [ 20,55]. Galactic Arms
Race (GAR) [ 17] is an example of implicit evaluation. It was the first
video game using interactive evolution for content generation; it
included a weapon system that automatically evolved new weapons
based on playersâ€™ behavior. Petalz [ 43] was a Facebook game about
growing a garden of procedurally generated flowers; players would
select what flowers they liked most and wanted to breed; human
evaluation used by the interactive evolutionary algorithm was im-
plicitly implemented within the farming mechanics.
Most often, interactive evolutionary frameworks involve an
explicit human-based evaluation of candidates and, similarly to
Dawkinsâ€™ Biomorphs [10], have a grid-like interface that allows
users to evaluate candidate designs iteratively. Hoover et al. [ 18,19]
integrated interactive evolution with functional scaffolding for gen-
erating drum tracks [ 18] and accompaniments for existing musical
pieces [ 19] using a compositional pattern-producing network. At
first, users select a musical piece (in MIDI format) and which parts
should be elaborated by the evolutionary algorithm (e.g., the pi-
ano, guitar, or bass guitar). Next, users customize and refine thecomputer-generated accompaniment through an interactive selec-
tion and mutation of compositional networks. Noticeably, the user
interface in [ 19] is similar to other music composition tools instead
of the grid-based structure used in most frameworks. Cardamone
et al. [ 5,6] developed a tool that combined an interactive genetic
algorithm with procedural content generation to evolve tracks for
two open-source racing games. The tool had a web frontend that
remained active for several years and currently appears to be dis- algorithm with procedural content generation to evolve tracks for
two open-source racing games. The tool had a web frontend that
remained active for several years and currently appears to be dis-
continued, although still online. Ã˜lsted et al. [ 57] developed a tool
for the interactive evolution of first-person-shooter maps inspired
by the popular multiplayer game Counter-Strike. While the tool of
[5,6] is external to the actual racing games, the tool of Ã˜lsted et al.
[57] is integrated within the game (FPSEvolver) and operated live,
collecting playersâ€™ feedback during the usual map voting and selec-
tion processâ€”a typical phase in multiplayer first-person-shooter
games. Pirovano et al. [ 40] developed a tool for creating 3D sword
models that combined procedural content generation, interactive
evolution, and a grid-based interface to let users explore such a pe-
culiar design space. Generative Adversarial Networks (GANs) [ 14]
represented a milestone in procedural content generation and have
been applied to various creative tasks. They learn the probability
distribution that generates a collection of training examples and
can generate more samples from randomly generated input vectors
of Gaussian noise, which form the latent space. Several authors
developed methods to explore the latent space to guide the gener-
ation of examples [ 13,49], including interactive evolution [ 1,44].
Bontrager et al. [ 1] combined generative adversarial networks for
image generation with interactive evolution to explore the latent
space to improve the quality of sampled images for specific targets.
Schrum et al. [ 44] applied interactive evolution for exploring the
latent space for generating levels for the video games Super Mario
Bros. andThe Legend of Zelda . Both [ 1] and [ 44] require an explicit
human-based evaluation using a grid-like interface similar to the
ones used in [5, 6, 10, 40].
Most approaches ask users to select the designs they like best
[1,44]; however, some authors proposed ways to improve the usersâ€™
agency over the process [ 30,53]. Wooley et al. [ 53] combine in-
teractive human evaluation with novelty search to facilitate the
serendipitous discovery of designs by allowing the users to seed the
forthcoming generation with novel descendants. Liapis et al. [ 30]
ask the users to rank the individuals instead of evaluating the single
individuals; this provides more information about the usersâ€™ pref-
erences to the underlying evolutionary engine and appears to be
faster and more robust than preference-based evaluation. Mitchel et
al. [33] introduced an interactive evolutionary framework (PETRI)
with an interface based on physical tangibles elements. Each tangi-
ble represented a design in the population, and users could interact
with them using specific gestures. The goal was to enhance the
user experience while alleviating fatigue. Mitchel at al. [ 33] applied
PETRI to reproduce the evolution of biomorph images [10] and to
develop an application to explore quantum phenomena through
movement and dance. Later, Ivanov et al. [ 22] developed EvoIsland,
a framework that maintained localized populations of designs and
let users manipulate the subpopulations using a touch interface.
EvoIsland structure is inspired by spatial isolation of land masses
on Earth and resembles several similarities to the island models in
parallel genetic algorithms [16]. ChatGPT and Other Large Language Models as Evolutionary Engines for Online Interactive Collaborative Game Design
Figure 1: The framework architecture when collaboration is
based on the Telegram messaging platform.
3 THE FRAMEWORK ARCHITECTURE
Our framework combines interactive evolution and large language
models to simulate the typical human design process. It comprises
three components: (i) the online database of designs; (ii) the evolu-
tionary algorithm; and (iii) the agent responsible for publishing the
designs and collecting usersâ€™ feedback. Figure 1 shows the structure
of our framework; in this case, the interaction with the human
designers uses the Telegram messaging system, which is the one
we employed in the experiments discussed in this study.
The database contains (i) a list of design ideas that have been pub-
lished and are currently under evaluation; (ii) the list of submitted
evaluations that are used to compute the fitness; (iii) the current
population of active design ideas; this includes both the designs
that been already published and under evaluation by the users and
the ones that have been already generated but not published yet.
The evolutionary engine is implemented as a steady-state ge-
netic algorithm that, at each iteration, (i) selects promising design
ideas from the current population; (ii) applies recombination and
mutation (implemented using a large language model like CharGPT
or another LLM like DaVinci GPT-3 [ 4]); (iii) inserts the newly gen-
erated individuals in the population; finally, (iv) deletes individuals
to keep the population size constant.
The interaction agent manages the communication between the
framework and the publishing server; it publishes the design con-
cepts in the population and collects the usersâ€™ feedback. In Figure 1,
we show the architecture used in the experiments discussed in this
paper with an interaction agent implemented as a Telegram bot
that publishes the design concepts on a Telegram group through
the Telegram servers. However, our framework also supports pub-
lishing using web servers (as done in [6, 45]).Note that, when using a publishing-subscribe platform like Tele-
gram, the publication of design concepts is timed to limit the num-
ber of concepts (and message notifications) the users receive at
any given time (see Section 5). Accordingly, we maintain two sepa-
rate tables, one for the population of active designs (Figure 1) and
one for the published designs currently being evaluated. In con-
trast, when interacting through a web server, the agent will publish
the population all at once; users will autonomously decide how
many concepts they want to view and evaluate using the online
navigation interface (similarly to [6, 45]).
User Evaluation. Most of the interactive evolutionary algorithms
we examined (Section 2) ask for qualitative evaluations based, for
example, on basic voting systems [ 44,57], scales with a limited
number of values [ 5,6], or let users actively select what individual
should go to the next generation [ 1,53]. In our framework, we
adopted a simple three-value scale (positive, neutral, and negative)
that let users express how they felt about a given design idea. Note
that, the evaluation is anonymous and users cannot see how other
people evaluated an idea before they submitted their evaluation.
When using the Telegram poll-based interface, only the summary
statistics about the submitted evaluations will appear on the group
chat; when using the web-based interface, users can see only their
evaluation.
3.1 The Workflow
The process starts with a short design brief , describing the activity
goals [ 52]. The evolutionary algorithm uses the brief to gener-
ate the initial population either (i) by asking ChatGPT or another
language model to generate random solutions (similarly to the tra-
ditional population initialization in evolutionary algorithms); (ii) by
introducing human-designed concepts originating from the brief ditional population initialization in evolutionary algorithms); (ii) by
introducing human-designed concepts originating from the brief
(e.g., by asking participants to propose solutions or taking existing
well-known solutions); or (iii) by combining the previous options
(similarly to the half and half initialization in Genetic Program-
ming [ 28]). The individuals in the initial population are published
either at once (when collaboration is web-based) or timely (when
using a publishing-subscribe platform like Telegram). Next, the
framework waits for feedback from the users, who can score each
published concept. When sufficient evaluations have been submit-
ted for all the published concepts, the evolutionary algorithm starts
its select-recombine-mutate cycle: it selects two individuals from
the population using tournament selection of size two; with a given
probability, it applies recombination to generate one offspring that
is then mutated; finally, the offspring is added to the population
while the worst individual is deleted to keep the population size
constant. The new individual becomes eligible for publication; de-
pending on the platform used, the individual is published immedi-
ately or in a given time frame. The next iteration of the evolutionary
algorithm will start when a sufficient number of evaluations have
been submitted for the newly published individuals.
4 IMPLEMENTING GENETIC OPERATORS
WITH LARGE LANGUAGE MODELS
LLMs are queried using questions (i.e., prompts ) expressed in nat-
ural language. The quality of their answers heavily relies on how
well the prompts can specify the objective for the target LLM. In Pier Luca Lanzi and Daniele Loiacono
our framework, individuals represent game design ideas expressed
as free-form text; all the operators manipulating them are imple-
mented by querying an LLM. Accordingly, we initially studied how
to design prompts so that the LLM answers could mimic the behav-
ior of the three operators we needed to implement the evolutionary
algorithm: random initialization of individuals, recombination or
crossover, and variation or mutation.
4.1 Random Initialization of Individual
In our framework, the population can be initialized (i) with random
individuals, (ii) with existing designs, or (iii) with a combination of
the previous approaches. Random individuals (game ideas) ignite
the design process and need to provide an approximate indication
of the target objective. In our initial analysis of feasible prompts to
implement evolutionary operators we noted that it is convenient to
ask the system to structure the answer. Accordingly, the prompts
used to generate the initial random game ideas consist of (i) a design
brief defining the objective and its constraints in an organized
structure; and (ii) a request to act as a game designer and generate
a novel design based on the brief. Table 1a shows a prompt to
generate a random idea for a generic board game. The bold text
shows the actual request while the remaining part specifies how the
answer should be structured. Note that, the prompt also specifies the
length of each section to avoid very long game ideas that could be
more difficult to evaluate by the designers. When the request is less
generic, the prompt begins with a text that serves as inspiration
or as an example of the objective. Table 1b shows a prompt to
generate a video game that uses a minimal amount of resources.
This example is inspired to the study of minimalism in video game
design [ 29,35,36]. The first sentence of the prompt is a statement
that serves as an inspiration and sets the basis of what is going to
be asked. The second sentence (in bold) shows the actual request
(as in the previous case). The remaining text specifies the answer
structure. Table 1c shows an example of prompt that was used to
generate random individuals for an experiment run during the 2023
Global Game Jam1in which the goal was to create a game based on
the theme roots . Also in this case, the first sentence was used as a sort
of inspiration. However, since there could be many interpretations
ofroots (it could refer to cultural heritage, botanic, etc.), the sentence
contained the marker âŸ¨ğ¼ğ‘ğ‘‡ğ¸ğ‘…ğ‘ƒğ‘…ğ¸ğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘ âŸ©which was replaced
with sentences suggesting different interpretations (Table 1d). The
process generated a great variety of prompts for the same theme.
4.2 Recombination (Crossover)
The prompt to implement the recombination of two individuals
has a general structure (Table 1e). It starts with the same brief used
to generate random individuals. For example, when recombining
two video games using minimal resources, the marker âŸ¨ğµğ‘…ğ¼ğ¸ğ¹âŸ©
would be replaced with the sentence â€œA white pixel is the minimum
amount [...]â€ from Table 1b. The brief is followed by two examples
of games in which the markers âŸ¨ğ¼ğ‘ğ·ğ¼ğ‘‰ğ¼ğ·ğ‘ˆğ´ğ¿âŸ©are replaced with
the text description of the two parents selected for recombination.
Next, the actual request (highlighted in bold) and two sentences
specifying a series of constraints to avoid answers that are blunt
rephrasing of the parents. Note that, the recombination prompt
1https://globalgamejam.orggenerates one single offspring and to generate a second offspring
(as in traditional crossover) another prompt using two different
parents should be used. We tried several prompts to generate two
offspring at once but we noted that such approach would lead with
very similar offspring so we opted for a recombination prompt that
would generate only one offspring.
4.3 Variation (Mutation)
The prompt for variation also starts with the brief used to generate
random individuals (marker âŸ¨ğµğ‘…ğ¼ğ¸ğ¹âŸ©in Table 1f) followed by (i) would generate only one offspring.
4.3 Variation (Mutation)
The prompt for variation also starts with the brief used to generate
random individuals (marker âŸ¨ğµğ‘…ğ¼ğ¸ğ¹âŸ©in Table 1f) followed by (i)
an existing game idea to be mutated (marker âŸ¨ğ¼ğ‘ğ·ğ¼ğ‘‰ğ¼ğ·ğ‘ˆğ´ğ¿âŸ©), (ii)
the request to the LLM (highlighted in bold) specifying the focus of
the mutation (marker âŸ¨ğ‘€ğ‘ˆğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘âŸ©), and (iv) two sentences spec-
ifying a series of constraints to avoid answers that would be simple
rephrasing of the parent. Marker âŸ¨ğ‘€ğ‘ˆğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘âŸ©specifies the focus
of the mutation and it is randomly replaced with a gameplay aspects
such as, the goal of the game ,the gameâ€™s resources ,the level design ,
the playerâ€™s input , etc. We experimented with mutation operators
that would work at a lower level of detail (e.g., by substituting some
keywords of the game idea with synonyms or antonyms gener-
ated using word embeddings); however, the approach proved less
effective as it did not introduce enough variation.
5 EXPERIMENTAL EVALUATION
We performed a preliminary evaluation of our framework with
human subjects (junior and senior game designers) on three de-
sign tasks. One focused on designing a video game with the least
amount of resources possible while having interesting mechanicsâ€”
a minimalistic video game [ 29,35,36]. One concerned the creation
of a generic board game using only one board of any layout and
a set of pieces. Finally, we evaluated our framework with people
participating in the 2023 Global Game Jam as a tool for the initial
brainstorming phase of the jam. All the experiments were run using
the Telegram-based version of our framework (Figure 1).
5.1 Board Game and Minimalistic Video Game
Design
These two experiments were aimed at simulating the typical idea-
generation process in a controlled environment (e.g., a design stu-
dio) that usually is well-structured [ 15], has clear goals, and has a
fixed duration. We set up two Telegram groups, one for each task.
We sent a call for volunteers to game design Facebook groups and
mailing lists with the link to join each Telegram group; around
44 people participated in the two experiments; most people sub-
scribed to both groups. Participants could join using their identity
or a nickname. Several volunteers are employed in the game in-
dustry and told us they would not be able to provide continuous
feedback over the day. Accordingly, we decided to schedule the
publication of design ideas during three periods, morning, noon,
and late afternoon. The experiments began with a brief that we
posted on each Telegram group with information about the timing
of the postings so that people could plan their participation. The
experiments lasted four days, Tuesday to Friday; we allowed a grace
period of few hours, until Saturday morning, to let participants sub-
mit their final evaluations. We wanted to focus the design process
and limit the number of ideas that the participants had to evaluate ChatGPT and Other Large Language Models as Evolutionary Engines for Online Interactive Collaborative Game Design
Act as a board game designer and create a unique board game with the following restrictions: the game can involve only a board (of any layot) and a set
of pieces (of any number, and type). Organize your response as follows: 1) Name of the Game; 2) Number of players and cooperative/competitive game; 3) Game
Board: describe the layout of the game board, the number and shape of its tiles (max 200 characters); 4) Game Pieces: describe the number of pieces, their type, and
their distribution among players (max 300 characters); 5) Rules: provide a detailed explanation of how the game is played, including how to move pieces and take
turns (max 800 characters); 6) Objective: provide a clear description of the win and lose conditions of the game (max 200 characters). Keep the game description as
simple as possible, without including visual details, theme and story.
(a)
A white pixel is the minimum amount of information we can show on-screen, and pressing a key (or a button) is the least interaction we can ask players. Act as
a game designer and design a minimalist game. Organize your response as follows: 1) the name of the game; 2) game concept: describe the idea, the core
mechanics, the goal of the game, and player controls (max 1000 chars); 3) game resources: describe the graphical elements involved by the game, which type of
player input is required, and any additional resources required by the game (e.g., sound); 4) level design: describe how to do the level design for this game (max 300
chars); 5) game instructions: provide the game instructions for the player (max 300 chars). Do not add additional information.
(b)
Act as a game designer and describe (max 1000 chars), a concept for a video game about the theme ""roots:âŸ¨ğ¼ğ‘ğ‘‡ğ¸ğ‘…ğ‘ƒğ‘…ğ¸ğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘ âŸ©"". Both the game
mechanics and the interaction of the players with the game should involve elements directly connected to the theme of the game.
Organize your response as follows: 1) name of the game; 2) game concept: describe the idea, the core mechanics, the goal of the game, and player controls (max
800 chars); 3) level design: describe how to do the level design for this game (max 400 chars); 4) game instructions: provide the game instructions for the player
(max 300 chars). Do not add additional information.
(c)
â€¢""the part of a plant that is below the ground and that absorbs water and minerals from the soil""
â€¢""the part of a tooth within the socket""
â€¢""one or more progenitors of a group of descendants""
â€¢""the essential core""
â€¢...
(d)
âŸ¨ğµğ‘…ğ¼ğ¸ğ¹âŸ©. Given these two examples of minimalist game.
EXAMPLE1:âŸ¨ğ¼ğ‘ğ·ğ¼ğ‘‰ğ¼ğ·ğ‘ˆğ´ğ¿âŸ©
EXAMPLE2:âŸ¨ğ¼ğ‘ğ·ğ¼ğ‘‰ğ¼ğ·ğ‘ˆğ´ğ¿âŸ©
Act as a game designer and recombine these two games to create a novel game. In your response do not include any introduction or final comment. In the
response, please avoid references to the two games recombined.
(e)
âŸ¨ğµğ‘…ğ¼ğ¸ğ¹âŸ©. Given the following example of minimalist game.
EXAMPLE:âŸ¨ğ¼ğ‘ğ·ğ¼ğ‘‰ğ¼ğ·ğ‘ˆğ´ğ¿âŸ©
Act as a game designer and design a novel game as a variation of the given example, by changing only âŸ¨ğ‘€ğ‘ˆğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘âŸ©. In your response do not
include any introduction or final comment. In the response, please avoid explicit reference to the original game.
(f)
Table 1: Example of prompts for generating (a) a generic board game; (b) a minimalistic video game; (c) a game based on the
theme roots in which the marker âŸ¨ğ¼ğ‘ğ‘‡ğ¸ğ‘…ğ‘ƒğ‘…ğ¸ğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘ âŸ©can be replaced with sentences suggesting different theme interpre-
tation, like the ones listed in (d). Prompts to implement (e) recombination (crossover) and (f) variation (mutation); âŸ¨ğµğ‘…ğ¼ğ¸ğ¹âŸ©
identify the brief used to generate the random individuals, âŸ¨ğ¼ğ‘ğ·ğ¼ğ‘‰ğ¼ğ·ğ‘ˆğ´ğ¿âŸ©an individual selected from the population, and
âŸ¨ğ‘€ğ‘ˆğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘âŸ©a high-level characteristic of gameplay.
initially (Section 3). Accordingly, we chose a small population size
(10 individuals); selection, recombination, and variation were im- âŸ¨ğ‘€ğ‘ˆğ‘‡ğ´ğ‘‡ğ¼ğ‘‚ğ‘âŸ©a high-level characteristic of gameplay.
initially (Section 3). Accordingly, we chose a small population size
(10 individuals); selection, recombination, and variation were im-
plemented using ChatGPT [38]; they were triggered as soon as 25
new evaluations were submitted; selection was implemented usinga tournament selection of size 2; recombination probability was set
to 0.7; variation was always applied.
Over the four days, the evolutionary algorithm performed 30
iterations and a total of 40 game ideas were evaluated for each task; Pier Luca Lanzi and Daniele Loiacono
Figure 2: Number of evaluations submitted during the exper-
iments.
Figure 3: Average length of the game concepts in the pop-
ulation computed as the moving average over the last five
activation of the evolutionary algorithm.
board game ideas received a total of 799 evaluations; video game
ideas received 1025 evaluations overall. Figure 2 shows the number
of evaluations submitted over the four and half days. The plots
follow the schedule with peaks around the publication slots and no
evaluations during the night time. Figure 3 shows the average length
of the concepts in the population computed as the moving average
over the last 5 activation of the evolutionary algorithm. As can be
noted, board game concepts tend to be longer on average (Figure 3)
and therefore require more effort to evaluate; as a consequence,
the board game concepts received less evaluations than the ones of
minimalistic video games as Figure 2 shows.
Figure 4 compares the word cloud generated using all the board
game ideas in the original population (4a) with the one generated
from the final population (4b). The clouds share some general terms
(e.g., moves, starts), but the game concepts in the final population
(a)
(b)
Figure 4: Word cloud for (a) the initial population and (b) the
final population of the board game design task.
focus on completely different concepts like the terms related to
ecosystem maintenance (e.g., island, conservation, resources). Fig-
ure 5 and Figure 6 show the word clouds generated during the
process for the board game and the video game respectively. At the
end, we asked participants to complete a form asking them which
game idea they liked most and why they liked it. Many games in
the final population shared similar elements and mechanics; thus,
while participant did not preferred a single game over the 40 ones
evaluated, there was a common preference over one specific me-
chanic for each task. In particular, in the board game design task,
most participants liked a cooperative mechanic that asked players
to maintain the equilibrium of an ecosystem by placing tiles on a
board. Interestingly, no component of this mechanic was present in
the initial population but the mechanic emerged later in the experi-
ment in games with different narratives (e.g., one set in an island
environment, one in an urban environment). In the video game task,
most participants liked a game mechanic involving reflection in its
different interpretations (e.g., reflection of light in some games,
reflection of bouncing bullets in other ones). In this case, the initial
population contained one game description using reflection of bul-
lets however the light reflection mechanics appeared much later
in the population. Table 2 shows examples of a board game and a
video game from the final population.
5.2 2023 Global Game Jam
We performed a final experiment during the 2023 Global Game
Jam that ran February 3-5, 2023, from Friday afternoon to Sunday ChatGPT and Other Large Language Models as Evolutionary Engines for Online Interactive Collaborative Game Design
evening. The event always starts at 5 pm on Friday with the publi-
cation of the theme (this year was roots ) and ends Sunday evening
with the presentation of the games. The jam is a global event run
with a local timing in that it starts at 5 pm and ends Sunday around
6 pm in every time zone ; jam sites in the Asia continent are the
first to start, those in the Hawaiian time zone are the last ones. We
contacted organizers of the Global Game Jam sites in our country,
sent them a link to a dedicated Telegram group, and asked them to
advertise the toolâ€™s availability to the participants of their jam sites;
around 35 people joined the group, most of them anonymously. In
the previous experiments, at the beginning, participants received
a brief with a list of constraints and were instructed to cooperate
toward a common objective. In contrast, in this case, participants
had a theme ( roots ) that could lead to several different interpreta-
tions; they did not have constraints and did not have to collaborate
but they brainstormed for ideas to develop their own game. In ad-
dition, the time window was more limited since the game must be
implemented by Sunday afternoon, so teams need to come up with
a game idea by Saturday around noon or early afternoon at the
latest. When the theme was revealed on February 3 at 5 pm, we
published the first ten game ideas randomly generated using the
procedure discussed in Section 4; the framework remained online
until Saturday night. The evolutionary operators were implemented
using DaVinci GPT-3 [ 4]; the selection was triggered every 5 new
evaluations; recombination and mutation probabilities were set as
in the previous experiments. The evolutionary algorithm ran for
15 iterations with a number of evaluations much lower than what
was recorded in the previous experiments. This is probably due
to the short span that jammers can dedicate to the brainstorming
process and the in-person nature of the event. Global Game Jam is a
physical jam that encourages meeting, working, and sharing ideas
with new people. Thus, it is no surprise that an online framework
like ours did not fit well in this in-person scenario.
6 CONCLUSIONS
We presented an online collaborative design framework combining
interactive evolution and large language models for helping users
evolve design ideas represented as free-form text. Our framework
can support collaboration through traditional web-based grid in-
terfaces [ 6,45] as well as messaging systems, like Telegram, which
in our opinion might fit free-text content better. We evaluated our
framework in three scenarios involving around 80 participants.
Two scenarios mimicked the typical collaborative design process
with objectives specified at the start and a fixed duration. The third
one was conceived as an open-ended brainstorming activity that
took place during the 2023 Global Game Jam. The first two used an
evolutionary engine based on ChatGPT; the third one employed
DaVinci GPT-3 for the same purpose. All the experiments were run
using the Telegram-based interface of our framework. Overall, we
received positive feedback from the participants. In our experience,
we did not notice any difference between the two large language
models that are, in our opinion, both viable options. We focused
our evaluation on game design since we had access to several ju-
nior and senior game designers employed in the industry. However,
the framework can be applied to any design task which can be de-
scribed in free-text form. And if needed, it could be easily extendedwith text-to-image platforms (like Dall Â·E 2[39] or Midjourney2) to
enrich design ideas with captivating visuals.
REFERENCES
[1]Philip Bontrager, Wending Lin, Julian Togelius, and Sebastian Risi. 2018. Deep
Interactive Evolution. In Computational Intelligence in Music, Sound, Art and REFERENCES
[1]Philip Bontrager, Wending Lin, Julian Togelius, and Sebastian Risi. 2018. Deep
Interactive Evolution. In Computational Intelligence in Music, Sound, Art and
Design - 7th International Conference, EvoMUSART 2018, Parma, Italy, April 4-
6, 2018, Proceedings (Lecture Notes in Computer Science, Vol. 10783) , Antonios
Liapis, Juan JesÃºs Romero Cardalda, and AnikÃ³ EkÃ¡rt (Eds.). Springer, 267â€“282.
https://doi.org/10.1007/978-3-319-77583-8_18
[2]A.M. Brintrup, J. Ramsden, H. Takagi, and A. Tiwari. 2008. Ergonomic Chair
Design by Fusing Qualitative and Quantitative Criteria Using Interactive Genetic
Algorithms. Evolutionary Computation, IEEE Transactions on 12, 3 (June 2008),
343 â€“354. https://doi.org/10.1109/TEVC.2007.904343
[3]Andrew R. Brown, Matthew Horrigan, Arne Eigenfeldt, Toby Gifford, Daniel
Field, and Jon McCormack. 2018. Interacting with Musebots. In 18th International
Conference on New Interfaces for Musical Expression, NIME 2018, Blacksburg, VA,
USA, June 3-6, 2018 . nime.org, 19â€“24. http://www.nime.org/proceedings/2018/
nime2018_paper0004.pdf
[4]Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan,
Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda
Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan,
Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter,
Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin
Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya
Sutskever, and Dario Amodei. 2020. Language Models are Few-Shot Learners.
https://doi.org/10.48550/ARXIV.2005.14165
[5]Luigi Cardamone, Pier Luca Lanzi, and Daniele Loiacono. 2015. TrackGen: An
interactive track generator for TORCS and Speed-Dreams. Appl. Soft Comput. 28
(2015), 550â€“558. https://doi.org/10.1016/j.asoc.2014.11.010
[6]Luigi Cardamone, Daniele Loiacono, and Pier Luca Lanzi. 2011. Interactive
evolution for the procedural generation of tracks in a high-end racing game.
In13th Annual Genetic and Evolutionary Computation Conference, GECCO 2011,
Proceedings, Dublin, Ireland, July 12-16, 2011 , Natalio Krasnogor and Pier Luca
Lanzi (Eds.). ACM, 395â€“402. https://doi.org/10.1145/2001576.2001631
[7]Mark Chen, Alec Radford, Rewon Child, Jeffrey Wu, Heewoo Jun, David Luan,
and Ilya Sutskever. 2020. Generative Pretraining From Pixels. In Proceedings of
the 37th International Conference on Machine Learning, ICML 2020, 13-18 July
2020, Virtual Event (Proceedings of Machine Learning Research, Vol. 119) . PMLR,
1691â€“1703. http://proceedings.mlr.press/v119/chen20s.html
[8]Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira
Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman,
Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish
Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov,
Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe
Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis,
Elizabeth Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex
Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain,
William Saunders, Christopher Hesse, Andrew N. Carr, Jan Leike, Josh Achiam,
Vedant Misra, Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage,
Mira Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam
McCandlish, Ilya Sutskever, and Wojciech Zaremba. 2021. Evaluating Large
Language Models Trained on Code. https://doi.org/10.48550/ARXIV.2107.03374
[9]Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun,
Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano,
Christopher Hesse, and John Schulman. 2021. Training Verifiers to Solve Math
Word Problems. https://doi.org/10.48550/ARXIV.2110.14168
[10] Richard Dawkins. 1986. The Blind Watchmaker: Why the Evidence of Evolution Word Problems. https://doi.org/10.48550/ARXIV.2110.14168
[10] Richard Dawkins. 1986. The Blind Watchmaker: Why the Evidence of Evolution
Reveals a Universe without Design . Norton & Company, Inc.
[11] Marc Ebner, Markus Reinhardt, and JÃ¼rgen Albert. 2005. Evolution of Vertex and
Pixel Shaders. In Genetic Programming, 8th European Conference, EuroGP2005,
Lausanne, Switzerland, March 30 - April 1, 2005, Proceedings (Lecture Notes in
Computer Science, Vol. 3447) , Maarten Keijzer, Andrea Tettamanzi, Pierre Collet,
Jano I. van Hemert, and Marco Tomassini (Eds.). Springer, 261â€“270. https:
//doi.org/10.1007/978-3-540-31989-4_23
[12] Kevin Frans. 2021. AI Charades: Language Models as Interactive Game Environ-
ments. In 2021 IEEE Conference on Games (CoG) . 1â€“2. https://doi.org/10.1109/
CoG52621.2021.9619126
[13] Edoardo Giacomello, Pier Luca Lanzi, and Daniele Loiacono. 2019. Searching the
Latent Space of a Generative Adversarial Network to Generate DOOM Levels.
InIEEE Conference on Games, CoG 2019, London, United Kingdom, August 20-23,
2019. IEEE, 1â€“8. https://doi.org/10.1109/CIG.2019.8848011
[14] Ian J. Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-
Farley, Sherjil Ozair, Aaron C. Courville, and Yoshua Bengio. 2020. Generative
2https://www.midjourney.com Pier Luca Lanzi and Daniele Loiacono
adversarial networks. Commun. ACM 63, 11 (2020), 139â€“144. https://doi.org/10.
1145/3422622
[15] Dave Gray and Sunni Brown. 2010. Gamestorming: A Playbook for Innovators,
Rulebreakers, and Changemakers . Oâ€™Reilly.
[16] Tomohiro Harada and Enrique Alba. 2020. Parallel Genetic Algorithms: A Useful
Survey. ACM Comput. Surv. 53, 4, Article 86 (aug 2020), 39 pages. https://doi.
org/10.1145/3400031
[17] Erin J. Hastings, Ratan K. Guha, , and Kenneth O. Stanley. 2009. Automatic
Content Generation in the Galactic Arms Race Video Game. IEEE Transactions
on Computational Intelligence and AI in Games 4, 1 (2009), 245â€“263.
[18] Amy K. Hoover and Kenneth O. Stanley. 2009. Exploiting functional relationships
in musical composition. Connect. Sci. 21, 2&3 (2009), 227â€“251. https://doi.org/10.
1080/09540090902733871
[19] Amy K. Hoover, Paul A. Szerlip, and Kenneth O. Stanley. 2011. Interactively
evolving harmonies through functional scaffolding. In 13th Annual Genetic and
Evolutionary Computation Conference, GECCO 2011, Proceedings, Dublin, Ireland,
July 12-16, 2011 , Natalio Krasnogor and Pier Luca Lanzi (Eds.). ACM, 387â€“394.
https://doi.org/10.1145/2001576.2001630
[20] Gregory S. Hornby and Josh C. Bongard. 2012. Accelerating human-computer
collaborative search through learning comparative and predictive user models.
InGenetic and Evolutionary Computation Conference, GECCO â€™12, Philadelphia,
PA, USA, July 7-11, 2012 , Terence Soule and Jason H. Moore (Eds.). ACM, 225â€“232.
https://doi.org/10.1145/2330163.2330196
[21] Andrew Howlett, Simon Colton, and Cameron Browne. 2010. Evolving pixel
shaders for the prototype video game Subversion. In Proceedings of the 3rd Inter-
national Symposium on AI and Games - A Symposium at the AISB 2010 Convention
(Proceedings of the 3rd International Symposium on AI and Games - A Symposium
at the AISB 2010 Convention) . 41â€“46. AISB Symposium on AI and Games 2010 ;
Conference date: 29-03-2010 Through 01-04-2010.
[22] Alexander Ivanov, Wesley Willett, and Christian Jacob. 2022. EvoIsland: Inter-
active Evolution via an Island-Inspired Spatial User Interface Framework. In
Proceedings of the Genetic and Evolutionary Computation Conference (Boston,
Massachusetts) (GECCO â€™22) . Association for Computing Machinery, New York,
NY, USA, 1200â€“1208. https://doi.org/10.1145/3512290.3528722
[23] Shahroz Khan, Erkan Gunpinar, and Bekir Sener. 2019. GenYacht: An inter-
active generative design system for computer-aided yacht hull design. Ocean
Engineering 191 (2019), 106462. https://doi.org/10.1016/j.oceaneng.2019.106462
[24] Hee-Su Kim and Sung-Bae Cho. 2000. Application of interactive genetic algorithm
to fashion design. Engineering Applications of Artificial Intelligence 13, 6 (2000),
635 â€“ 644. https://doi.org/DOI:10.1016/S0952-1976(00)00045-2
[25] Hee-Su Kim and Sung-Bae Cho. 2005. Fashion Design Using Interactive Genetic
Algorithm with Knowledge-based Encoding . Springer Berlin Heidelberg, Berlin,
Heidelberg, 411â€“434. https://doi.org/10.1007/978-3-540-44511-1_19
[26] Taras Kowaliw, Alan Dorin, and Jon McCormack. 2012. Promoting Creative
Design in Interactive Evolutionary Computation. IEEE Trans. Evol. Comput. 16, 4
(2012), 523â€“536. https://doi.org/10.1109/TEVC.2011.2166764
[27] Taras Kowaliw, Jon McCormack, and Alan Dorin. 2011. An interactive electronic
art system based on artificial ecosystemics. In 2011 IEEE Symposium on Artificial
Life, ALIFE 2011, Paris, France, April 13-15, 2011 . IEEE, 162â€“169. https://doi.org/
10.1109/ALIFE.2011.5954645
[28] John R. Koza. 1992. Genetic Programming: On the Programming of Computers by
Means of Natural Selection . The MIT Press.
[29] Pier Luca Lanzi, Daniele Loiacono, Alberto Arosio, Dorian Bucur, Davide Caio,
Luca Capecchi, Maria Giulietta Cappelletti, Lorenzo Carnaghi, Marco Giuseppe
Caruso, Valerio Ceraudo, Luca Contato, Luca Cornaggia, Christian Costanza,
Tommaso Grilli, Sumero Lira, Luca Marchetti, Giulia Olivares, Barbara Pagano, Caruso, Valerio Ceraudo, Luca Contato, Luca Cornaggia, Christian Costanza,
Tommaso Grilli, Sumero Lira, Luca Marchetti, Giulia Olivares, Barbara Pagano,
Davide Pons, Michele Pirovano, and Valentina Tosto. 2022. One Pixel, One
Interaction, One Game: An Experiment in Minimalist Game Design. https:
//doi.org/10.48550/ARXIV.2207.03827
[30] Antonios Liapis, HÃ©ctor P. MartÃ­nez, Julian Togelius, and Georgios N. Yannakakis.
2013. Adaptive game level creation through rank-based interactive evolution. In
2013 IEEE Conference on Computational Inteligence in Games (CIG) . 1â€“8. https:
//doi.org/10.1109/CIG.2013.6633651
[31] Telegram FZ LLC and Telegram Messenger Inc. 2023. Telegram. https://telegram.
org
[32] Piotr Mirowski, Kory W. Mathewson, Jaylen Pittman, and Richard Evans. 2022. Co-
Writing Screenplays and Theatre Scripts with Language Models: An Evaluation
by Industry Professionals. https://doi.org/10.48550/ARXIV.2209.14958
[33] Thomas Mitchell, Peter Bennett, Sebastian Madgwick, Edward Davies, and Philip
Tew. 2016. Tangible Interfaces for Interactive Evolutionary Computation. In
Proceedings of the 2016 CHI Conference Extended Abstracts on Human Factors in
Computing Systems (San Jose, California, USA) (CHI EA â€™16) . Association for
Computing Machinery, New York, NY, USA, 2609â€“2616. https://doi.org/10.1145/
2851581.2892405
[34] P.Y. Mok, Jie Xu, X.X. Wang, J.T. Fan, Y.L. Kwok, and John H. Xin. 2013. An IGA-
based design support system for realistic and practical fashion designs. Computer-
Aided Design 45, 11 (2013), 1442â€“1458. https://doi.org/10.1016/j.cad.2013.06.014[35] David Myers. 2009. In search of a minimalist game. In Proceedings of the 2009
DiGRA International Conference: Breaking New Ground: Innovation in Games,
Play, Practice and Theory, DiGRA 2009, London, UK, September 1-4, 2009 , Tanya
Krzywinska, Helen W. Kennedy, and Barry Atkins (Eds.). Digital Games Research
Association. http://www.digra.org/digital-library/publications/in-search-of-a-
minimalist-game/
[36] Andrew Nealen, Adam Saltsman, and Eddy Boxerman. 2011. Towards minimalist
game design. In Foundations of Digital Games, FDGâ€™11, Bordeaux, France, June 28
- July 1, 2011 , Marc Cavazza, Katherine Isbister, and Charles Rich (Eds.). ACM,
38â€“45. https://doi.org/10.1145/2159365.2159371
[37] Don Norman. 2013. The Design Of Everyday Things . Basic Books. Revised edition.
[38] OpenAI. 2021. ChatGPT: a Generative Pre-training Transformer Model for
Conversational AI. https://openai.com/models/gpt-3-citation/.
[39] OpenAI. 2022. DALL Â·E 2. https://openai.com/dall-e-2/. Retrieved 2 February
2023.
[40] Michele Pirovano, Renato Mainetti, and Daniele Loiacono. 2015. Volcano: An
interactive sword generator. In 2015 IEEE Games Entertainment Media Confer-
ence, GEM 2015, Toronto, ON, Canada, October 14-16, 2015 , Elena G. Bertozzi,
Bill Kapralos, Nahum D. Gershon, and Jim R. Parker (Eds.). IEEE, 1â€“8. https:
//doi.org/10.1109/GEM.2015.7377226
[41] Stanislas Polu and Ilya Sutskever. 2020. Generative Language Modeling for
Automated Theorem Proving. https://doi.org/10.48550/ARXIV.2009.03393
[42] Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya
Sutskever. 2019. Language Models are Unsupervised Multitask Learners. (2019).
https://openai.com/blog/better-language-models/
[43] Sebastian Risi, Joel Lehman, David B. Dâ€™Ambrosio, Ryan Hall, and Kenneth O.
Stanley. 2012. Combining Search-Based Procedural Content Generation and So-
cial Gaming in the Petalz Video Game. In AIIDE , Mark Riedl and Gita Sukthankar
(Eds.). The AAAI Press.
[44] Jacob Schrum, Jake Gutierrez, Vanessa Volz, Jialin Liu, Simon Lucas, and Sebastian
Risi. 2020. Interactive Evolution and Exploration within Latent Level-Design
Space of Generative Adversarial Networks. In Proceedings of the 2020 Genetic and
Evolutionary Computation Conference (CancÃºn, Mexico) (GECCO â€™20) . Association
for Computing Machinery, New York, NY, USA, 148â€“156. https://doi.org/10.
1145/3377930.3389821 Evolutionary Computation Conference (CancÃºn, Mexico) (GECCO â€™20) . Association
for Computing Machinery, New York, NY, USA, 148â€“156. https://doi.org/10.
1145/3377930.3389821
[45] Jimmy Secretan and Nicholas Beato. 2008. Picbreeder: evolving pictures collabo-
ratively online. In CHI. 1759â€“1768.
[46] Nazanin Alsadat Tabatabaei Anaraki. 2017. Fashion Design Aid System with
Application of Interactive Genetic Algorithms. In Computational Intelligence in
Music, Sound, Art and Design , JoÃ£o Correia, Vic Ciesielski, and Antonios Liapis
(Eds.). Springer International Publishing, Cham, 289â€“303.
[47] H. Takagi. 2001. Interactive evolutionary computation: fusion of the capabilities
of EC optimization and human evaluation. Proc. IEEE 89, 9 (2001), 1275â€“1296.
https://doi.org/10.1109/5.949485
[48] Judith van Stegeren and Jakub Myundefinedliwiec. 2021. Fine-Tuning GPT-2
on Annotated RPG Quests for NPC Dialogue Generation. In Proceedings of the
16th International Conference on the Foundations of Digital Games (Montreal, QC,
Canada) (FDG â€™21) . Association for Computing Machinery, New York, NY, USA,
Article 2, 8 pages. https://doi.org/10.1145/3472538.3472595
[49] Vanessa Volz, Jacob Schrum, Jialin Liu, Simon M. Lucas, Adam M. Smith, and
Sebastian Risi. 2018. Evolving mario levels in the latent space of a deep con-
volutional generative adversarial network. In Proceedings of the Genetic and
Evolutionary Computation Conference, GECCO 2018, Kyoto, Japan, July 15-19,
2018, HernÃ¡n E. Aguirre and Keiki Takadama (Eds.). ACM, 221â€“228. https:
//doi.org/10.1145/3205455.3205517
[50] Susanna VÃ¤rtinen, Perttu HÃ¤mÃ¤lÃ¤inen, and Christian Guckelsberger. 2022. Gener-
ating Role-Playing Game Quests With GPT Language Models. IEEE Transactions
on Games (2022), 1â€“12. https://doi.org/10.1109/TG.2022.3228480
[51] Tianxiong Wang and Meiyu Zhou. 2020. A method for product form design of
integrating interactive genetic algorithm with the interval hesitation time and
user satisfaction. International Journal of Industrial Ergonomics 76 (2020), 102901.
https://doi.org/10.1016/j.ergon.2019.102901
[52] Wikipedia. 2022. Design Brief (Wikipedia, The Free Encyclopedia). https:
//en.wikipedia.org/wiki/Design_brief
[53] Brian G. Woolley and Kenneth O. Stanley. 2014. A Novel Human-Computer
Collaboration: Combining Novelty Search with Interactive Evolution. In Pro-
ceedings of the 2014 Annual Conference on Genetic and Evolutionary Computation
(Vancouver, BC, Canada) (GECCO â€™14) . Association for Computing Machinery,
New York, NY, USA, 233â€“240. https://doi.org/10.1145/2576768.2598353
[54] Bin Xu, Shangfei Wang, and Xian Li. 2010. An emotional harmony generation
system. In Evolutionary Computation (CEC), 2010 IEEE Congress on . 1 â€“7. https:
//doi.org/10.1109/CEC.2010.5586210
[55] Georgios N. Yannakakis and Julian Togelius. 2011. Experience-Driven Procedural
Content Generation. IEEE Transactions on Affective Computing 2, 3 (2011), 147â€“
161. https://doi.org/10.1109/T-AFFC.2011.6
[56] Qihao Zhu and Jianxi Luo. 2022. Generative Design Ideation: A Natural Language
Generation Approach. https://doi.org/10.48550/ARXIV.2204.09658 ChatGPT and Other Large Language Models as Evolutionary Engines for Online Interactive Collaborative Game Design
[57] Peter Thorup Ã˜lsted, Benjamin Ma, and Sebastian Risi. 2015. Interactive evolution
of levels for a competitive multiplayer FPS. In 2015 IEEE Congress on Evolutionary
Computation (CEC) . 1527â€“1534. https://doi.org/10.1109/CEC.2015.7257069 Pier Luca Lanzi and Daniele Loiacono
Name of the game : Eco-Island
Number of players : 2-4. Cooperative/competitive game: Cooperative.
Game Board : a square board with 64 tiles in an 8x8 grid, representing a tropical island. Each tile has a different terrain, such as a beach, a
rainforest, a volcano, a coral reef and a mangrove. The board also includes a starting point and a research station tile.
Game Pieces : Each player starts with a pawn-shaped game piece, representing their scientist and a set of worker pieces, which are small circles.
The players also have a set of cards representing different research equipment, such as a microscope, a GPS, a sample container and a camera,
and different conservation measures, such as marine protected areas, reforestation and community education.
Rules :
Players take turns moving their game pieces on the board, starting from the starting point and trying to reach the research station tile. Each tile
has its own set of environmental issues, such as habitat destruction, pollution, and overfishing. Landing on a tile can either help or harm the
playerâ€™s research. Players can use their cards to study and mitigate the issues and increase their chances of reaching the research station. Players
can also place their conservation measures on any tile, but they have to abide by certain rules such as: Marine protected areas need to be placed
near coral reefs to protect them; Reforestation needs to be placed in areas with high soil erosion; Community education needs to be placed near
vulnerable communities; Players also have a limited number of workers, they can place on the board to help them implement conservation
measures faster. Players can also form alliances with other players to increase their chances of reaching the research station, but they can also
betray their allies to gain an advantage. Players can also choose to remove their conservation measures to make room for new measures. The
game ends when one player reaches the research station tile or all the tiles on the board are filled with conservation measures.
Objective : The game is won by the player who reaches the research station tile first and has implemented conservation measures that meet
certain criteria for biodiversity and sustainability. The players lose if the island becomes unsustainable or all players run out of cards before
reaching the research station tile.
(a)
Name of the game : Reflectron
Game Concept : The game is a minimalist puzzle platformer where the player controls a character that can reflect both light beams and
projectiles to interact with the environment and solve puzzles. The goal of the game is to reach the end of each level by reflecting both light
beams and projectiles to solve puzzles and overcome obstacles. The core mechanics involve using the arrow keys to move the character, the left
mouse button to reflect incoming projectiles, and the right mouse button to manipulate the angle of reflection of incoming light beams.
Game resources : The game only requires a simple background, a character that can reflect incoming projectiles and light beams, objects that
can be interacted with by reflecting both projectiles and light beams, and obstacles that can be overcome by reflecting both projectiles and light
beams. Player input is required through the use of the arrow keys, left mouse button, and right mouse button.
Level design : The levels are designed by creating obstacles and challenges that require the player to reflect both projectiles and light beams in
different ways to overcome them, adding diversity to the gameplay.
Game instructions : Use the arrow keys to move the character, left mouse button to reflect incoming projectiles, and the right mouse button to
manipulate the angle of reflection of incoming light beams. Reach the end of each level by reflecting both projectiles and light beams to solve
puzzles and overcome obstacles.
(b) manipulate the angle of reflection of incoming light beams. Reach the end of each level by reflecting both projectiles and light beams to solve
puzzles and overcome obstacles.
(b)
Table 2: Example of evolved games for (a) the board game design task and (b) the video game design task. ChatGPT and Other Large Language Models as Evolutionary Engines for Online Interactive Collaborative Game Design
(a) (b)
(c) (d)
(e) (f)
Figure 5: Sequence of word clouds for the board game design task starting from (a) the initial population to the (f) the final
population. Pier Luca Lanzi and Daniele Loiacono
(a) (b)
(c) (d)
(e) (f)
Figure 6: Sequence of word clouds for the video game design task starting from (a) the initial population to the (f) the final
population."," This paper presents a framework combining interactive evolution and large language models to simulate the typical human design process. It was evaluated on three game design tasks with 80 users, and implemented using the Telegram messaging platform and ChatGPT. The experiments received positive feedback from the participants and the framework can be applied to any design task which can be described in free-text form. The paper also references 10 sources related to evolutionary computation and presents a sequence of word clouds for a board game and video game design task."
33," PDSketch: Integrated Planning Domain
Programming and Learning
Jiayuan Mao1TomÃ¡s Lozano-PÃ©rez1Joshua B. Tenenbaum1;2;3Leslie Pack Kaelbling1
1MIT Computer Science & Artiï¬cial Intelligence Laboratory
2MIT Department of Brain and Cognitive Sciences
3Center for Brains, Minds and Machines
Abstract
This paper studies a model learning and online planning approach towards building
ï¬‚exible and general robots. Speciï¬cally, we investigate how to exploit the locality
andsparsity structures in the underlying environmental transition model to improve
model generalization, data-efï¬ciency, and runtime-efï¬ciency. We present a new
domain deï¬nition language, named PDSketch. It allows users to ï¬‚exibly deï¬ne
high-level structures in the transition models, such as object and feature dependen-
cies, in a way similar to how programmers use TensorFlow or PyTorch to specify
kernel sizes and hidden dimensions of a convolutional neural network. The details
of the transition model will be ï¬lled in by trainable neural networks. Based on
the deï¬ned structures and learned parameters, PDSketch automatically generates
domain-independent planning heuristics without additional training. The derived
heuristics accelerate the performance-time planning for novel goals.
1 Introduction
A long-standing goal in AI is to build robotic agents that are ï¬‚exible and general, able to accomplish
a diverse set of tasks in novel and complex environments. Such tasks generally require a robot to
generate long-horizon plans for novel goals in novel situations, by reasoning about many objects
and the ways in which their state-changes depend on one another. A promising solution strategy is
to combine model learning with online planning: the agent forms an internal representation of the
environmentâ€™s states and dynamics by learning from external or actively-collected data, and then
applies planning algorithms to generate actions, given a new situation and goal at performance time.
There are two primary desiderata for a system based on model-learning and planning. First, the
learning process should be data efï¬cient , especially because of the combinatorial complexity of
possible conï¬guration of in the real world. Second, the learned model should be computationally
efï¬cient , making online planning a feasible runtime execution strategy.
A critical strategy for learning models that generalize well from small amounts of data and that
can be deployed efï¬ciently at runtime is to introduce inductive biases. In image processing, we
leverage translation invariance and equivariance by using convolutions. In graph learning, we leverage
permutation invariance by using graph neural networks. Two essential forms of structure we can
leverage in dynamic models of the physical world are locality andsparsity . Consider a robot picking
an object up off a table. At the object level, the operation only changes the states of the object being
picked up and the robot, and only depends on a few other nearby objects, such as the table (local). At
the object feature level, only the conï¬guration of the robot and pose of the object are changed, but
their colors and frictional properties are unaffected (sparse).
Classical hand-engineered approaches to robot task and motion planning have designed represen-
tations that expose and exploit locality through lifting (orobject-centrism ), which allows relational
Correspondence to: jiayuanm@mit.edu. Project page: https://pdsketch.csail.mit.edu.
36th Conference on Neural Information Processing Systems (NeurIPS 2022).arXiv:2303.05501v1  [cs.AI]  9 Mar 2023 (:action move-into:parameters (?o1?o2):effects(and(pose::assign?o1(??f(pose ?o2)))......PDSketch(Structure)ğœƒNeural Modules(Parameters)Data(Offline Demonstration or Online Interaction)ModelGoal(e.g.,paint all blocks yellow)Domain-IndependentPlanner (A*)PrimitivePolicies(pick, place, etc.)Action: move-into(Item#1, Item#5)ModelTraining
Environment(e.g.PyBullet)StateRobotCommandPolicy
TrainingTimePerformanceTimeFigure 1: The life cycle of a PDSketch model. A PDSketch model is composed of a model structure
deï¬nition and a collection of trainable neural modules. The model parameters can be learned from
data. During performance time, the model is used by a domain-independent planner to form a policy
that directly interacts with the environment.
defmove_into(o,c):o.pose=c.pose+[0,0,0.1]ifis_block(o)andis_painter(c):o.color=c.colordefmove_into(o,c):o.prop1=??(c.prop1)if??(o,c):o.prop2=??(c.prop2)(a)Afullspecificationofthetransitionmodel.(b)Astructure-onlyspecification.
Figure 2: Deï¬ning both the transition model structure and
implementation in Python (a) vs. deï¬ning only the structure
while leaving details (the ??functions) to be learned (b).descriptions of objects and abstrac-
tion over them, and through factoring ,
which represents different attributes of
an object in a disentangled way [Gar-
rett et al., 2021]. These representa-
tions are powerful and effective artic-
ulations of locality and sparsity, but
they are traditionally laboriously hand-
designed in a process that is very dif-
ï¬cult to get correct, similar to writing
a full state-transition function as in Fig. 2a. This approach is not directly applicable to problems
involving perception or environmental dynamics that are unknown or difï¬cult to specify. In this
paper, we present PDSketch, a model-speciï¬cation language that integrates human speciï¬cation of
structural sparsity priors and machine learning of continuous and symbolic aspects of the model. Just
as human users may deï¬ne the structure of a convolutional neural network in TensorFlow [Abadi
et al., 2016] or PyTorch [Paszke et al., 2019], PDSketch allows users to specify high-level structures
of the transition model as in Fig. 2b (analogous to setting the kernel sizes), and uses machine learning
to ï¬ll in the details (analogous to learning the convolution kernels).
Fig. 1 depicts the life-cycle of a PDSketch model, PDSketch uses an object-centric, factored, symbolic
language to ï¬‚exibly describe structural inductive biases in planning domains (i.e., the model structure).
A PDSketch model is associated with a collection of neural modules whose parameters can be learned
from robot trajectory data that are either collected ofï¬‚ine by experts or actively-collected by interacting
with the environment. During performance time, a PDSketch is paired with a domain-independent
planner, such as A, and as a whole forms a goal-conditioned policy. The planner receives the
environmental state and the trained PDSketch model, makes plans in an abstract action space, and
invokes primitive policies that actually generate robot joint commands.
Compared to unstructured models, such as a single multi-layer perceptron that models the complete
state transition monolithically, the structures speciï¬ed in PDSketch substantially improve model
generalization and data-efï¬ciency in training. In addition, they enable the computation of powerful
domain-independent planning heuristics : these are estimates of the cost-to-go from each state to a
state satisfying the goal speciï¬cation, which can be obtained from the structured transition model
without any additional learning . They can be leveraged by Ato efï¬ciently plan for unseen goals,
speciï¬ed in a ï¬rst-order logic language.
We experimentally verify the efï¬ciency and effectiveness of PDSketch in two domains: BabyAI, an
2D grid-world environment that focuses on navigation, and Painting Factory, a simulated table-top We experimentally verify the efï¬ciency and effectiveness of PDSketch in two domains: BabyAI, an
2D grid-world environment that focuses on navigation, and Painting Factory, a simulated table-top
robotic environment that paints and moves blocks. Our results suggest that 1) locality and sparsity
structures, speciï¬ed economically in a few lines of code, can signiï¬cantly improve the data efï¬ciency
of model learning; 2) the model learning and planning paradigm enables strong generalization to
unseen goal speciï¬cations. Finally, the domain-independent heuristics automatically induced from the
structures dramatically improve performance-time efï¬ciency, especially for novel goal speciï¬cations.
2 Input ImageSegmentation(a) Raw Observations(b) Object-CentricState (Observation)
Item#1(423.0, 420.0)
Item#2(159.0, 256.5)
Item#3(543.0, 381.5)
Item#6(275.5, 273.5)pose       Item#1color      Item#1wetness    Item#1dirtiness  Item#1pose       Item#6color      Item#6wetness    Item#6dirtiness  Item#6......type       Item#1
type       Item#6pose       Item#1color      Item#1wetness    Item#1dirtiness  Item#1pose       Item#6color      Item#6wetness    Item#6dirtiness  Item#6......type       Item#1
type       Item#6(c) Factored State (Internal)(d) Factored State(Next Timestep)
Item#1(273.0, 273.0)
Item#2(159.0, 256.5)
Item#3(543.0, 381.5)
Item#6(275.5, 273.5)(e) Object-CentricState (Next Observation)Actionmove-into(Item#1, Item#6)
Transition Function ğ’¯!SupervisionEncoder â„°!......(:action move-into:parameters (?o1?o2):effects(and(pose::assign?o1(??f(pose ?o2)))(when(??g(type ?o1)(type ?o2))(wetness::assign ?o1(??h(wetness ?o1)))............Figure 3: A factorized state representation and transition model for the robot painting domain.
The raw observation (a) is ï¬rst processed by an external perception module into an object-centric
representation (b). This representation is further transformed into a ï¬ne-grained factorization (c).
The transition function Tcan be deï¬ned over this factored state representation: each action may
only change a few factors of the state. Executing a speciï¬c action move-into(item#1, item#6)
produces the predicted factored state at the next timestep. During training time, we will be using the
object-centric observation from the next timestep to supervise the learning of T.
2 PDSketch
We focus on the problem of learning models for a robot that operates in a space Sof world states that
plans to achieve goal conditions that are subsets of S. A planning problem is a tuple hS;s0;g;A;Ti,
wheres02S is the initial state, gis a goal speciï¬cation in ï¬rst-order logic, Ais a set of actions
that the agent can execute, and Tis a environmental transition model T:SA!S . The task of
planning is to output a sequence of actions a=fai2Ag in which the terminal state sTinduced
by applying aisequentially following Tsatisï¬es the goal speciï¬cation g:eval(g;sT) = 1 . The
function eval(g;s)determines whether state ssatisï¬es the goal condition gby recursively evaluating
the logical expression and using learned neural groundings of the primitive terms in the expression.
At execution time, the agent will observe s0and be given gfrom human input, such as a ï¬rst-order
logic expression corresponding to â€œall the apples are in a blue bowl.â€ However, we do not assume
that the agent knows, in advance, the groundings of g(i.e. the underlying eval(g;s)function) or the
transition modelT. Thus, we need to learn gandTfrom data, in the form of observed trajectories
that achieve goal states of interest.
Formally, we assume the training data given to the agent is a collection of tuples hs;a;g; succi,
wheres=hsiiis a sequence of world states, a=haiiis the sequence of actions taken by the
robot,gis a goal speciï¬cation, and succ=hsucciiis the â€œtask-successâ€ signal. Each succi2f0;1g
indicates whether the goal gis satisï¬ed at state si:succi=eval(g;si). The data sequences should
be representative of the dynamics of the domain but need not be optimal goal-reaching trajectories.
It can be difï¬cult to learn a transition model that is accurate over the long term on some types of
state representations. For this reason, we generally assume an arbitrary latent space, , for planning.
The learning problem, then, is to ï¬nd three parametric functions, collectively parameterized by :
state encoderE:S! , goal-evaluation function eval:G!f0;1g, and transition model
T: A! . Although the domain might be mildly partially observable or stochastic, our goal
will be to recover the most accurate possible deterministic model on the latent space.
Local, sparse structure. We need models that will generalize very broadly to scenarios with different will be to recover the most accurate possible deterministic model on the latent space.
Local, sparse structure. We need models that will generalize very broadly to scenarios with different
numbers and types of objects in widely varying arrangements. To achieve this, we exploit structure to
enable compositional generalization: throughout this work we will be committing to an object-centric
representation for s, a logical language for goals g, and a sparse, local model of action effects.
We begin by factoring the environmental state sinto a set of object states. Each s2S is a tuple
(Us;fs), whereUsis the set of objects in state s, denoted by arbitrary unique names (e.g., item#1 ,
item#2 ). The object setUsis assumed to be constant within a single episode, but may differ in
different episodes. The second component, fs, is a dictionary mapping each object name to a ï¬xed-
dimensional object-state representation, such as a local image crop of the object and its position. We
3 can extend this representation to relations among objects, for example by adding gs(x;y);x;y2U
as a mapping from each object pair to a vector representation. We assume the detection and tracking
of objects through time is done by external perception modules (e.g., object detectors and trackers).
We carry the object-centric representation through to actions, goals, and the transition model. Speciï¬-
cally, we deï¬ne a predicate as a tuplehname;args;groundingi, where args is a list ofkarguments and
grounding is a function from the latent representations of the objects corresponding to its arguments
(in	k) into a scalar or vector value. (This is a generalization of the typical use of the term ""predicate,""
which is better suited for use in robotics domains in which many quantities we must reason about are
continuous.) For example, as illustrated in Fig. 3c, the predicate wetness takes a single argument
as its input, and returns a (latent) vector representation of its wetness property; its grounding might
be a neural network that maps from the visual appearance of the object to the latent wetness value.
Given a set of predicates, we deï¬ne the language of possible goal speciï¬cations to be all ï¬rst-order
logic formulas over the subset of the predicates whose output type is Boolean. To evaluate a goal
speciï¬cation in a state (U;f), quantiï¬cation is interpreted in the ï¬nite domain Uandfsprovides an
interpretation of object names into representations that can serve as input to the grounded predicates.
The transition model Tis speciï¬ed in terms of a set object-parameterized action schema
hname;args;precond;effect;i, where name is a symbol, args is a list of symbols, precond and
effect are descriptions of the actionâ€™s effects, described in section 2.1, and is a parameterized
primitive policy for carrying out the action in terms of raw perception and motor commands. These
local policies can be learned via demonstration or reinforcement learning in a phase prior to the
model-learning phase, constructed using principles of control theory, or a combination of these
methods. The set of concrete actions Aavailable in a state sis formed by instantiating the action
scheme with objects in universe Us. We assume the transition dynamics of the domain (i.e., the effect
of each action schema) are well characterized in terms of the changes of properties and relations of
objects and that the transition model is lifted in the sense that it can be applied to domain instances
with different numbers and types of objects. In addition, we assume the dynamics are local and sparse,
in the sense that effects of any individual action depend on and change only a small number attributes
and relations of a few objects, and that by default all other objects and attributes are unaffected.
Taking again action schema move-into as an example, shown in Fig. 3d, only the states of object #1
and #6 are relevant to this action (but not #2, #3, etc.), and furthermore, the action only changes the
pose andwetness properties of item#1 (but not the color and the type).
The factored representation also introduces a factored learning problem: instead of learning a
monolithic neural network for Tandeval, the problem is factored into learning the grounding of
individual predicates that appear in goal formulas, as well as the transition function for individual
factors that were changed by an action.
2.1 Representation Language
The overall speciï¬cation of evalandTcan be decomposed into two parts: 1) the locality and
sparsity structures and 2) the actual model parameters, , such as neural network weights. We provide
a symbolic language for human programmers to specify the locality and sparsity structure of the
domain and methods for representing and learning . If the human provides no structure, the model
falls back to a plain object-centric dynamics model Zhu et al. [2018]. However, we will show that domain and methods for representing and learning . If the human provides no structure, the model
falls back to a plain object-centric dynamics model Zhu et al. [2018]. However, we will show that
explicit encoding of locality and sparsity structures can substantially improve the data efï¬ciency of
learning and the computational efï¬ciency of planning with the resulting models.
PDSketch is an extension of the planning-domain deï¬nition language [Fikes and Nilsson, 1971, Fox
and Long, 2003], a widely used formalism that focuses exposing locality and sparsity structure in
symbolic planning domains. The key extensions are 1) allowing vector values in the computation
graph and 2) enabling the programmer to use â€œblanksâ€, which are unspeciï¬ed functions that will
be ï¬lled in with neural networks learned from data. Thus, rather than specifying the model in full
detail, the programmer provides only a â€œsketchâ€ [Solar-Lezama, 2008]. The two key representational
components of PDDL are predicates and action schemas (operators).
Fig. 4 shows a simple example of PDSketch deï¬nition of predicates. All three predicates take a single
object ?oof type item as their argument, and return either a ï¬‚oating-point vector or a scalar value
from 0 to 1, indicating the score of a binary classiï¬er. The image predicate simply refers to the raw
image crop feature of the object. The is-yellow predicateâ€™s grounding takes a very simple form
â€œ(??f (color ?o)) â€. The term ??fdeï¬nes a slot whose name is f. It takes only one argument, the
4 (a)A PDSketchdefinition of an input feature of each objects: (image?o),and two derived feature/predicates:(color?o)and (is-yellow?o).(:predicates; inputfeatures(image [return_type=vector[float32],input] ?o-item))(:derived(color[return_type=vector[float32]]?o-item)(??f(image?o)))(:derived(is-yellow?o-item) ; parameter and type(??f(color?o)); function body)RawObservation(Image)image?o(per-obj.)color::f(ConvNet)color?o(per-obj.)is-yellow::f(ConvNet)is-yellow?o(per-obj.score)(b) Thecorrespondingâ€œcomputationgraphâ€inducedbythedefinitions.color::fandis-yellow::farecustomizableCNNsthatareappliedidenticallytoeachobjectintheinputstate.
0.0
0.9
0.1
0.0
0.9
0.0Figure 4: A minimal example of deï¬ning derived features and predicates with blanks â€œ ??â€.
color of the object ?o, and outputs a classiï¬cation score, which can be interpreted as the score of the
object ?obeing yellow. The actual computation of the yellow predicate from the color value (as
well as the computation of the color value from the image value) is instantiated in a neural network
with trained parameters. The computation graph for the whole model can be built by recursively
chaining the function bodies of predicate deï¬nitions.
Next, we illustrate how locality andsparsity structures can be speciï¬ed for an action schema. Fig. 5
deï¬nes an action schema name move-into with two effect components. First, highlighted in blue,
the action changes the pose of object ?o1to a new pose that depends on the current pose of the
second object ?o2. Rather than hand-coding this detailed dependence, we leave the grounding blank.
In addition, in our domain, the wetness of an object may be changed when the object is placed into
a speciï¬c type of container. This is encoded by specifying a conditional effect using the keyword
when , with two parts: 1) a Boolean-valued condition gof some other predicates on the state (in this
case, the types of the two objects), and 2) the actual â€œeffectâ€, in this case, to change the wetness of
?o1based on a function that considers the current wetness of?o1. The update will be applied only
if the condition is true. To ensure the computation is differentiable, we make this condition â€œsoftâ€:
letwbe the current wetness, w0be the new wetness computed by function ??h, andcbe the scalar
condition value computed by function ??g. The updated value of the wetness will be cw0+ (1"," This paper introduces PDSketch, a domain definition language that combines human-specified structural sparsity priors and machine learning of continuous and symbolic aspects of the model. Experiments show that PDSketch is efficient and effective in two domains: BabyAI and Painting Factory, enabling data-efficient learning, compositional generalization, and domain-independent heuristics. It uses first-order logic to represent decision rules, an assignment operation, two special operators, syntax sugars, and a blank notation. It also uses a two-layer graph neural network (GNN) and a basic task and motion planning strategy."
34," Learning Rational Subgoals from Demonstrations and Instructions
Zhezheng Luo*1, Jiayuan Mao*1, Jiajun Wu2,
Tom Â´as Lozano-P Â´erez1, Joshua B. Tenenbaum1, Leslie Pack Kaelbling1
1Massachusetts Institute of Technology2Stanford University
Abstract
We present a framework for learning useful subgoals that sup-
port efï¬cient long-term planning to achieve novel goals. At
the core of our framework is a collection of rational subgoals
(RSGs), which are essentially binary classiï¬ers over the envi-
ronmental states. RSGs can be learned from weakly-annotated
data, in the form of unsegmented demonstration trajectories,
paired with abstract task descriptions, which are composed of
terms initially unknown to the agent (e.g., collect-wood then
craft-boat then go-across-river ). Our framework also discov-
ers dependencies between RSGs, e.g., the task collect-wood
is a helpful subgoal for the task craft-boat . Given a goal de-
scription, the learned subgoals and the derived dependencies
facilitate off-the-shelf planning algorithms, such as Aand
RRT, by setting helpful subgoals as waypoints to the plan-
ner, which signiï¬cantly improves performance-time efï¬ciency.
Project page: https://rsg.csail.mit.edu
Introduction
Being able to decompose complex tasks into subgoals is crit-
ical for efï¬cient long-term planning. Consider the example
in Fig. 1: planning to craft a boat from scratch is hard, as it
requires a long-term plan going from collecting materials to
crafting boats, but it can be made easier if we know that hav-
ing an axe andhaving wood are useful sub-goals. Planning
hierarchically with these subgoals can substantially reduce
the search required. It is also helpful to understand the tem-
poral dependencies between these subgoals, such as having
wood being a useful subgoal to achieve prior to crafting boat
makes long-term planning much more efï¬cient.
In this work, we propose Rational Subgoals (RSGs), a
framework for learning useful subgoals and their temporal
dependencies from demonstrations. Our system learns with
very weak supervision, in the form of a small number of un-
segmented demonstrations of complex behaviors paired with
abstract task descriptions. The descriptions are composed of
terms that are initially unknown to the agent, much as an
adult might narrate the high-level steps when demonstrating
a cooking recipe to a child. These action terms indicate im-
portant subgoals in the action sequence, and our agent learns
*These authors contributed equally.
Copyright Â©2023, Association for the Advancement of Artiï¬cial
Intelligence (www.aaai.org). All rights reserved.to detect when these subgoals are true in the world, infer their
temporal dependencies, and leverage them to plan efï¬ciently.
Illustrated in Fig. 1, our model learns from a dataset of
paired but unaligned low-level state-action sequences and
the corresponding abstract task description ( collect-wood
then craft-boat then go-across-river ). For each action term
o(e.g., collect-wood ), our model learns a goal condition Go,
which maps any state to a binary random variable, indicat-
ing whether the state satisï¬es the goal condition. Given the
training data, we decompose the observed trajectory into frag-
ments, each of which corresponds to a â€œrationalâ€ sequence
of actions for achieving a subgoal in the description.
While this model-based approach enables great general-
ity in generating behaviors, it suffers from the slow online
computation. To speed up online planning, we compute a de-
pendency matrix whose entries encode which subgoals might
be helpful to achieve before accomplishing another subgoal
(e.g., having wood is a helpful subgoal for the task crafting
boat, and thus the entry ( having wood ,crafting boat ) will
have a higher weight). During test time, given a ï¬nal goal
(e.g., craft boat ) and the initial state, a hierarchical search
algorithm is applied at both the subgoal level and the lower,
environmental-action level. (e.g., craft boat ) and the initial state, a hierarchical search
algorithm is applied at both the subgoal level and the lower,
environmental-action level.
The explicit learning of subgoals and their dependency
structures brings two important advantages. First, the sub-
goal dependency allows us to explicitly set helpful subgoals
as waypoints for planners. This signiï¬cantly improves their
runtime efï¬ciency. Second, compared to alternative subgoal
parameterizations such as reward functions, subgoals in the
form of a state classiï¬er allows us to use simple and efï¬cient
planners. For example, in continuous spaces, we can use
Rapidly-exploring Random Trees ( RRT) to search for plans
in the robot conï¬guration space. These planers do not require
training and generalize immediately to novel environments.
We evaluate RSGs in Crafting World (Chen, Gupta, and
Marino 2021), an image-based grid-world domain with a
rich set of object crafting tasks, and Playroom (Konidaris,
Kaelbling, and Lozano-Perez 2018), a 2D continuous domain
with geometric constraints. Our evaluation shows that our
model clearly outperforms baselines on planning tasks where
the agent needs to generate trajectories to accomplish a given
task. Another important application of RSGs is to create a
language interface for human-robot communication, which
includes robots interpreting human actions and humans in-arXiv:2303.05487v1  [cs.AI]  9 Mar 2023 MoveRightMoveDownCollectMoveLeftCraft
Subgoal1:collect-woodSubgoal2:craft-boat()*+!=,-./'()*+!=,-./'()*+!=,-./'()*+!=#%&'()*+""=,-./'()*+""=#%&'()*+""=,-./'Subgoal1:collect-wood=%&'(!Subgoal2:craft-boat=%&'(""(a)(b)Figure 1: Interpreting a demonstration and its description in terms of RSGs: (a) Each RSG is represented as a subgoal Go. (b)
The system infers a transition to the next subgoal if the Gcondition is satisï¬ed. Such transition rules can be used to interpret
demonstrations and to plan for tasks that require multiple steps to achieve.
structing robots by specifying a sequence of subgoals. Our
model enables compositional generalization through ï¬‚exible
re-composition of learned subgoals, which allows the robot
to interpret and execute novel instructions.
Rational Subgoal Learning and Planning
We focus on learning rational subgoals from demonstration
data and leveraging them for planning. Formally, our training
data is a collection of paired unsegmented demonstrations
(i.e., state and action sequences) and abstract descriptions
(e.g., collect-wood then craft-boat ) composed of action terms
(collect-wood , etc.) and connectives ( then,or). Our ultimate
goal is to recover the grounding (i.e., the corresponding sub-
goal speciï¬ed by the action term) for each individual action
term. These subgoals will be leveraged by planning algo-
rithms to solve long-horizon planning problems.
We begin this section with basic deï¬nitions of the rational
subgoal representations and the language TLfor abstract de-
scriptions. Second, we outline the planning algorithm we use
to reï¬ne high-level instructions in TLinto environmental ac-
tions that agents can execute, given the RSGs. Although any
search algorithms or Markov Decision Process (MDP) solvers
are in principle applicable for our planning task, in this paper,
we have focused on a simple extension to the A* algorithm.
Next, we present the algorithm we use to learn RSGs from
data. Since we are working with unsegmented trajectories,
the learning algorithm has two steps. It ï¬rst computes a ra-
tionality score for individual actions in the trajectory based
on the optimal plan derived from the A* algorithm. Then,
it uses a dynamic programming algorithm to ï¬nd the best
segmentation of the trajectory and updates the parameters.
Finally, we describe a dependency discovery algorithm for
RSGs and apply it to solve planning tasks given only a single
goal action term (e.g., collect-gold ), in contrast to the earlier
case where there are detailed step-by-step instructions.
We call our representation rational subgoals because our
learning algorithm is based on a rationality objective with
-(a))=+(b))!=,-./01(d))=,2031(c))=,-./01456-34561-1-127#7$7#7$7#7$-34561-17#13456-1-7$Figure 2: Illustrative example of how ï¬nite state machines
(FSM) are constructed from task descriptions. The super-
starting node v0and the super-terminal node vTare high-
lighted.
respect to demonstration trajectories, and our planning algo-
rithm chooses rational subgoals to accelerate the search.
Formally, a rational subgoal (RSG) is a classiï¬er that
maps an environmental state sto a Boolean value, indicat-
ing whether the goal condition is satisï¬ed at s. Each RSG
has an atomic name o(e.g., collect-wood ), and the corre-
sponding goal classiï¬er is denoted by Go. Depending on the
representation of states, Gocan take various forms of neural
networks, such as convolutional neural networks (CNNs) for
image-based state representations.
In both learning and planning, we will be using an ab-
stract language to describe tasks, such as collect-wood then
craft-boat . These descriptions are written in a formal task lan-
guageTL. Syntactically, all atomic subgoals are in TL; and
for allt1;t22TL ,(t1thent2),(t1ort2), and (t1andt2)
are inTL. Semantically, a state sequence ssatisï¬es a task
descriptiont, written sj=twhen:
â€¢Iftis aRSGo, then the ï¬rst state does not satisfy Go,
and the last state satisï¬es Go. Note that this implies that descriptiont, written sj=twhen:
â€¢Iftis aRSGo, then the ï¬rst state does not satisfy Go,
and the last state satisï¬es Go. Note that this implies that
the sequence smust have at least 2states.
â€¢Ift= (t1thent2)then90< j < n such that
(s1;:::;sj)j=t1and(sj;:::;sn)j=t2: taskt1should
be accomplished before t2.
â€¢Ift= (t1ort2)thensj=t1orsj=t2: the agent should
either complete t1ort2. â€¢Ift= (t1andt2)then sj= (t1thent2)orsj=
(t2thent1): the agent should complete both t1andt2,
but in any order ( t1ï¬rst ort2ï¬rst) *.
Note that the relation sj=tonly speciï¬es whether scom-
pletestbut not how optimal sis. Later on, when we deï¬ne
the planning problem, we will introduce the trajectory cost.
Each task description t2TL can be represented with a
non-deterministic ï¬nite state machine ( FSM), representing
the sequential and branching structures. Each FSMtis a
tuple (Vt;Et;VIt;VGt)which are subgoal nodes, edges, set
of possible starting nodes and set of terminal nodes. Each
node corresponds to an action term in the description, and
each edge corresponds to a possible transition of changing
subgoals. Fig. 2 illustrates the constructions for syntax in TL,
and we provide the follow algorithm for the construction.
â€¢Single subgoal: A single subgoal sis corresponding FSM
with a single node i.e. VIt=VGt=Vt=fsg, and
Et=;.
â€¢t1thent2: We merge FSMt1and FSMt2by merging their
subgoal nodes, edges and using VIt1as the new starting
node set and VGt2as the new terminal node set. Then, we
add all edges from VGt1toVIt2. Formally,
FSMt1thent2=
(Vt1[Vt2;Et1[Et2[(VGt1VIt2);VIt1;VGt2);
whereindicates the Cartesian product, meaning that
each terminal node of FSMt1can transit to any starting
node of FSMt2.
â€¢t1orortn: Simply merge nFSMs without adding
any new edges. Formally,
FSMt1orortn= ([
iVti;[
iEti;[
iVIti;[
iVGti)
â€¢t1andandtn: Build 2n"," This paper presents a framework for learning rational subgoals from demonstrations and instructions, using A* search on FSM-augmented transition models. It compares the performance of RSGs with two baselines (IRL and Behavior Cloning) on primitive and compositional tasks, as well as novel tasks. It also discusses the use of Generative Adversarial Imitation Learning (GAIL) as a baseline for completing tasks on seen instructions. The results show that RSGs outperform all baselines on both the compositional and novel splits."
35," Knowledge-augmented Risk Assessment (KaRA): a hybrid-intelligence framework
for supporting knowledge-intensive risk assessment of prospect candidates
Carlos Raoni Mendes, Emilio Vital Brazil, Vinicius Segura, Renato Cerqueira
IBM Research
Rio de Janeiro, RJ, Brazil
craoni@br.ibm.com, evital@br.ibm.com, vboas@br.ibm.com, rcerq@br.ibm.com
Abstract
Evaluating the potential of a prospective candidate is a com-
mon task in multiple decision-making processes in different
industries. We refer to a prospect as something or someone
that could potentially produce positive results in a given con-
text, e.g., an area where an oil company could ï¬nd oil, a com-
pound that, when synthesized, results in a material with re-
quired properties, and so on. In many contexts, assessing the
Probability of Success (PoS) of prospects heavily depends
on expertsâ€™ knowledge, often leading to biased and inconsis-
tent assessments. We have developed the framework named
KARA (Knowledge-augmented Risk Assessment) to address
these issues. It combines multiple AI techniques that con-
sider SMEs (Subject Matter Experts) feedback on top of a
structured domain knowledge-base to support risk assessment
processes of prospect candidates in knowledge-intensive con-
texts.
Introduction
The assessment of the risk of failure or its opposite, the Prob-
ability of Success (POS), plays a crucial role in deciding
which prospects are worth investing in. In many critical con-
texts, the prospect risk assessment process carries the char-
acteristics of the so-called Knowledge-intensive process (Ci-
ccio, Marrella, and Russo 2015). When this is the case, there
is a strong dependency on the tacit knowledge of multiple
experts in different areas, and a relevant part of the available
data is heavily uncertain. Methods that donâ€™t correctly han-
dle this inherent complexity often lead to biased and incon-
sistent assessments. The challenge is to develop a methodol-
ogy and supporting technology for prospect risk assessment
in knowledge-intensive contexts that is consistent, reduces
biases, controls uncertainty, and often leads to the selection
of successful prospects (or discoveries). This work describes
a framework that aims to address these issues. We called it
the Knowledge-augmented Risk Assessment (KaRA) frame-
work.
The recent advances in AI and Knowledge Engineering
provided the basis for the development of KaRA. Knowl-
edge engineering practices and technologies are applied to
represent and integrate the domain knowledge from multi-
ple data sources and stakeholders and provide easy access
Copyright Â© 2023, Association for the Advancement of Artiï¬cial
Intelligence (www.aaai.org). All rights reserved.to this knowledge. At the same time, AI provides the appro-
priate tools for inference, prediction, uncertainty reduction,
consensus reaching, etc. Then, KaRA combines multiple AI
techniques that consider SMEâ€™s (Subject Matter Experts)
feedback on top of a structured domain KB (Knowledge
Base) to support the risk assessment processes of prospect
candidates in knowledge-intensive contexts.
The KaRA framework is a generalization and extension
of the work we developed for supporting the assessment of
the geological success of prospects (see Silva et al. (2019)
and Vital Brazil et al. (2021)). Next, we detail the general
problem that KaRA approaches.
Knowledge-intensive Prospect Risk Assessment
In this work, we refer to a successful prospect as a dis-
covery. Finding discoveries generally starts with many can-
didates from which very little is known. These candidates
pass through a triage process that selects those worth fur-
ther investigation. Given the number of candidates, the triage
often involves some form of automatic ï¬ltering combined
with expertsâ€™ simple evaluations. The candidates that pass
triage became what we refer to as prospects. A prospect can
pass through a detailed assessment that involves analyzing
the many risk factors that could prevent it from succeeding. triage became what we refer to as prospects. A prospect can
pass through a detailed assessment that involves analyzing
the many risk factors that could prevent it from succeeding.
This process requires expertsâ€™ analysis from different areas
and probably new data acquisition. These resource require-
ments imply the existence of a limited number of prospects.
Then, a ï¬nal investment is made to an even smaller number
to become discoveries or failures. For instance, in oil and
gas exploration, this last investment would mean drilling a
well, while in materials discovery, that would mean synthe-
sizing a new compound. Both examples are very resource-
demanding, but they could generate high rewards on the
other side. Therefore, the prospect selection process is es-
sential to creating a successful business. At each step of
the process the number of candidates decreases, while at
the same time, more is known about them. Another essen-
tial aspect is that each step requires increasing resource in-
vestments. In Figure 1, we detail the workï¬‚ow for assessing
prospectsâ€™ POS. It starts with acquiring new data related to
the prospect to be analyzed. The available data is then pro-
cessed and interpreted by experts from different areas. This
process is carried out to detail relevant information and char-
acteristics resulting in a prospect characterization suited forarXiv:2303.05288v1  [cs.AI]  9 Mar 2023 Figure 1: Prospect Risk Assessment Workï¬‚ow
the risk assessment methodology. Itâ€™s worth noting that the
available data is often limited and uncertain. The expertsâ€™ in-
terpretation compensates for these limitations with their ex-
perience and tacit knowledge. But the ï¬nal characterization
is still subject to uncertainty and may be biased by the ex-
pertsâ€™ opinions. The risk assessment methodology then takes
the characterization as input and produces the prospectâ€™s
POS itself. It is also a process that depends on expertsâ€™ opin-
ions and knowledge. It becomes only a guessing exercise for
experts if done in an unstructured form, often leading to in-
consistent and biased assessments (Milkov 2015).
The prospectâ€™s POS helps decision-makers decide if they
should invest, discard, or need more information/data and
then another round of assessment. This last decision is rep-
resented in Figure 1 by the backward arrow. Essentially an
enduring decision (invest or discard) is made when there is
enough conï¬dence in the current knowledge of the prospect
and, consequently, in the assessment. Some risk assessment
methodologies use the metric Level-of-Knowledge (LOK)
to represent how much is known about the prospect explic-
itly (Lowry, Suttill, and Taylor 2005).
Structure
In the next section, we detail the related literature with a
focus on the works in the Oil & Gas exploration space.
We assume that it is the most advanced industry regarding
prospect risk assessment. In the section KaRA Framework ,
we present an overview of the proposed methodology de-
veloped in KaRA. Subsequent sections are dedicated to de-
tail the methodology phases, that are, prospect characteri-
zation, Level-of-Knowledge assessment, and Probability-of-
Success assessment.
Related Literature
The generalization that we proposed for knowledge-
intensive prospect risk assessment was derived from the Oil
& Gas exploration domain. In this context, a prospect is a re-
gion containing a potentially recoverable oil accumulation.
To conï¬rm or discard the hypothesis of oil accumulation in
the prospect region, the company must drill a well, which is
very resource demanding. It is a high-risk, high-reward sit-uation, so this industry treats it very carefully. We believe
that prospect risk assessment in the Oil & Gas exploration
space is mature compared to other prospect exploration do-
mains. Therefore, we will use its literature as a reference in
this section.
Given the complexity involved in assessing a prospect, a
common approach adopted by the industry is to break the as-
sessment into different geological (or risk) factors, evaluat-
ing the POS of each one and then combining the correspond-
ing probabilities to obtain the POS for the prospect itself.
The factors correspond to geological features that should ex-
ist to form an oil accumulation. One common assumption to
facilitate the analysis is to adopt independence between the
risk factors. In this case, the prospectâ€™s POS is the multi-
plication of all individual factorâ€™s POS values. So, choosing
how to break the assessment into different factors plays a
crucial role in the methodology. An excessive number may
result in very small and hard to differentiate prospectsâ€™ POS
values, while a small number may neglect essential dimen-
sions of the risk evaluation. So, the methods adopted across
different organizations vary in the number of geological risk
factors analyzed. Milkov (2015) presents a table comparing
various methodologies found in the literature. To illustrate
this variation, the method proposed by Lowry, Suttill, and
Taylor (2005) considers the assessment of 19 geological risk
factors, while Rose (2001) analyzes only ï¬ve.
The methodologies also vary in the strategy that guides
POS assessments for each geological factor. They must bal-
ance the quality and quantity of the available data with the
geological model characteristics to ï¬ne-tune the range of
possible values experts could adopt for the POS. In (Milkov ance the quality and quantity of the available data with the
geological model characteristics to ï¬ne-tune the range of
possible values experts could adopt for the POS. In (Milkov
2015) and (Jan-Erik, Bundiit, and Simplicil 2000), the au-
thors propose using reference tables. To use a geological fac-
tor reference table, one must identify which cell the prospect
maps based on the available data and geological model char-
acteristics. While in (Milkov 2015), the cell speciï¬es the
POS value itself, in (Jan-Erik, Bundiit, and Simplicil 2000),
they provide a range of possible values that POS could as-
sume. Although adopting these tables may improve the con-
sistency and repeatability of the assessment process, they are
not suitable to accommodate new disruptive knowledge. One
clear example of this problem is that the tables become out- Knowledge Base (KB)Structured Domain Knowledge 
Structured Domain DataUnstructured Domain DataAI-discovery AgentsKnowledge-augmented Risk Assessment (KaRA)
Discovery WorkbenchFigure 2: Overview of KaRA â€“ methodology workï¬‚ow and features.
dated when new technologies are developed.
Another popular method is the use of the metric Level-of-
Knowledge (LOK) to assess data availability, quantity, and
quality (see (Paltrinieri, Comfort, and Reniers 2019)). Some
approaches use the LOK metric to constrain the possible
range of values assigned to the POS. In (Rose 2001), we ï¬nd
a matrix specifying a relation where the POS is restricted to
the middle of the scale (around ï¬fty percent) when the LOK
is low. At the same time, at high LOK levels, the POS value
should be either very low (around zero percent) or very high
(around a hundred percent). The rationale is that in a low
conï¬dence situation, one should not be conclusive about the
POS value, while in high conï¬dence cases, one must be very
assertive. In (Lowry, Suttill, and Taylor 2005), they apply the
same rationale and create a graphic that speciï¬es a LOK and
POS relationship by delimiting a region of allowed LOK and
POS assessment pairs. The same work also presents alterna-
tive LOK/POS relationships that implement different ratio-
nales. The authors also recognize that making quantitative
assessments of LOK and using it to manipulate POS is chal-
lenging both in theory and practice.
The KaRA framework aims at addressing the limitations
of the described methods. The main objective is to provide a
methodology that guarantees consistency, decreases biases,
and continuously improves given new relevant knowledge
obtained from data sources and or SMEs, all supported by
practical and meaningful LOK quantitative scales.
KaRA Framework
The KaRA framework is a generalization and extension of
the work we developed for supporting the assessment of the
geological success of prospects (see Silva et al. (2019), and
Vital Brazil et al. (2021)). It combines multiple AI tech-
niques that consider SMEsâ€™ feedback on top of a structured
domain knowledge base to support the risk assessment pro-
cesses of candidates in knowledge-intensive contexts. The
recent advances in AI and Knowledge Engineering providedthe basis for the development of KaRA. Knowledge en-
gineering practices and technologies are applied to repre-
sent and integrate the domain knowledge from multiple data
sources and stakeholders and provide easy access to this
knowledge. At the same time, AI provides the appropriate
tools for inference, prediction, uncertainty reduction, con-
sensus reaching, etc.
The methodology implemented by KaRA divides the as-
sessment into multiple risk factors. Individual risk factor
evaluation encompasses three phases: risk factor characteri-
zation, LOK assessment, and POS assessment. Different AI
agents support expert decisions at each one of them. As men-
tioned, the domain knowledge is structured and integrated
by the KB. The KB also handles all the data used by KaRA
components. KaRA aims to enable a co-creation environ-
ment for SMEs and AI agents to support the risk assessment
process. Figure 2 summarizes the architecture, the method-
ology workï¬‚ow, and some of the main features of KaRA.
We discuss those features in the sequence according to each
phase.
Risk Factor Characterization
We adopted a similar approach to (Milkov 2015) and (Jan-
Erik, Bundiit, and Simplicil 2000) in the risk factor char-
acterization phase. For each risk factor, experts should an-
swer a standard questionnaire showcasing the data analy-
sis workï¬‚ow results that could inï¬‚uence LOK or POS as-
sessments. The characterization questionnaires structure the
candidates in the KB, providing an easy way to represent
them for supervised and unsupervised machine learning al-
gorithms. One representative example used in the following
phases is retrieving similar candidates in terms of characteri- them for supervised and unsupervised machine learning al-
gorithms. One representative example used in the following
phases is retrieving similar candidates in terms of characteri-
zation for comparison purposes. The differentiator of KaRA
will be the ability to query and reason through the KB to re-
trieve and rank relevant evidence that may help the experts
answer the characterization questions. The expert will curate
the evidence recovered from the KB, keeping only the ones GlobalLOKExpert LOKCandidatesExpert LOK ComparisonsRule-based InferenceConsistent Expert LOK Comparisons 
Peer-reviewed CandidatesUnder-review CandidatesReference LOK ML TrainingReference LOK ML PredictionReference LOK Trained ModelReference LOK ScoresLOK Calibration LP ModelExpert LOK Scores
All Experts LOK ComparisonsConflicts Minimization IP ModelConsistent Consensus LOK Comparisons LOK Calibration LP ModelGlobal LOK ScoresFigure 3: Workï¬‚ows for expert and global LOK scores.
relevant to the answer. This feedback feeds the ranking algo-
rithms used in the evidence retrieval, which are continuously
improved. This mechanism establishes a co-creation process
where AI and experts collaborate to accurately characterize
the candidate risk factors taking advantage of available evi-
dence stored in the KB and the expertâ€™s tacit knowledge.
LOK Assessment
The role of the LOK assessment phase is to establish fair
and consistent LOK score scales dependent on the risk fac-
tor characterizations produced in the previous step to support
the POS assessment process, such as done in (Lowry, Suttill,
and Taylor 2005) and (Rose 2001). The LOK scales are cre-
ated based on pairwise comparisons made by the experts and
previously assessed, and peer-reviewed candidates present
in KB. These candidates serve as training examples for a
supervised machine learning algorithm that gives an initial
LOK estimate, the so-called reference LOK. Expertsâ€™ pair-
wise LOK comparisons calibrate this estimate by solving a
Linear Programming (LP) model that determines the small-
est overall adjustments in the LOK values needed to respect
the comparisons. A rule-based inference strategy maintains
the consistency of comparisons for a particular individual.
The comparisons at the individual level capture the ranking
opinions of each expert. The reference LOK estimates cal-
ibrated by these comparisons create the expert LOK scale.
The system also determines the subset of consistent LOK
comparisons that best represent expertsâ€™ consensus by solv-
ing an Integer Programming (IP) model that minimizes the
conï¬‚icts between the output comparisons and the overall
expert opinions. We obtain the so-called global LOK scale
when these comparisons calibrate the reference LOK esti-
mates with the same LP model previously described. Ad-
ditional candidates and comparisons continuously adjust ex-
pert and global LOK scales. Figure 3 summarizes expert and
global LOK workï¬‚ows. This approach is another example of
a human-AI co-creation strategy applied to support an essen-
tial step in the discovery process.LOK comparisons consistency trough rule-based infer-
ence As previously mentioned, when evaluating a risk fac-
tor of a target prospect, experts compare pairwisely the risk
factor characterization of the target prospect with other sim-
ilar risk characterizations present in the KB. In the pairwise
comparison, the expert answers which risk characterization
should receive a higher LOK score or if their LOK scores
should be the same. A rule-based approach keeps the con-
sistency of LOK comparisons for each expert. Given risk
factor characterizations a,b, and c, and Lirepresenting the
LOK score of characterization i, the consistency rules for
pairwise LOK comparisons are:
â€¢(La< Lb)^(Lb< Lc) =)La< Lc
â€¢(La=Lb)^(Lb=Lc) =)La=Lc
â€¢(La< Lb)^(Lb=Lc) =)La< Lc
In ï¬gure 4, we show a graph representation of canonical ex-
pertâ€™s LOK comparisons. The nodes represent the risk factor
characterizations, directed edges from a node ito a node
jrepresent a LOK comparison where Li> L j, while the
bi-directional ones represent a LOK comparison Li=Lj.
Figure 5 shows the graph representation after applying LOK
A
B
C D E
Figure 4: Canonical LOK comparisons graph
consistency rules. The inference of those rules could be ob-
tained by polynomial-time graph-based algorithms such as
the ones found in (Mohr and Henderson 1986).
Reference LOK and LOK Calibration LP Reference tained by polynomial-time graph-based algorithms such as
the ones found in (Mohr and Henderson 1986).
Reference LOK and LOK Calibration LP Reference
LOK scores provide a ï¬rst quantitative estimation of LOK A
B
C
D
EFigure 5: Consistent LOK comparisons graph after inference
based on peer-reviewed examples, which means that a group
of experts validated their ï¬nal LOK assessment scores. Us-
ing a one-hot encoding representation of risk-factor charac-
terizations, we apply supervised machine learning (ML) al-
gorithms to estimate the reference LOK scores. The model
is re-trained whenever a new peer-reviewed assessment is
stored in the KB. We use the average loss of a ten-fold
cross-validation test to choose the best ML model (i.e., al-
gorithm and parametrization). Despite the usefulness of ref-
erence LOK, we adopt in KaRA an approach that prioritizes
expert feedback. We create individual LOK scales by cali-
brating the reference LOK estimates with the expertâ€™s con-
sistent LOK comparisons. Given a set of risk factor charac-
terizations P, reference LOK estimates LRi(8i2P), a set
of consistent greater than GTand equals EQpairwise (i; j)
LOK comparisons, the following LP is used to estimate the
expertâ€™s LOK scores Li(8i2P):
MinX
i2PjLi"," This paper presents the Knowledge-augmented Risk Assessment (KaRA) framework, a hybrid-intelligence system designed to support knowledge-intensive risk assessment of prospect candidates. KaRA combines AI techniques with structured domain knowledge and feedback from Subject Matter Experts (SMEs) to reduce bias and inconsistency in the assessment of the Probability of Success (PoS) of prospects. It also discusses GSA â€“ GeoScience Advisor, a web-based platform developed by Vital Brazil, E. et al. to help geoscientists make informed decisions. GSA provides access to a variety of data sources and tools to help users analyze and interpret geological data."
36," Published as a conference paper at ICLR 2023
PLANNING WITH LARGE LANGUAGE MODELS
FOR CODE GENERATION
Shun Zhang, Zhenfang Chen, Yikang Shen
MIT-IBM Watson AI LabMingyu Ding
The University of Hong Kong
Joshua B. Tenenbaum
MIT BCS, CBMM, CSAILChuang Gan
UMass Amherst, MIT-IBM Watson AI Lab
ABSTRACT
Existing large language model-based code generation pipelines typically use beam
search or sampling algorithms during the decoding process. Although the pro-
grams they generate achieve high token-matching-based scores, they often fail to
compile or generate incorrect outputs. The main reason is that conventional Trans-
former decoding algorithms may not be the best choice for code generation. In
this work, we propose a novel Transformer decoding algorithm, Planning-Guided
Transformer Decoding (PG-TD), that uses a planning algorithm to do lookahead
search and guide the Transformer to generate better programs. Speciï¬cally, in-
stead of simply optimizing the likelihood of the generated sequences, the Trans-
former makes use of a planner to generate candidate programs and test them on
public test cases. The Transformer can therefore make more informed decisions
and generate tokens that will eventually lead to higher-quality programs. We also
design a mechanism that shares information between the Transformer and the
planner to make our algorithm computationally efï¬cient. We empirically evaluate
our framework with several large language models as backbones on public coding
challenge benchmarks, showing that 1) it can generate programs that consistently
achieve higher performance compared with competing baseline methods; 2) it en-
ables controllable code generation, such as concise codes and highly-commented
codes by optimizing modiï¬ed objective1.
1 I NTRODUCTION
Large language models like Transformer (Vaswani et al., 2017a) have shown successes in natural
language processing, computer vision, and various other domains. Thanks to Transformerâ€™s power
on sequence modeling, it has been adopted for code generation (Wang et al., 2021; Ahmad et al.,
2021) by treating programs as text sequences. Transformer has achieved signiï¬cant improvements
on the benchmarking tasks of code translation (Roziere et al., 2022), code completion (Chen et al.,
2021a), and solving coding challenge problems (Hendrycks et al., 2021). Recently, AlphaCode (Li
et al., 2022) even achieved a competitive-level performance in programming competitions with the
help of large Transformer models pre-trained on a large programming corpus.
Transformer-based pipelines like AlphaCode follow the tradition of natural language processing
and use sampling methods (Fan et al., 2018; Dabre & Fujita, 2020) during the generation process.
Speciï¬cally, they sample a large number of complete programs using a pre-trained code generation
Transformer, evaluate these programs using the public test cases provided in the dataset, and output
the program that passes the most number of test cases. Compared with beam search-based methods,
these sampling followed by ï¬ltering algorithms (which we will refer to as sampling + ï¬ltering ) can
take advantage of test cases and indeed improve the quality of the generated programs. However,
during the Transformer generation process, they do not consider the test cases at all. Instead, they
only use the test cases to evaluate the programs after all the candidate programs are generated. This
can make their algorithms sample inefï¬cient. Different from natural languages, programs may fail
1Project page: https://codeaimcts.github.io
1arXiv:2303.05510v1  [cs.LG]  9 Mar 2023 Published as a conference paper at ICLR 2023
completely with even a single incorrect generated token. So these algorithms need to exhaustively
sample a large number of programs to ï¬nd a correct solution.
The main reason behind the sample efï¬ciency issue of these algorithms is that the Transformer beam
search algorithm and the sampling algorithm (Vaswani et al., 2017b) may not be the best choices
for code generation. An ideal code generation algorithm should stop early in the generation process
when it knows the program it currently generates would certainly fail, and bias the generation pro-
cess towards generating successful programs that pass more test cases. To achieve such a goal, we
contribute to applying a planning algorithm in the Transformer generation process. Since a planning
algorithm can use the pass rates of the generated programs as its objective, we use it to determine
the quality of the generated codes and make the Transformer model make more informed decisions.
In this paper, we investigate the following research question: Can we integrate a planning algo-
rithm with a pre-trained code generation Transformer, achieving an algorithm that generates better
programs than the conventional Transformer generation algorithms and the well-accepted sam-
pling + ï¬ltering scheme in the literature? To answer this question, we propose a novel algorithm,
Planning-Guided Transformer Decoding (PG-TD). During the code generation process, a planner
does lookahead search and ï¬nds tokens that will lead to high-quality codes. The planner alone may
not efï¬ciently ï¬nd high-quality codes due to the large search space of codes, and that is where a pre-
trained code generation Transformer comes into play. Speciï¬cally, the Transformer beam search
algorithm and the next-token probabilities are used inside the planner to provide useful heuristics.
We ï¬nd that a straightforward integration between the planner and the Transformer can be compu-
tationally inefï¬cient. So we design mechanisms that allow the Transformer and the planner to share
their information to make the overall algorithm more efï¬cient.
We emphasize that our algorithm is model-agnostic , that is, any standard code generation Trans-
former model can be used as the backbone Transformer. Importantly, our algorithm does not require
acquiring more sample solutions or ï¬netuning the Transformer model to improve its performance.
We empirically ï¬nd that our proposed algorithm generates higher-quality programs under multiple
accepted metrics compared with competing baseline methods. Additionally, we also empirically
show that our algorithm has the following advantages. 1) By changing the reward function of the
planner, our algorithm becomes versatile and can optimize different objective functions without the
necessity of ï¬netuning the Transformer model. 2) Our algorithm can generate solutions that are used
to ï¬netune a code-generation Transformer model to improve the Transformerâ€™s performance. More
precisely, we have the following contributions in this paper.
â€¢ First, we propose a novel algorithm, Planning-Guided Transformer Decoding (PG-TD), that
uses a planning algorithm for lookahead search and guide the Transformer to generate better
codes. Our algorithm is model-agnostic, which can work with any standard Transformer model,
and does not require knowledge of the grammar of the generated programs.
â€¢ Second, a direct integration of the planning algorithm with the Transformer decoding process
can cause redundant uses of the Transformer beam search algorithm. We contribute to design-
ing mechanisms that signiï¬cantly improve the computational efï¬ciency of the algorithm.
â€¢ Third, we evaluate our algorithm on competitive programming benchmarks and empirically
show that our algorithm can consistently generate better programs in terms of the pass rate and
other metrics compared with the baseline methods. We also show that our algorithm is versatile show that our algorithm can consistently generate better programs in terms of the pass rate and
other metrics compared with the baseline methods. We also show that our algorithm is versatile
and can optimize objectives other than the pass rate for controllable code generation, such as
generating concise codes and codes with more comments.
2 R ELATED WORK
Transformers for program synthesis. Our work is based on Transformer for program synthe-
sis (Roziere et al., 2020; Austin et al., 2021). Inspired by their capacities on a range of natural
language tasks, modern transformer-based language models (Devlin et al., 2019; Radford et al.,
2019; Raffel et al., 2020) have been adopted for program synthesis by treating programming lan-
guages in the same way as natural languages. A family of BERT-based Transformers are developed
for code syntax (Kanade et al., 2020; Feng et al., 2020; Devlin et al., 2019; Guo et al., 2020). Later,
CodeX (Chen et al., 2021a) and CodeT5 (Wang et al., 2021) adopted GPT2 (Radford et al., 2019)
and T5 (Raffel et al., 2020), respectively, as backbones for both code understanding and generation.
Different learning methods including learning from examples (Ellis et al., 2021) and neural-symbolic
methods (Nye et al., 2020) were explored. Recently, AlphaCode (Li et al., 2022) combined large
2 Published as a conference paper at ICLR 2023
transformer models pre-trained on massive program data with large-scale sampling, showing com-
petitive performance in programming competitions. All these works mainly focused on training
more powerful code-generation models and still used beam search (Graves, 2012) or sampling (Fan
et al., 2018) during the Transformersâ€™ generation process.
Test cases for program synthesis. Our work is also related to using unit tests (Myers, 1979) for
program synthesis. Tufano et al. (2020a;b) propose to generate test cases and corresponding accurate
assert statements with Transformer models (Vaswani et al., 2017a). Recently, Roziere et al. (2022)
leverage automatically generated unit tests to construct parallel training data for unsupervised code
translation. Chen et al. (2018); Gupta et al. (2020); Chen et al. (2021b) directly synthesize domain-
speciï¬c programs from input-output pairs without problem description. Ellis et al. (2019) use test
cases to train a reinforcement learning agent and use a sequential Monte-Carlo sampling method
for code generation. Unlike the prior work, we use unit-testing results as reward signals for a
tree-search-based planning algorithm, which is further integrated with a Transformer-based large
language model to generate better codes.
Planning and reinforcement learning for code generation. The code generation problem has
been formulated as a sequential decision-making problem (Bunel et al., 2018; Chen et al., 2018),
which enables designing and applying reinforcement learning (RL) and planning algorithms for code
generation. RL has been used for both the training phase and the decoding phase of the Transformer
for code generation. In the training phase, Le et al. (2022); Xu et al. (2019b) use an RL objective
that optimizes the correctness of the generated programs instead of optimizing their similarity to the
reference solutions. In the decoding phase, the Monte-Carlo tree search (MCTS) algorithm has been
applied to search for high-quality codes. However, MCTS itself is unable to scale to larger domains.
It is only used to generate domain-speciï¬c languages or for restricted programming synthesis tasks
like assembly code generation (Xu et al., 2019a), Java bytecode translation (Lim & Yoo, 2016), and
robot planning (Matulewicz, 2022). These tasks have a much smaller scale than generating Python
codes in our work. Therefore, their frameworks do not require a large language model and do not
need to address the challenge of integrating a planning algorithm with a large language model.
MCTS is more efï¬cient and applicable to large domains when combined with deep learning or with
a default policy as prior knowledge (Gelly & Silver, 2011; Silver et al., 2016; Simmons-Edler et al.,
2018). We consider the same overall recipe in our work. Speciï¬cally, we contributed to integrating
the large language model with a tree search algorithm to design a novel algorithm that is capable of
solving competitive programming problems, and designed mechanisms to improve its efï¬ciency.
Planning in natural language generation. Planning algorithms like MCTS have also been used
to ï¬nd the optimal text outputs for different natural language processing (NLP) tasks. For example,
Scialom et al. (2021); Leblond et al. (2021); Chafï¬n et al. (2022) use pre-trained discriminators or
pre-deï¬ned metrics as reward functions. We want to emphasize that we are the ï¬rst to combine a
tree search algorithm with large language models for general-purpose programming language gener-
ation. We design the interfaces between these two components and deal with the unique challenges
of making the framework computationally efï¬cient. Concurrently, other search algorithms like A*
algorithm (Hart et al., 1968) are also applied in the Transformer decoding process. Lu et al. (2021)
consider the constrained text generation problem and integrate A* with the beam search algorithm. algorithm (Hart et al., 1968) are also applied in the Transformer decoding process. Lu et al. (2021)
consider the constrained text generation problem and integrate A* with the beam search algorithm.
However, their constraints are expressed as a formal logic expression, which is different from maxi-
mizing the pass rate in our problem.
3 M ETHOD
3.1 O VERVIEW
We consider the code generation problem for competitive programming, illustrated in Fig. 1. An
agent is given the natural language description of a coding problem. It requires the agent to under-
stand the problem description and generate a program that solves the problem. Similar to Li et al.
(2022); Chen et al. (2018); Ellis et al. (2019), we assume that the agent has access to a set of test
cases, where a test case is a pair of input, output strings. Given the input string, the agent is expected
to generate a program that produces an output that exactly matches the test caseâ€™s output string. The
objective is to generate a program that passes the most number of test cases. To determine if the
agent is able to generate programs that generalize to unseen test cases, we divide the test cases into
public test cases and private test cases, following the terms in Li et al. (2022). The agent can only
3 Published as a conference paper at ICLR 2023
Problem Statement
Given is a string S. Replace every character in S with xand print the result.
Constraints
(1).Sis a string consisting of lowercase English letters.
(2). The length of Sis between 1and100(inclusive).
Input
Input is given from Standard Input in the following format: S
Output
Replace every character in Swithxand print the result.
Sample Test Input
sardine
Sample Test Output
xxxxxxx
Beam Search (Pass Rate: 0.00).
 Sampling + Filtering (Pass Rate:
0.22).
PG-TD (Pass Rate: 1.00).
Figure 1: A code generation example for competitive programming, with the problem description
(top) and the programs generated by baseline algorithms and our PG-TD algorithm (bottom).
access the public test cases during the program generation process, while we use the private test
cases to evaluate the programs it generates.
Transformer models (Li et al., 2022; Hendrycks et al., 2021) have been widely applied for code
generation thanks to their capacity in sequence-to-sequence modeling. In the Transformerâ€™s genera-
tion process, beam search (Graves, 2012) and sampling (Fan et al., 2018; Dabre & Fujita, 2020) are
adopted to generate code sequences. However, these algorithms cannot easily optimize an objective
different from what it is trained on (usually the similarity to the reference solutions). So we cannot
directly use these generation algorithms to generate programs aiming to pass more test cases.
On the other hand, a planning algorithm can directly optimize the pass rate or any desirable pro-
gramming objective. To use a planning algorithm, we follow Bunel et al. (2018); Ellis et al. (2019)
to formulate the code generation problem as a Markov decision process (MDP) (Sutton & Barto,
2018). In this formulation, a statesis the concatenation of the problem description and a partial or
complete program, where a complete program ends with a special terminal token. An actionais a
token in the vocabulary set of the Transformer. There is a special termination action (the terminal
token) that indicates that the agent believes the program is complete. The transition function de-
terministically concatenates a state swith a token a, and an episode ends when the agent takes the
termination action. The reward of statesis the pass rate of the program on the public test cases
whensis a complete program ( i.e.,when the last token of sis the terminal token). The reward of a
partial program is always 0.
There is rich literature on ï¬nding the optimal policy in an MDP. In this paper, we consider a tree
search-based planning algorithm inspired by Monte-Carlo tree search (MCTS), illustrated in Fig. 2.
Intuitively, the tree search algorithm maintains a tree structure where nodes correspond to states and
edges correspond to actions. The algorithm starts from the root node (the initial state) and searches
the state space to ï¬nd terminal states with high rewards. It maintains 1) the number of times each
node is visited and 2) a value function that maintains the maximum reward obtained by starting
in node (or state) sand taking action a. The algorithm would visit and expand nodes with either
higher values (as they lead to higher-quality programs) or with smaller visit numbers (as they are
under-explored). In the following part of this section, we describe how we integrate the tree search
algorithm in the generation process of a Transformer.
4 Published as a conference paper at ICLR 2023
a,,<PD>axa=x,ax=,<PD>axa=x,ax=,generates complete programs using beam searcha,ba,\n
a,,<PD>axa=x,ax=,a,,<PD>axa=x,ax=,suggests next tokensâ€¦SelectionExpansionEvaluationBackpropagation
Transformer 
Evaluate onpublic test casesâ€¦
Figure 2: Illustration of using the Monte Carlo tree search algorithm in the Transformer generation
process for code generation. <PD>stands for problem description.
3.2 P LANNING -GUIDED TRANSFORMER DECODING
Algorithm 1 The PG-TD algorithm.
Require: root: the current state; c: P-UCB exploration pa-
rameter; k: the maximum number of children of any node;
b: the number of beams for Transformer beam search.
1:program dict=DICTIONARY ()
2:fori 1;2; : : : ; max rollouts do
3: node root
4: # Selection
5: whilejnode:childrenj>0do
6: node PUCB SELECT (node:children; c )
7: end while
8: # Expansion
9: next tokens TOP K(node; k )
10: fornext token2next tokens do
11: next state CONCAT (node; next token )
12: Create a node newnode fornext state
13: Add newnode to the children of node
14: end for
15: # Evaluation
16: p BEAM SEARCH (node; b )
17: r GET REWARD (p)
18: program dict[p] =r
19: # Backpropagation
20: Update and the values of node and its ancestors in the
tree with r
21:end for
22:return program in program dict with the highest rewardNow we are ready to answer the question
we asked in the introduction: Can we in-
tegrate a planning algorithm with a pre-
trained code generation Transformer to
generate better programs? We design a
Transformer generation algorithm where
a tree search algorithm is used to perform
lookahead planning. The tree search al-
gorithm alone may not be able to ï¬nd
high-quality codes due to the large search
space. So the conventional Transformer
beam search algorithm and the next-token
probabilities provided by the pre-trained
Transformer are used by the tree search
algorithm to guide the search process.
We provide the pseudocode of our
Planning-Guided Transformer Decoding
algorithm (PG-TD) in Algorithm 1 and
illustrate the whole process in Figure 2.
The PG-TD algorithm follows the same
framework as the standard MCTS algo-
rithm, based on the implementation used
in Silver et al. (2017). Here, we focus on
how the Transformer is used in the tree
search steps. We provide more details of
our algorithm in Sec. D.1.
In the selection step, we follow Silver et al. (2017) and use the P-UCB algorithm to select which
branch of the tree we want to explore. In P-UCB, we weigh the exploration term by the probability of
the next tokens determined by the Transformer. So the tree search selects higher-probability tokens
more often. The selection algorithm is parameterized by an exploration parameter, c, where a higher
cvalue leads to more exploration. We describe the details of P-UCB in Sec. D.1.
In the expansion step, after a node in the tree is selected, we select the possible next tokens and add
the corresponding next states as new nodes to its children list (for succinctness, a node also refers
to the state that it represents). Sampling a random token as in the standard MCTS may very likely
cause a syntax error. So we call TOP Kto get the most likely next tokens, where TOP K(s;k)returns
thekmost likely next tokens starting from s;kis the maximum number of children that any node
may have. The corresponding knext states are the concatenations of the current state with each of
5 Published as a conference paper at ICLR 2023
the next tokens suggested by the Transformer. These next states are added to the children list of the
current node. (Line 9-14)
In the evaluation step, we need to evaluate the selected node . Note thatnode may still be a partial
program. We cannot directly evaluate the quality of a partial program as we do not know how it
will be completed and how many test cases it will pass. Here, we use the Transformer again by
calling the BEAM SEARCH function to generate a complete program from the current node, where
BEAM SEARCH (s;b)generates a sequence using the Transformer beam search algorithm with the
preï¬xsand beam size b. We run the generated program on the public test cases to get its reward,
and set it to be the value of node (Line 16-17). This value is backpropagated up in the tree so that
the values of its ancestors are updated (Line 20).
a,ba,ca,,<PD>axa=x,ax=,a,b,a,b=a,c=a,c,â€¦â€¦â€¦â€¦â€¦a,,<PD>axa=x,ax=,a,b,a,b=a,bIteration tIteration t+1
Figure 3: Illustration for caching in
the PG-TD algorithm. The tree search
part is visualized in black color and the
Transformer beam search part is in red
color.Information sharing between Transformer and tree
search. A keen reader may notice that if we follow the
algorithm described above, there may be a lot of repeated
computations. The key observation is that the Trans-
former beam search algorithm also implicitly builds a tree
structure , which can be used by future iterations of tree
search. In the rest of this section, we describe how we im-
prove the algorithmâ€™s efï¬ciency by sharing information in
the Transformer beam search algorithm with tree search.
Consider the example in Fig. 3, which shows two iter-
ations of PG-TD. In the evaluation step of the t-th iter-
ation, the Transformer beam search algorithm implicitly
builds a tree to ï¬nd the most likely sequences within a
beam (Fig. 3 (left)). Because we only keep bpartial pro-
grams in the beam, it is a tree where only bnodes with the
highest likelihood are expanded at each level (in the illus-
tration,b= 2). Other nodes are dropped and no longer
considered by the beam search algorithm. In the (t+1)-st
iteration, if the tree search algorithm selects â€œ a,â€, such a
state is already visited in the Transformer beam search in
thet-th iteration. When the algorithm needs to ï¬nd the
top-k most likely next tokens, such information is already obtained in the t-th iteration and can be
reused without recomputation. In our implementation, we cache the tree structure generated by the
Transformer beam search algorithm. We call this implementation tree structure caching .
We can also cache the complete programs generated during the PG-TD evaluation step. In the
evaluation step of the t-th iteration (Fig. 3), suppose the greedily-optimal sequence is â€œ a,b=... â€.
In the (t+ 1)-st iteration, to generate a sequence starting with â€œ a,bâ€, the Transformer beam search
algorithm will generate the same sequence â€œ a,b=... â€ as before. (This is not necessarily true
when the beam size is larger than 1. We will clarify this in Sec. D.2.) To improve the efï¬ciency of
BEAM SEARCH , we cache the sequences that have been generated during the evaluation step. In the
evaluation step of future iterations, PG-TD will check if the current state matches the preï¬x of any
sequence that has been generated before, and use the generated sequence directly without calling
the Transformer beam search function. We call this implementation sequence caching . We will
empirically conï¬rm the effectiveness of using these caching methods in the next section.
4 E MPIRICAL EVALUATION
In this section, we empirically examine the effectiveness and efï¬ciency of our PG-TD algorithm
by answering the following questions. Q1: Does PG-TD generate better programs than using
the Transformer beam search algorithm and other competing baseline methods? Is our algorithm
model-agnostic, showing improvement when applied to different Transformer models? Q2: Is the the Transformer beam search algorithm and other competing baseline methods? Is our algorithm
model-agnostic, showing improvement when applied to different Transformer models? Q2: Is the
tree search algorithm an effective planning algorithm in PG-TD? Is it better than other planning
or sampling-based algorithms? Q3: Is PG-TD efï¬cient in terms of the number of times it runs
the Transformer beam search algorithm and also the computation time it consumes? Q4: Are the
caching methods effective in saving computation time? Q5: Can we use the samples generated by
PG-TD in its search process and ï¬netune the Transformer to generate even better solutions?
6 Published as a conference paper at ICLR 2023
Pass Rate (%) Strict Accuracy (%)
APPS Intro. APPS Inter. APPS comp. CodeContests APPS Intro. APPS Inter. APPS comp. CodeContests
APPS GPT-2 Beam Search 11.95 9.55 5.04 5.10 5.50 2.10 1.00 0.00
Sampling+Filtering 25.19 24.13 11.92 20.40 13.80 5.70 2.30 3.64
SMCG-TD 24.10 21.98 10.37 17.47 11.70 5.50 2.10 4.24
PG-TD (c= 4) 26.70 24.92 12.89 24.05 13.10 6.10 3.10 4.85
APPS GPT-Neo Beam Search 14.32 9.80 6.39 5.73 6.70 2.00 2.10 0.00
Sampling+Filtering 27.71 24.85 12.55 25.26 15.50 5.80 3.00 4.24
SMCG-TD 25.09 20.34 9.16 15.44 13.80 5.10 1.80 3.03
PG-TD (c= 4) 29.27 25.69 13.55 26.07 15.50 6.43 3.50 4.85
Table 1: Results of PG-TD and other algorithms. The maximum number of Transformer generations
for all algorithms is 256.
200 400 600
# of Transformer Generations22242628Pass Rate (%)
1000 2000 3000
Computation Time (sec.)22242628Pass Rate (%)
SMCG-TD
Sampling + Filtering
PG-TD (c=2)
PG-TD (c=4)
PG-TD (c=6)
Figure 4: Pass rates of PG-TD and baseline algorithms vs. the number of Transformer generations
(left) and the computation time (middle) on the introductory problems in the APPS test dataset (1000
problems), using the APPS GPT-2 Transformer model.
Datasets and models. Recently, several competitive programming datasets have been made avail-
able for benchmarking code generation algorithms. For each programming problem, they include
the natural language program descriptions, sample solutions, and test cases. We evaluated PG-TD
and the baseline algorithms on some popular benchmark datasets: APPS (Hendrycks et al., 2021)
and CodeContests in AlphaCode (Li et al., 2022). The APPS dataset does not specify public vs. pri-
vate test cases. So we split all the test cases of a program evenly into two sets, where the ï¬rst set is
used as the public test cases for the algorithms to optimize the pass rate, and the second set is used as
the private test cases for evaluating the generated programs. For CodeContests, we use their public
and generated test cases as our public test cases, and their private test cases as our private test cases.
To show that PG-TD is model-agnostic and can be applied to different pre-trained Transformers and
achieve a better performance, we use two popular pre-trained code-generation Transformers in the
literature: GPT-2 and GPT-Neo ï¬netuned on the APPS training dataset (Hendrycks et al., 2021).
Algorithms. We compare PG-TD with the following algorithms. Beam search only uses the Trans-
former beam search algorithm to generate the whole program, without using the test cases. This is
the method used in Hendrycks et al. (2021); Chen et al. (2021a). We use the beam size of 5 in the
Transformer generation function, which is the same choice as in Hendrycks et al. (2021).
We also implemented two baselines that use Transformer to sample programs and ï¬lter them using
the test cases. Sampling + Filtering (S+F) generates a set of programs using the Transformer
sampling algorithm. Once the programs are all generated, it computes the pass rates of all the
programs on the public test cases and returns the program with the highest pass rate. To avoid
generating low-probability tokens that may fail the program completely, we use top-3 sampling, that
is, the Transformer only samples the token that is in the top-3 most-likely tokens in each step. The
sampling temperature is 1. This method is similar to the algorithm in AlphaCode (Li et al., 2022),
except that we did not perform clustering as we generate a much smaller number of programs.
To determine the effectiveness of the tree search algorithm, we considered another baseline, Se-
quential Monte-Carlo-Guided Transformer Decoding (SMCG-TD) , that replaces the tree search
algorithm component with a sequential Monte-Carlo algorithm (Ellis et al., 2019). It is an iterative
algorithm that maintains a population of partial programs. It determines the ï¬tness of a partial pro- algorithm that maintains a population of partial programs. It determines the ï¬tness of a partial pro-
gram using the Transformer in the same way as the evaluation step in PG-TD. Partial programs with
higher ï¬tness scores are more likely to be selected in the next iteration. We leave more details about
the baseline algorithms in Sec D.3.
For PG-TD, we set the maximum number of children of any node ( k) to be 3, and the beam size
(b) to be 1 by default. For the baseline methods, we sample at most 512 programs in Sampling
7 Published as a conference paper at ICLR 2023
Method Time (sec.)
With both caching methods 1312.27
W/ only sequence caching 1430.63
W/ only tree structure caching 1899.17
W/o caching 2206.38
Table 2: Affects of using caching for PG-TD on
the ï¬rst 100 problems on the APPS introductory
dataset, using the APPS GPT-2 (1.5B).Method Pass Rate (%) Strict Acc. (%)
Original 14.32 6.70
FT w/ S+F 15.24 7.90
FT w/ PG-TD 16.54 7.90
Table 3: Performance on APPS introduc-
tory dataset with ï¬netuned (FT) APPS GPT-2
(2.7B), using Beam Search for code genera-
tion.
+ Filtering, and maintain a set of 200 partial programs in each iteration for SMCG-TD. We will
use these parameters for the following experiments unless noted otherwise. The experiments are
conducted on the test set of the APPS dataset (5000 problems) (Hendrycks et al., 2021) and the test
set of CodeContests (165 problems) (Li et al., 2022). We use the same metrics as in Hendrycks et al.
(2021), which are pass rates andstrict accuracies on the private test cases. Speciï¬cally, the pass
rate is the average percentage of the private test cases that the generated programs pass over all the
problems. The strict accuracy is the percentage of the problems where the generated programs pass
all the private test cases.
Effectiveness of PG-TD. To make a fair comparison, we evaluate the best programs found by the
algorithms when they use the same number of Transformer generations . Speciï¬cally, the num-
ber of Transformer generations is the number of function calls of BEAM SEARCH in PG-TD and
SMCG-TD (when no cached sequences are found and used in sequence caching), and the number
of sampling function calls in S+F.
As shown in Table 1, PG-TD consistently outperforms all the other baselines on all the datasets
under the pass rate metric. As we optimize the pass rate, we expect our algorithm to outperform other
baselines under strict accuracy as well. This is almost true except that our algorithm is matched or
outperformed by S+F on the APPS introductory set, mostly due to the fact that this set of programs
is less challenging. The gaps between different algorithms are also small on this set. Overall, these
results conï¬rm that our algorithm indeed generates programs that pass more test cases than the
baseline methods (answering Q1). Speciï¬cally, S+F and SMCG-TD both use test cases to ï¬lter
programs generated by the Transformer, while their performance is overall outperformed by PG-
TD. So the tree search-based planning algorithm is indeed powerful enough and can be effectively
integrated with Transformer (answering Q2). We also report the performance of PG-TD and S+F
under the n@kandpass @kmetrics (Li et al., 2022) in Sec. A (Table 6).
Efï¬ciency of PG-TD. To show PG-TDâ€™s efï¬ciency, we report the pass rates of the best programs
found by the algorithms using the same computation time (Fig. 4 (right)). The experiments are run
on the introductory problems in the APPS test set. Since one may implement these algorithms dif-
ferently (possibly using parallelization), we also report the results using the number of Transformer
generations as a budget (Fig. 4 (left)).
For PG-TD, we set k= 3;b= 1and vary the P-UCB exploration parameter cto be 2, 4, and 6. We
see that PG-TD with c= 4 has the best performance, while setting c= 2 tends to under-explore
and settingc= 6over-explores. With the same computational budget, S+F generates programs with
lower pass rates (answering Q3). This conï¬rms our observation that S+F, like the algorithm used
in AlphaCode (Li et al., 2022), generates solutions only according to the Transformerâ€™s generation
probabilities, without taking their pass rates into consideration until all the programs are generated.
PG-TD actively considers the pass rates of the generated programs during the generation process,
which achieves better efï¬ciency. On the other hand, SMCG-TD also uses the Transformer and PG-TD actively considers the pass rates of the generated programs during the generation process,
which achieves better efï¬ciency. On the other hand, SMCG-TD also uses the Transformer and
public test cases to guide the generation process. However, due to its sampling nature, it cannot do
multi-step lookahead search as in PG-TD, which results in worse performance. We leave additional
results of varying k;bfor PG-TD and varying temperatures for S+F in Sec. A.
Effectiveness of caching. In terms of the design choices of tree structure caching and sequence
caching, we performed ablative studies to verify their efï¬ciencies. In Table 2, we compare versions
of PG-TD with and without tree structure caching and sequence caching. As we expect, without
sequence caching, the algorithm needs to regenerate whole sequences, ending up consuming much
more time. Without tree structure caching, the algorithm is slightly slower as it needs to call Trans-
former to get the most likely next tokens (answering Q4).
8 Published as a conference paper at ICLR 2023
Finetuning transformer with PG-TD-generated samples. Since we are able to generate solutions
with high pass rates using our PG-TD algorithm, can we use these generated solutions to ï¬netune
the code generation Transformers to further improve their performance? This may effectively solve
the problem that high-quality human-written programs that can be used to train the code generation
Transformers are scarcely available. Concretely, we ï¬rst run PG-TD on the training set of APPS.
We then add the generated solutions with pass rates larger than 80% to the APPS sample solution
set, and use the augmented solution set to ï¬netune the GPT-2 (2.7B) model. With the ï¬netuned
Transformer model, we run beam search to generate solutions on the test set to see if it has a better
performance. We use the ï¬rst 500 problems in the interview-level problems in APPS test set for
validation and the introductory-level problems in APPS test set for testing. The results are reported
in Table 3. After ï¬netuning with PG-TD-generated solutions, we see improvement in both pass rate
and strict accuracy. More details are in Sec. D.4.
MethodsCode#Comment""Pass""length number rate
Default 248.42 0.68 23.14
Length Penalty 190.73 - 22.82
Comment Encouragement - 3.11 21.65
Table 4: Performance of controllable code generation.
Code length denotes the length of the generated code
string and comment number denotes the number of code
lines that contains comments.Optimizing other code generation
objectives. Beyond the pass rate,
we can make the algorithm versatile
by using different reward functions.
We consider two new objectives, code
length penalty and comment encour-
agement . As shown in Table 4, the
code length penalty reward function
makes the model generate more con-
cise codes; the comment encourage-
ment reward function encourages mod-
els to generate codes with more comments. Both objectives still achieve reasonable pass rates on
the public test cases. We provide qualitative examples and more details of the reward functions in
Sec. C of the appendix.
Using automatically-generated test cases. The datasets we use in this paper both contain test
cases that can be used to compute rewards for PG-TD. However, in reality, human-speciï¬ed test
cases are not always available. Recently, Chen et al. (2022) observe that Transformer pre-trained
on code generation can also generate useful test cases by adding an assert keyword at the end of
the prompt. We follow the prompt design in Chen et al. (2022) to automatically generate test cases
and run our PG-TD algorithm using the automatically-generated test cases. Empirically, we conï¬rm
that compared with beam search, PG-TD still has a higher strict accuracy by using automatically-
generated test cases to verify the generated programs. We provide the details of the method and the
experiments are in Sec. B.
5 D ISCUSSION AND CONCLUSION
In summary, we proposed a novel algorithm that uses the power of a pre-trained Transformer and
a tree search algorithm inspired by Monte-Carlo tree search. We evaluate our algorithm and em-
pirically show that our algorithm generates programs of higher quality compared with competing
baseline algorithms in different settings. We also design model structure-speciï¬c caching mecha-
nisms which contribute to saving computational expenses. We show that our algorithm is versatile
and can generate codes under objectives other than the pass rate without ï¬netuning the Transformer.
We hope our work can inspire more ways of incorporating planning algorithms into the Transformer
generation process for code generation or other problems.
One limitation of our algorithm is its reliance on test cases, although we ï¬nd that even a small
number of test cases can help ï¬nd better solutions (Sec. A, Table 7). To address this limitation, we
provided results to show that our algorithm can take advantage of automatically-generated test cases provided results to show that our algorithm can take advantage of automatically-generated test cases
(Sec. B). Our algorithm is also more computationally expensive than the pure Transformer beam
search algorithm since ours needs to run the beam search algorithm multiple times within the tree
search algorithm. In the future, we consider improving the frameworkâ€™s performance by using a
value function to estimate the programsâ€™ pass rates, similar to the evaluation function in Silver et al.
(2016) for mastering the game of Go. We can learn a neural state representation for partial programs
as in Chen et al. (2018). We also consider using parallel tree search algorithms (Chaslot et al., 2008)
for the evaluation step to parallelize the computation for different states.
9 Published as a conference paper at ICLR 2023
Acknowledgements. This work was supported by the MIT-IBM Watson AI Lab, DARPA MCS,
and gift funding from MERL, Cisco, and Amazon. We would also like to thank the computation
support from AiMOS, a server cluster for the IBM Research AI Hardware Center.
REFERENCES
Wasi Ahmad, Saikat Chakraborty, Baishakhi Ray, and Kai-Wei Chang. Uniï¬ed pre-training for pro-
gram understanding and generation. In Proceedings of the 2021 Conference of the North American
Chapter of the Association for Computational Linguistics: Human Language Technologies , pp.
2655â€“2668, Online, June 2021. Association for Computational Linguistics. 1
Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan,
Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, and Charles Sutton. Program Synthesis with
Large Language Models. arXiv:2108.07732 [cs] , August 2021. URL http://arxiv.org/
abs/2108.07732 . arXiv: 2108.07732. 2
Rudy Bunel, Matthew Hausknecht, Jacob Devlin, Rishabh Singh, and Pushmeet Kohli. Leveraging
Grammar and Reinforcement Learning for Neural Program Synthesis. ICLR , May 2018. URL
http://arxiv.org/abs/1805.04276 . arXiv: 1805.04276. 3, 4
Antoine Chafï¬n, Vincent Claveau, and Ewa Kijak. Ppl-mcts: Constrained textual generation through
discriminator-guided mcts decoding. In Proceedings of the 2022 Conference of the North Amer-
ican Chapter of the Association for Computational Linguistics: Human Language Technologies ,
pp. 2953â€“2967, 2022. 3
Guillaume MJ-B Chaslot, Mark HM Winands, and HJVD Herik. Parallel monte-carlo tree search.
InInternational Conference on Computers and Games , pp. 60â€“71. Springer, 2008. 9
Bei Chen, Fengji Zhang, Anh Nguyen, Daoguang Zan, Zeqi Lin, Jian-Guang Lou, and Weizhu
Chen. CodeT: Code Generation with Generated Tests, July 2022. URL http://arxiv.org/
abs/2207.10397 . arXiv:2207.10397 [cs]. 9, 17
Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared
Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri,
Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan,
Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian,
Clemens Winter, Philippe Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fo-
tios Chantzis, Elizabeth Barnes, Ariel Herbert-V oss, William Hebgen Guss, Alex Nichol, Alex
Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders,
Christopher Hesse, Andrew N. Carr, Jan Leike, Josh Achiam, Vedant Misra, Evan Morikawa,
Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer, Peter Welinder,
Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, and Wojciech Zaremba. Eval-
uating Large Language Models Trained on Code. arXiv:2107.03374 [cs] , July 2021a. URL
http://arxiv.org/abs/2107.03374 . arXiv: 2107.03374. 1, 2, 7, 15, 17
Xinyun Chen, Chang Liu, and Dawn Song. Execution-guided neural program synthesis. In Interna-
tional Conference on Learning Representations , 2018. 3, 9
Xinyun Chen, Dawn Song, and Yuandong Tian. Latent execution for neural program synthesis
beyond domain-speciï¬c languages. Advances in Neural Information Processing Systems , 2021b.
3
Raj Dabre and Atsushi Fujita. Softmax tempering for training neural machine translation models.
arXiv , 2020. 1, 4
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: Pre-training of deep
bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of
the North American Chapter of the Association for Computational Linguistics: Human Language
Technologies, Volume 1 (Long and Short Papers) , pp. 4171â€“4186, Minneapolis, Minnesota, June
2019. Association for Computational Linguistics. doi: 10.18653/v1/N19-1423. URL https:
//aclanthology.org/N19-1423 . 2
10 Published as a conference paper at ICLR 2023
Kevin Ellis, Catherine Wong, Maxwell Nye, Mathias Sabl Â´e-Meyer, Lucas Morales, Luke Hewitt,
Luc Cary, Armando Solar-Lezama, and Joshua B Tenenbaum. Dreamcoder: Bootstrapping in-
ductive program synthesis with wake-sleep library learning. In Proceedings of the 42nd ACM
SIGPLAN International Conference on Programming Language Design and Implementation , pp.
835â€“850, 2021. 2
Kevin M. Ellis, Maxwell Nye, Yewen Pu, Felix Sosa, Joshua Tenenbaum, and Armando Solar-
Lezama. Write, execute, assess: Program synthesis with a repl. Neural Information Processing
Systems , 2019. 3, 4, 7
Angela Fan, Mike Lewis, and Yann Dauphin. Hierarchical neural story generation. In Proceedings
of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long
Papers) , pp. 889â€“898, 2018. 1, 3, 4
Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou,
Bing Qin, Ting Liu, Daxin Jiang, et al. Codebert: A pre-trained model for programming and
natural languages. In Findings of the Association for Computational Linguistics: EMNLP 2020 ,
pp. 1536â€“1547, 2020. 2
Sylvain Gelly and David Silver. Monte-carlo tree search and rapid action value estimation in com-
puter go. Artiï¬cial Intelligence , 175(11):1856â€“1875, 2011. 3
Alex Graves. Sequence transduction with recurrent neural networks. In International Conference
on Machine Learning: Representation Learning Workshop , 2012. 3, 4
Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, LIU Shujie, Long Zhou, Nan Duan,
Alexey Svyatkovskiy, Shengyu Fu, et al. Graphcodebert: Pre-training code representations with
data ï¬‚ow. In International Conference on Learning Representations , 2020. 2
Kavi Gupta, Peter Ebert Christensen, Xinyun Chen, and Dawn Song. Synthesize, execute and debug:
Learning to repair for neural program synthesis. Advances in Neural Information Processing
Systems , 2020. 3
Peter E Hart, Nils J Nilsson, and Bertram Raphael. A formal basis for the heuristic determination
of minimum cost paths. IEEE transactions on Systems Science and Cybernetics , 4(2):100â€“107,
1968. 3
Dan Hendrycks, Steven Basart, Saurav Kadavath, Mantas Mazeika, Akul Arora, Ethan Guo, Collin
Burns, Samir Puranik, Horace He, Dawn Song, and Jacob Steinhardt. Measuring coding challenge
competence with APPS. NeurIPS , 2021. 1, 4, 7, 8, 14, 17
Aditya Kanade, Petros Maniatis, Gogul Balakrishnan, and Kensen Shi. Learning and evaluating
contextual embedding of source code. In International Conference on Machine Learning , pp.
5110â€“5121. PMLR, 2020. 2
Levente Kocsis and Csaba Szepesv Â´ari. Bandit based monte-carlo planning. In European conference
on machine learning , pp. 282â€“293. Springer, 2006. 21
Hung Le, Yue Wang, Akhilesh Deepak Gotmare, Silvio Savarese, and Steven C. H. Hoi. CodeRL:
Mastering Code Generation through Pretrained Models and Deep Reinforcement Learning.
arXiv, July 2022. doi: 10.48550/arXiv.2207.01780. URL http://arxiv.org/abs/2207.
01780 . arXiv:2207.01780 [cs]. 3, 24
RÂ´emi Leblond, Jean-Baptiste Alayrac, Laurent Sifre, Miruna Pislar, Jean-Baptiste Lespiau, Ioannis
Antonoglou, Karen Simonyan, and Oriol Vinyals. Machine translation decoding beyond beam
search. arXiv preprint arXiv:2104.05336 , 2021. 3
Yujia Li, David Choi, Junyoung Chung, Nate Kushman, Julian Schrittwieser, R Â´emi Leblond, Tom
Eccles, James Keeling, Felix Gimeno, and Agustin Dal Lago. Competition-Level Code Genera-
tion with AlphaCode. arXiv preprint arXiv:2203.07814 , 2022. 1, 2, 3, 4, 7, 8, 14, 17
Jinsuk Lim and Shin Yoo. Field report: Applying monte carlo tree search for program synthesis. In
International Symposium on Search Based Software Engineering , pp. 304â€“310. Springer, 2016. 3
11 Published as a conference paper at ICLR 2023
Ximing Lu, Sean Welleck, Peter West, Liwei Jiang, Jungo Kasai, Daniel Khashabi, Ronan Le
Bras, Lianhui Qin, Youngjae Yu, Rowan Zellers, Noah A. Smith, and Yejin Choi. NeuroLogic
A*esque Decoding: Constrained Text Generation with Lookahead Heuristics, December 2021.
URLhttp://arxiv.org/abs/2112.08726 . arXiv:2112.08726 [cs]. 3
Nadia Matulewicz. Inductive program synthesis through using monte carlo tree search guided by a
heuristic-based loss function. 2022. 3
Glenford J Myers. The art of software testing. 1979. 3
Maxwell Nye, Armando Solar-Lezama, Josh Tenenbaum, and Brenden M Lake. Learning compo-
sitional rules via neural program synthesis. Advances in Neural Information Processing Systems ,
33:10832â€“10842, 2020. 2
Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language
models are unsupervised multitask learners. 2019. 2, 28
Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi
Zhou, Wei Li, and Peter J. Liu. Exploring the limits of transfer learning with a uniï¬ed text-to-
text transformer. Journal of Machine Learning Research , 2020. URL http://jmlr.org/
papers/v21/20-074.html . 2
Baptiste Roziere, Marie-Anne Lachaux, Lowik Chanussot, and Guillaume Lample. Unsupervised
translation of programming languages. Advances in Neural Information Processing Systems , 33,
2020. 2
Baptiste Roziere, Jie M Zhang, Francois Charton, Mark Harman, Gabriel Synnaeve, and Guillaume
Lample. Leveraging automated unit tests for unsupervised code translation. In International
Conference on Learning Representations , 2022. 1, 3
Thomas Scialom, Paul-Alexis Dray, Jacopo Staiano, Sylvain Lamprier, and Benjamin Piwowarski.
To beam or not to beam: That is a question of cooperation for language gans. Advances in neural
information processing systems , 34:26585â€“26597, 2021. 3
David Silver, Aja Huang, Chris J. Maddison, Arthur Guez, Laurent Sifre, George Van Den Driess-
che, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, and Marc Lanctot. Mas-
tering the game of Go with deep neural networks and tree search. Nature , 529(7587):484, 2016.
Publisher: Nature Publishing Group. 3, 9
David Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur Guez,
Marc Lanctot, Laurent Sifre, Dharshan Kumaran, Thore Graepel, Timothy Lillicrap, Karen Si-
monyan, and Demis Hassabis. Mastering Chess and Shogi by Self-Play with a General Reinforce-
ment Learning Algorithm, December 2017. URL http://arxiv.org/abs/1712.01815 .
arXiv:1712.01815 [cs]. 5, 21
Riley Simmons-Edler, Anders Miltner, and Sebastian Seung. Program synthesis through reinforce-
ment learning guided tree search. arXiv preprint arXiv:1806.02932 , 2018. 3
Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction . MIT Press,
October 2018. ISBN 978-0-262-35270-3. 4
Michele Tufano, Dawn Drain, Alexey Svyatkovskiy, Shao Kun Deng, and Neel Sundaresan. Unit
test case generation with transformers and focal context. arXiv , 2020a. 3
Michele Tufano, Dawn Drain, Alexey Svyatkovskiy, and Neel Sundaresan. Generating accurate
assert statements for unit test cases using pretrained transformers. arXiv , 2020b. 3
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
Åukasz Kaiser, and Illia Polosukhin. Attention is all you need. Advances in neural informa-
tion processing systems , 2017a. 1, 3
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez,
Lukasz Kaiser, and Illia Polosukhin. Attention Is All You Need. arXiv:1706.03762 [cs] , De-
cember 2017b. URL http://arxiv.org/abs/1706.03762 . arXiv: 1706.03762. 2
12 Published as a conference paper at ICLR 2023
Yue Wang, Weishi Wang, Shaï¬q Joty, and Steven C.H. Hoi. CodeT5: Identiï¬er-aware Uniï¬ed
Pre-trained Encoder-Decoder Models for Code Understanding and Generation. In Proceedings
of the 2021 Conference on Empirical Methods in Natural Language Processing , pp. 8696â€“8708,
Online and Punta Cana, Dominican Republic, November 2021. Association for Computational
Linguistics. doi: 10.18653/v1/2021.emnlp-main.685. URL https://aclanthology.org/
2021.emnlp-main.685 . 1, 2
Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi,
Pierric Cistac, Tim Rault, R Â´emi Louf, and Morgan Funtowicz. Huggingfaceâ€™s transformers: State-
of-the-art natural language processing. arXiv preprint arXiv:1910.03771 , 2019. 17
Yifan Xu, Lu Dai, Udaikaran Singh, Kening Zhang, and Zhuowen Tu. Neural program synthesis by
self-learning. arXiv preprint arXiv:1910.05865 , 2019a. 3
Yifan Xu, Lu Dai, Udaikaran Singh, Kening Zhang, and Zhuowen Tu. Neural Program Synthesis
By Self-Learning. October 2019b. doi: 10.48550/arXiv.1910.05865. URL https://arxiv.
org/abs/1910.05865v1 . 3
13 Published as a conference paper at ICLR 2023
APPENDIX
In this appendix, we supplement the main paper by providing more thorough empirical evaluations to
back up our claims and more detailed descriptions of the algorithms to help readers better understand
our paper.
This appendix is organized as follows.
â€¢ In Sec. A, we provide more comprehensive results of our algorithm and the baseline algorithms.
We also include the license information of the datasets we use.
â€¢ In Sec. B, we consider the scenario where test cases are not provided. We evaluate our PG-TD
algorithm using automatically-generated test cases.
â€¢ In Sec. C, we provide empirical evidence for our claims in the discussion section that our
algorithm is versatile and can be used to optimize different code generation objectives other
than the pass rate. We consider the objectives of generating concise codes and generating
codes with more comments.
â€¢ In Sec. D, we provide more details on the components in PG-TD as well as the baseline algo-
rithms.
â€¢ In Sec. E, we illustrate more examples of the codes generated by our PG-TD algorithm and the
baseline algorithms.
â€¢ In Sec. F, we discuss more on the advantages and the potential negative social impacts of our
algorithm.
A E MPIRICAL EVALUATION
We reported the performance of our algorithm and other baselines on the whole APPS dataset
(Hendrycks et al., 2021) and CodeContests (Li et al., 2022). The APPS test dataset contains coding
problems at three levels: introductory (1000 problems), interview (3000 problems), and competition
(1000 problems).
In addition to our results in Table 1 in the main paper, Table 5 shows the results where the budget
of the number of Transformer generations is 512. As we expect, with a larger number of generated
programs, the gap between PG-TD and the rest is smaller. Sampling + Filtering has a better strict
accuracy than our algorithm on some subsets of datasets. We also experimented with other parameter
settings of PG-TD. In Fig. 5 and 6, we vary the beam size ( b= 1;3;5) underc= 2;4. In Fig. 7, we
vary the maximum number of children of any node ( k= 2;3;4).
Although one may expect expanding the width of the tree (increasing k) can help ï¬nd better pro-
grams, considering generating less-likely tokens suggested by the Transformer may not contribute
to ï¬nding better programs. In fact, it wastes the budget of the number of Transformer generations
and the computation time by considering less likely tokens. On the other hand, increasing the beam
size (b) does help improve the pass rate when the number of rollouts (corresponding to the number
of Transformer generations) is small. However, increasing the beam size under a larger number of
rollouts does not always increase the pass rate (Fig. 7), which may be caused by an overï¬tting issue.
Increasingbalso costs more computation time even though sequence caching is used.
In Fig. 8, we use different temperatures in the Sampling + Filtering algorithm ( t= 0:6;0:8;1),
conï¬rming that our choice of t= 1in the experiments in the main paper does have the best perfor-
mance.
n@k and pass@k metrics. We also report the performance of PG-TD and S+F under the n@kand
pass @kmetrics (Li et al., 2022). Given a problem, each algorithm is asked to generate kprograms
and submit nprograms for evaluation (they submit the nprograms with the highest reward on the
public test cases). n@kis the proportion of the problems where any of the nsubmitted programs
passes all the private test cases. pass @kis the proportion of the problems where any of the k
generated programs passes all the private test cases (effectively k@k). For PG-TD, the ksamples are
the complete programs found in the ï¬rst krollouts. The results are reported in Table 6, evaluated on
the APPS introductory problems. We observe that for smaller norkvalues, PG-TD ï¬nds programs
14 Published as a conference paper at ICLR 2023
Pass Rate (%) Strict Accuracy (%)
APPS Intro. APPS Inter. APPS comp. CodeContests APPS Intro. APPS Inter. APPS comp. CodeContests
APPS GPT-2 Beam Search 11.95 9.55 5.04 5.10 5.50 2.10 1.00 0.00
Sampling+Filtering 27.33 25.75 12.09 21.57 14.80 6.97 2.40 4.24
SMCG-TD 24.40 22.18 10.60 17.72 11.80 5.87 2.50 4.24
PG-TD (c= 4) 28.27 26.13 13.74 25.91 14.40 6.63 4.00 4.85
APPS GPT-Neo Beam Search 14.32 9.80 6.39 5.73 6.70 2.00 2.10 0.00
Sampling+Filtering 30.23 26.58 13.12 26.57 16.70 7.40 3.10 4.24
SMCG-TD 24.77 20.52 9.19 15.42 14.00 5.20 1.70 2.42
PG-TD (c= 4) 30.38 26.89 13.28 27.10 16.70 6.90 3.20 5.45
Table 5: Results of PG-TD and other algorithms. The maximum number of Transformer generations
for all algorithms is 512.
1@10 1@50 1@100
PG-TD (c= 4) 8.1 10.2 11.6
S+F 6.5 9.7 11.4
5@10 5@50 5@100
PG-TD (c= 4) 12.5 14.9 16.2
S+F 11.9 14.6 18.2
pass@10 pass@50 pass@100
PG-TD (c= 4) 14.7 23.7 27.3
S+F 14.7 23.2 28.3
Table 6: n@kandpass @kresults of PG-TD and Sampling, evaluated on the APPS introductory
problems.
Pass Rate Strict Accuracy
0 public test cases (the beam search baseline) 13.61 4.2
1 public test case 23.27 7.4
3 public test cases 33.02 13.4
5 public test cases 32.99 14.2
Half of all test cases (10.44 public test cases on average) 37.71 14.8
Table 7: The performance of PG-TD using different numbers of public test cases, evaluated on the
ï¬rst 500 APPS introductory problems.
that are more likely to pass all the private test cases. When more programs are generated ( k) or more
programs are submitted for evaluation ( n), the performance of PG-TD is matched or outperformed
by S+F.
Using different numbers of public test cases. On the APPS dataset, we split all the test cases
evenly into public test cases and private test cases. To investigate how many test cases are enough
for PG-TD to achieve a satisfactory performance, we consider using 1, 3, and 5 public test cases and
using the rest of the test cases as private test cases. The results are reported in Table 7, evaluated on
the ï¬rst 500 APPS introductory problems. We observe that even with a small number of public test
cases, PG-TD is able to ï¬nd programs with higher a pass rate and strict accuracy than beam search.
This also suggests that the Transformer can serve as a regularizer in code generation. With a small
number of public test cases, PG-TD still generates programs similar to human-written programs
without overï¬tting the pubic test cases.
Results on Codex. To evaluate the effectiveness of our algorithms on more powerful code-
generation Transformers, we run both beam search and PG-TD algorithms using Codex (Chen et al.,
2021a) as the backbone. We follow the â€œbest practicesâ€ provided in the Codex guide to put the
problem description into a block comment in the beginning, and ask Codex to complete the rest.
The prompt looks like the following.
""""""
Python 3
{problem description}
""""""
15 Published as a conference paper at ICLR 2023
100 200 300 400 500
# of Transformer Generations22242628Pass Rate (%)
1000 2000 3000
Computation Time (sec.)22242628Pass Rate (%)
SMCG-TD
Sampling + Filtering
PG-TD (b=1)
PG-TD (b=3)
PG-TD (b=5)
Figure 5: Results of PG-TD ( c= 2) on the APPS introductory dataset, using the APPS GPT-2
Transformer model.
200 400
# of Transformer Generations22242628Pass Rate (%)
1000 2000 3000
Computation Time (sec.)22242628Pass Rate (%)
SMCG-TD
Sampling + Filtering
PG-TD (b=1)
PG-TD (b=3)
PG-TD (b=5)
Figure 6: Results of PG-TD ( c= 4) on the APPS introductory dataset, using the APPS GPT-2
Transformer model.
200 400
# of Transformer Generations22242628Pass Rate (%)
500 1000 1500 2000
Computation Time (sec.)22242628Pass Rate (%)
PG-TD (k=2)
PG-TD (k=3)
PG-TD (k=4)
Figure 7: Results of PG-TD ( c= 4) with different kon the APPS introductory dataset, using the
APPS GPT-2 Transformer model..
100 200 300 400 500
# of Transformer Generations222426Pass Rate (%)
500 1000 1500 2000
Computation Time (sec.)222426Pass Rate (%)
S + F (t=0.6)
S + F (t=0.8)
S + F (t=1)
Figure 8: Results of Sampling + Filtering with different temperatures on the APPS introductory
dataset, using the APPS GPT-2 Transformer model.
As we expect, PG-TD helps Codex generate better codes (Table 8). This further validates our claim
that our method is model-agnostic and can help a pre-trained code generation Transformer generate
better codes. Due to the limits of the OpenAI APIs, we are only able to test the algorithms on a
subset of data. We also show a concrete example where PG-TD outperforms beam search in the
following sections in Fig. 16.
Using sampling-based tree search. We could use a sampling approach in the evaluation step of
PG-TD instead of using beam search, which would be a more faithful implementation of MCTS.
We experimented with the two versions of PG-TD and ï¬nd that overall using beam search indeed
has a better performance (Table 9). The gap could be caused by that we only do sampling once
to evaluate any node. We could estimate the value of nodes more accurately by sampling multiple
times. However, it would make our algorithm more computationally expensive.
16 Published as a conference paper at ICLR 2023
Model Decoding Algorithm Pass Rate (%) Strict Accuracy (%)
APPS GPT-2 (1.5B) Beam Search 11.65 2
APPS GPT-2 (1.5B) PG-TD 36.42 6
Codex (code-davinci-002) Beam Search 33.26 14
Codex (code-davinci-002) PG-TD 59.14 31
Table 8: Comparison between using different Transformers (APPS and Codex) as the backbone for
code generation, evaluated on the ï¬rst 100 APPS introductory problems.
Decoding Algorithm Pass Rate (%) Strict Accuracy (%)
# of Transformer Generations 128 256 512 128 256 512
PG-TD using Beam Search 36.19 37.71 38.57 14.4 14.8 15.6
PG-TD using Sampling 33.95 35.67 37.87 13.8 15.4 17.2
Table 9: PG-TD using beam search vs. sampling in the evaluation step, evaluated on the ï¬rst 500
APPS introductory problems.
Compilation Error (%) Runtime Error (%)
APPS GPT-2 (1.5B), Beam Search 5.58 32.95
APPS GPT-2 (1.5B), Sampling + Filtering 4.68 27.38
APPS GPT-2 (1.5B), PG-TD 1.93 19.5
Table 10: Failure case analysis. The percentages are averaged over the APPS introductory dataset.
Strict Accuracy (%)
Beam Search 26.82
PG-TD (using auto-generated test cases) 74.53
Table 11: Comparison between beam search and TG-PD using automatically-generated test cases,
using the Codex model and evaluated on the HumanEval dataset.
Failure mode analysis. In Table 10, we report the average percentages of test cases where com-
pilation errors and runtime errors occur. We use the error analysis utility provided in the original
APPS codebase. As we expect, PG-TD executes the generated programs and ï¬nds the ones with
higher pass rates, so it dramatically reduces the percentage of both types of errors.
Assets and licenses. Our experiments are run on machines with two Intel(R) Xeon(R) Gold 6258R
CPUs (@ 2.70GHz), and one V100-SXM2 GPU. The APPS dataset (Hendrycks et al., 2021) is
released under MIT License2. The CodeContests dataset (Li et al., 2022) is released under Apache
License 2.03. The Huggingface Transformer (Wolf et al., 2019) is released under Apache License
2.04.
B U SING AUTOMATICALLY -GENERATED TESTCASES
When human-speciï¬ed test cases are not available, our algorithm can still rely on automatically-
generated test cases. We ï¬rst follow Chen et al. (2022) to use the Codex model and evaluate the
code generation algorithms on the HumanEval dataset (Chen et al., 2021a). We adopt the same
procedure as Chen et al. (2022) to automatically generate test cases. Concretely, we use a prompt
that includes the natural language description of the problem and an assert statement at the end
of the prompt. We also removed the example input, output pairs in the problem description to avoid
2https://github.com/hendrycks/apps/blob/main/LICENSE
3https://github.com/deepmind/code_contests/blob/main/LICENSE
4https://github.com/huggingface/transformers/blob/main/LICENSE
17 Published as a conference paper at ICLR 2023
the Transformer from directly copying the test cases in the problem description. The following is an
example of the prompt for test case generation.
from typing import List
def has_close_elements(numbers: List[float], threshold: float) -> bool:
"""""" Check if in given list of numbers, are any two numbers closer to
each other than given threshold.
""""""
pass
# check the correctness of has_close_elements
def check(candidate):
assert candidate
Does Codex generate correct test cases? In the HumanEval dataset, the generated solutions are
evaluated by the test script by calling the check function. So we use the strict accuracy (pass@1)
metric that counts the percentage of the problems where the generated solutions pass the check
function. To evaluate the quality of the automatically-generated test cases, we compute the strict
accuracies of the sample solutions (correct solutions written by human programmers) on these test
cases. Clearly, the strict accuracies of the sample solutions on the ground-truth test cases should
be 100%. We evaluate the sample solutions on the automatically-generated test cases and ï¬nd the
corresponding strict accuracy is 72.56%, which conï¬rms that the automatically-generated test cases
are mostly correct.
Can PG-TD take advantage of the automatically-generated test cases? We report the average
strict accuracy of the generated programs on a subset of HumanEval problems in Table 11. We
conï¬rm that the strict accuracy of PG-TD is higher as it uses high-quality automatically-generated
test cases to verify the generated programs.
C P LANNING FOR OTHER CODE GENERATION OBJECTIVES
Besides the default reward function that optimizes the pass rate, we show the versatility of the pro-
posed algorithm by setting two new objectives, code length penalty and comment encouragement.
Code length penalty . We make the planner generate more concise codes by using the following
reward function
Rlength =p+1e"," This paper presents a novel algorithm, Planning-Guided Transformer Decoding (PG-TD), which uses a planning algorithm to guide a pre-trained code generation Transformer to generate better codes. It is evaluated on competitive programming benchmarks and shows improved results compared to baseline methods, as well as enabling controllable code generation. The paper also discusses related works on using unit tests, reinforcement learning, and planning algorithms for code generation, as well as planning algorithms for natural language generation. However, this could also make it easier to develop malware, so a separate module may be needed to screen natural language descriptions and reject requests that could lead to harmful codes."
37," Published as a conference paper at ICLR 2023
TANGOS: R EGULARIZING TABULAR NEURAL NET-
WORKS THROUGH GRADIENT ORTHOGONALIZATION
AND SPECIALIZATION
Alan Jeffares
University of Cambridge
aj659@cam.ac.ukTennison Liu
University of Cambridge
tl522@cam.ac.ukJonathan CrabbÃ©
University of Cambridge
jc2133@cam.ac.uk
Fergus Imrie
University of California, Los Angeles
imrie@ucla.eduMihaela van der Schaar
University of Cambridge
Alan Turing Institute
mv472@cam.ac.uk
ABSTRACT
Despite their success with unstructured data, deep neural networks are not yet a
panacea for structured tabular data. In the tabular domain, their efï¬ciency crucially
relies on various forms of regularization to prevent overï¬tting and provide strong
generalization performance. Existing regularization techniques include broad
modelling decisions such as choice of architecture, loss functions, and optimization
methods. In this work, we introduce Tabular Neural Gradient Orthogonalization
and Specialization ( TANGOS ), a novel framework for regularization in the tabular
setting built on latent unit attributions. The gradient attribution of an activation
with respect to a given input feature suggests how the neuron attends to that feature,
and is often employed to interpret the predictions of deep networks. In TANGOS ,
we take a different approach and incorporate neuron attributions directly into
training to encourage orthogonalization and specialization of latent attributions
in a fully-connected network. Our regularizer encourages neurons to focus on
sparse, non-overlapping input features and results in a set of diverse and specialized
latent units. In the tabular domain, we demonstrate that our approach can lead to
improved out-of-sample generalization performance, outperforming other popular
regularization methods. We provide insight into whyour regularizer is effective and
demonstrate that TANGOS can be applied jointly with existing methods to achieve
even greater generalization performance.
1 I NTRODUCTION
Despite its relative under-representation in deep learning research, tabular data is ubiquitous in
many salient application areas including medicine, ï¬nance, climate science, and economics. Beyond
raw performance gains, deep learning provides a number of promising advantages over non-neural
methods including multi-modal learning, meta-learning, and certain interpretability methods, which
we expand upon in depth in Appendix C. Additionally, it is a domain in which general-purpose
regularizers are of particular importance. Unlike areas such as computer vision or natural language
processing, architectures for tabular data generally do not exploit the inherent structure in the input
features (i.e. locality in images and sequential text, respectively) and lack the resulting inductive
biases in their design. Consequentially, improvement over non-neural ensemble methods has been
less pervasive. Regularization methods that implicitly or explicitly encode inductive biases thus play
a more signiï¬cant role. Furthermore, adapting successful strategies from the ensemble literature
to neural networks may provide a path to success in the tabular domain (e.g. Wen et al., 2020).
Recent work in Kadra et al. (2021) has demonstrated that suitable regularization is essential to
Equal contribution
1arXiv:2303.05506v1  [cs.LG]  9 Mar 2023 Published as a conference paper at ICLR 2023
Figure 1: TANGOS encourages specialization and orthogonalization. TANGOS penalizes neuron attribu-
tions during training. Here, indicates strong positive attribution and indicates strong negative attribution,
while interpolating colors reï¬‚ect weaker attributions. Neurons are regularized to be specialized (attend to sparser
features) and orthogonal (attend to non-overlapping features).
outperforming such methods and, furthermore, a balanced cocktail of regularizers results in neural
network superiority.
Regularization methods employed in practice can be categorized into those that prevent overï¬tting
through data augmentation (Krizhevsky et al., 2012; Zhang et al., 2018), network architecture choices
(Hinton et al., 2012; Ioffe & Szegedy, 2015), and penalty terms that explicitly inï¬‚uence parameter
learning (Hoerl & Kennard, 1970; Tibshirani, 1996; Jin et al., 2020), to name just a few. While all
such methods are uniï¬ed in attempting to improve out-of-sample generalization, this is often achieved
in vastly different ways. For example, L1andL2penalties favor sparsity and shrinkage, respectively,
on model weights, thus choosing more parsimonious solutions. Data perturbation techniques, on the
other hand, encourage smoothness in the system assuming that small perturbations in the input should
not result in large changes in the output. Which method works best for a given task is generally
not known a priori and considering different classes of regularizer is recommended in practice.
Furthermore, combining multiple forms of regularization simultaneously is often effective, especially
in lower data regimes (see e.g. Brigato & Iocchi, 2021 and Hu et al., 2017).
Neuroscience research has suggested that neurons are both selective (Johnston & Dark, 1986) and
have limited capacity (Cowan et al., 2005) in reacting to speciï¬c physiological stimuli. Speciï¬cally,
neurons selectively choose to focus on a few chunks of information in the input stimulus. In deep
learning, a similar concept, commonly described as a receptive ï¬eld , is employed in convolutional
layers (Luo et al., 2016). Here, each convolutional unit has multiple ï¬lters, and each ï¬lter is only
sensitive to specialized features in a local region. The output of the ï¬lter will activate more strongly
if the feature is present. This stands in contrast to fully-connected networks, where the all-to-all
relationships between neurons mean each unit depends on the entire input to the network. We
leverage this insight to propose a regularization method that can encourage artiï¬cial neurons to be
more specialized and orthogonal to each other.
Contributions. (1) Novel regularization method for deep tabular models. In this work, we
propose TANGOS , a novel method based on regularizing neuron attributions. A visual depiction is
given in Figure 1. Speciï¬cally, each neuron is more specialized , attending to sparse input features
while its attributions are more orthogonal to those of other neurons. In effect, different neurons pay
attention to non-overlapping subsets of input features resulting in better generalization performance.
We demonstrate that this novel regularization method results in excellent generalization performance
on tabular data when compared to other popular regularizers. (2) Distinct regularization objective.
We explore how TANGOS results in distinct emergent characteristics in the model weights. We
further show that its improved performance is linked to increased diversity among weak learners in
an ensemble of latent units, which is generally in contrast to existing regularizers. (3) Combination
with other regularizers. Based upon these insights, we demonstrate that deploying TANGOS in
tandem with other regularizers can further improve generalization of neural networks in the tabular
setting beyond that of any individual regularizer.
2 Published as a conference paper at ICLR 2023
2 R ELATED WORK
Gradient Attribution Regularization. A number of methods exist which incorporate a regulari-
sation term to penalize the network gradients in some way. Penalizing gradient attributions is a
natural approach for achieving various desirable properties in a neural network. Such methods
have been in use at least since Drucker & Le Cun (1992), where the authors improve robustness by
encouraging invariance to small perturbations in the input space. More recently, gradient attribution
regularization has been successfully applied across a broad range of application areas. Some notable
examples include encouraging the learning of robust features in auto-encoders (Rifai et al., 2011),
improving stability in the training of generative adversarial networks (Gulrajani et al., 2017), and
providing robustness to adversarial perturbations (Moosavi-Dezfooli et al., 2019). While many works
have applied a shrinkage penalty (L2) to input gradients, Ross et al. (2017a) explore the effects of
encouraging sparsity by considering an L1 penalty term. Gradient penalties may also be leveraged
to compel a network to attend to particular human-annotated input features (Ross et al., 2017b). A
related line of work considers the use of gradient aggregation methods such as Integrated Gradients
(Sundararajan et al., 2017) and, typically, penalizes their deviation from a given target value (see e.g.
Liu & Avci (2019) and Chen et al. (2019)). In contrast to these works, we do not require manually
annotated regions upon which we constrain the network to attend. Similarly, Erion et al. (2021)
provide methods for encoding domain knowledge such as smoothness between adjacent pixels in
an image. We note that while these works have investigated penalizing a predictive modelâ€™s output
attributions, we are the ï¬rst to regularize attributions on latent neuron activations. We provide an
extended discussion of related works on neural network regularization more generally in Appendix A.
3 TANGOS
3.1 P ROBLEM FORMULATION
We operate in the standard supervised learning setting, with dX-dimensional input variables X2
XRdXand target output variable Y2Y R. LetPXYdenote the joint distribution between
input and target variables. The goal of the supervised learning algorithm is to ï¬nd a predictive model,
f:X!Y with learnable parameters 2. The predictive model belongs to a hypothesis space
f2H that can map from the input space to the output space.
The predictive function is usually learned by optimizing a loss function L: !Rusing empirical
risk minimization (ERM). The empirical risk cannot be directly minimized since the data distribution
PXYis not known. Instead, we use a ï¬nite number of iid samples (x;y)PXY, which we refer to
as the training data D=f(xi;yi)gN
i=1.
Once the predictive model is trained on D, it should ideally predict well on out-of-sample data
generated from the same distribution. However, overï¬tting can occur if the hypothesis space His
too complex and the sampling of training data does not fully represent the underlying distribution
PXY. Regularization is an approach that reduces the complexity of the hypothesis space so that more
generalized functions are learned to explain the data. This leads to the following ERM:
= arg min
21
jDjX
(x;y)2DL(f(x);y) +R(;x;y ); (1)
that includes an additional regularization term Rwhich, generally, is a function of input x, the
labely, the model parameters , and reï¬‚ects prior assumptions about the model. For example, L1
regularization reï¬‚ects the belief that sparse solutions in parameter space are more desirable.
3.2 N EURON ATTRIBUTIONS
Formally, attribution methods aim to uncover the importance of each input feature of a given sample to
the prediction of the neural network. Recent works have demonstrated that feature attribution methods
can be incorporated into the training process (Lundberg & Lee, 2017; Erion et al., 2021). These the prediction of the neural network. Recent works have demonstrated that feature attribution methods
can be incorporated into the training process (Lundberg & Lee, 2017; Erion et al., 2021). These
attribution priors optimize attributions to have desirable characteristics, including interpretability as
well as smoothness and sparsity in predictions. However, these methods have exclusively investigated
output attributions, i.e., contributions of input features to the output of a model. To the best of our
knowledge, we are the ï¬rst work to investigate regularization of latent attributions .
3 Published as a conference paper at ICLR 2023
=++/uni007C/uni007C/uni007C/uni007C1/uni2112spec/uni007C/uni007C/uni007C/uni007C1/uni007C/uni007C/uni007C/uni007C1=cos(,)+/uni2112orthcos(,)+cos(,)
InputFeaturesh1h2h3
/uni2202hi/uni2202xjInputGradients
Figure 2: Method illustration. TANGOS
regularizes the gradients with respect to
each of the latent units.We rewrite our predictive function fusing function com-
positionf=lg. Hereg:X !H maps the input to a
representation h=g(x)2H , whereHRdHis adH-
dimensional latent space. Additionally, l:H!Y maps
the latent representation to a label space y=l(h)2Y. We
lethi=gi(x), for,i2[dH]denote theithneuron in the
hidden layer of interest. Additionally, we use ai
j(x)2R
to denote the attribution of the ithneuron w.r.t. the feature
xj. With this notation, upper indices correspond to latent
units and lower indices to features. In some cases, it will be
convenient to stack all the feature attributions together in the
attribution vector ai(x) = [ai
j(x)]dX
j=12RdX.
Attribution methods work by using gradient signals to eval-
uate the contributions of the input features. In the most
simplistic setting:
ai
j(x)@hi(x)
@xj: (2)
This admits a simple interpretation through a ï¬rst-order
Taylor expansion: if the input feature xjwere to increase
by some small number 2R+, the neuron activation would
change byai
j(x)+O(2). The larger the absolute value of
the gradient, the stronger the effect of a change in the input
feature. We emphasize that our method is agnostic to the gradient attribution method, as different
methods may be more appropriate for different tasks. For a comprehensive review of different
methods, assumptions, and trade-offs, see Ancona et al. (2017). For completeness, we also note
another category of attribution methods is built around perturbations : this class of methods evaluates
contributions of individual features through repeated perturbations. Generally speaking, they are
more computationally inefï¬cient due to the multiple forward passes through the neural network and
are difï¬cult to include directly in the training objective.
3.3 R EWARDING ORTHOGONALIZATION AND SPECIALIZATION
The main contribution of this work is proposing regularization on neuron attributions. In the most
general sense, any function of any neuron attribution method could be used as a regularization term,
thus encoding prior knowledge about the properties a model should have.
Speciï¬cally, the regularization term is a function of the network parameters andx, i.e.,R(;x), and
encourages prior assumptions on desired behavior of the learned function. Biological sensory neurons
are highly specialized. For example, certain visual neurons respond to a speciï¬c set of visual features
including edges and orientations within a single receptive ï¬eld. They are thus highly selective with
limited capacity to react to speciï¬c physiological stimuli (Johnston & Dark, 1986; Cowan et al.,
2005). Similarly, we hypothesize that neurons that are more specialized and pay attention to sparser
signals should exhibit better generalization performance. We propose the following desiderata and
corresponding regularization terms:
â€¢Specialization. The contribution of input features to the activation of a particular neuron should
be sparse, i.e.,jjai(x)jjis small for all i2[dH]andx2X. Intuitively, in higher-dimensional
settings, a few features should account for a large percentage of total attributions while others
are near zero, resulting in more specialized neurons. We write this as a regularization term for
mini-batch training:
Lspec(x) =1
BBX
b=11
dHdHX
i=1kai(xb)k1;
whereb2[B]is the batch index of xb2X andkk1denotes thel1norm.
â€¢Orthogonalization. Different neurons should attend to non-overlapping subsets of input features
given a particular input sample. To encourage this, we penalize the correlation between neuron
attributions[ai(x);aj(x)]for alli6=jandx2X. In other words, for each particular input, we
4 Published as a conference paper at ICLR 2023
want to discipline the latent units to attend to different aspects of the input. Then, expressing this
as a regularization term for mini-batch training, we obtain:
Lorth(x) =1
BBX
b=11
CdHX
i=2i"," This paper presents TANGOS, a regularization method for deep tabular models that encourages specialization and orthogonalization of neurons by penalizing neuron attributions during training. Results show that TANGOS outperforms other popular regularizers and that combining it with other regularizers can further improve generalization of neural networks in the tabular setting. Experiments were conducted on 20 datasets and results showed that TANGOS can close the gap between deep learning and boosting methods. The paper also discusses the use of feature attribution methods in the training process, as well as the use of regularization methods to aid generalization in neural networks."
38," Accepted to the ICLR 2023 TrustML-(un)Limited workshop
MARK MYWORDS : DANGERS OF WATERMARKED
IMAGES IN IMAGE NET
Kirill Bykov1, 2, *& Klaus-Robert M Â¨uller1, 3, 4, 5& Marina M.-C. H Â¨ohne1, 2, 3, 6, 7
1Technische Universit Â¨at Berlin, Machine Learning Group, 10587 Berlin, Germany
2Understandable Machine Intelligence Lab, ATB, 14469 Potsdam, Germany
3BIFOLD â€“ Berlin Institute for the Foundations of Learning and Data, 10587 Berlin, Germany
4Korea University, Department of Artiï¬cial Intelligence, Seoul 136-713, Korea
5Max Planck Institute for Informatics, 66123 Saarbr Â¨ucken, Germany
6Machine Learning Group, UiT the Arctic University of Norway, 9037 TromsÃ¸, Norway
7Department of Computer Science, University of Potsdam, 14476 Potsdam, Germany
*Corresponding Author: KBykov@atb-potsdam.de
ABSTRACT
The utilization of pre-trained networks, especially those trained on ImageNet, has
become a common practice in Computer Vision. However, prior research has
indicated that a signiï¬cant number of images in the ImageNet dataset contain wa-
termarks, making pre-trained networks susceptible to learning artifacts such as
watermark patterns within their latent spaces. In this paper, we aim to assess the
extent to which popular pre-trained architectures display such behavior and to de-
termine which classes are most affected. Additionally, we examine the impact
of watermarks on the extracted features. Contrary to the popular belief that the
Chinese logographic watermarks impact the â€œcartonâ€ class only, our analysis re-
veals that a variety of ImageNet classes, such as â€œmonitorâ€, â€œbroomâ€, â€œapronâ€
and â€œsafeâ€ rely on spurious correlations. Finally, we propose a simple approach
to mitigate this issue in ï¬ne-tuned networks by ignoring the encodings from the
feature-extractor layer of ImageNet pre-trained networks that are most susceptible
to watermark imprints.
1 I NTRODUCTION
In recent years, the utilization of ImageNet Deng et al. (2009) pre-trained models has become a
standard practice in Computer Vision applications Kornblith et al. (2019). Trained on the large and
diverse collection of images, these models obtain the ability to extract high-level visual features that
later could be transferred to a different task. This technique, referred to as transfer learning (see
e.g. Weiss et al. (2016) for a review), has proven to be highly effective, leading to signiï¬cant ad-
vancements in various computer vision applications, such as object detection Talukdar et al. (2018),
semantic segmentation Van Opbroek et al. (2018) and classiï¬cation Yuan et al. (2021).
Deep Neural Networks (DNNs), despite being highly effective across a variety of applications, are
prone to learning spurious correlations, i.e., erroneous relationships between variables that seem to
be associated based on a given dataset but in reality lack a causal relationship Izmailov et al. (2022).
This phenomenon, referred to as the â€œClever-Hans effectâ€ Lapuschkin et al. (2019) or â€œshortcut-
learningâ€ Geirhos et al. (2020), impairs the modelâ€™s ability to generalize. In Computer Vision (CV),
such correlations may manifest as DNNsâ€™ dependence on background information for image classi-
ï¬cation Xiao et al. (2020), textural information Geirhos et al. (2018), secondary objects Rosenfeld
et al. (2018), or unintended artifacts, such as human pen markings in skin cancer detection Anders
et al. (2022) and patient information in X-ray images for pneumonia detection Zech et al. (2018).
Recent studies have uncovered the presence of spurious correlations in the ImageNet dataset, specif-
ically, the connection of the Chinese logographic watermarks to the â€œcartonâ€ class Anders et al.
(2022); Li et al. (2022). These correlations make ImageNet-trained networks vulnerable to learn
watermark detectors in their latent space, leading to incorrect predictions when encountering similar
patterns in the data. Furthermore, it has been shown that this behavior persists even after ï¬ne-tuning patterns in the data. Furthermore, it has been shown that this behavior persists even after ï¬ne-tuning
1arXiv:2303.05498v1  [cs.LG]  9 Mar 2023 Accepted to the ICLR 2023 TrustML-(un)Limited workshop
on different datasets Bykov et al. (2022), indicating that the vulnerability to watermarks is not ex-
clusive to ImageNet networks but possibly extends to all ï¬ne-tuned models.
With this study, we aim to examine which speciï¬c ImageNet classes are inï¬‚uenced by the artifactual
behavior of watermarks. We analyze the extent to which commonly used pre-trained architectures
exhibit this phenomenon and propose a straightforward solution for reducing such behavior in trans-
fer learning by eliminating the most artifact-sensitive representations, with negligible effect on the
modelâ€™s performance.
2 M ETHOD
Figure 1: The illustration shows the images
in the baseline dataset and their correspond-
ing watermarked versions.In this work, we deï¬ne neural representations as sub-
functions of a model that map the input domain to
a scalar value indicating the activation of a speciï¬c
neuron. Our analysis focuses on two primary sce-
narios: scalar representations of output classes and
feature-extractor representations, which correspond
to the layer preceding the output logit layer1.
To evaluate the susceptibility of individual represen-
tations to watermarks, we created binary classiï¬ca-
tion datasets between normal and watermarked im-
ages and assessed their ability to distinguish between
the two classes. We followed the approach outlined
in Bykov et al. (2022) and used a baseline dataset
of 998 ImageNet images2. We created four probing
datasets by inserting random textual watermarks in
the three most popular languages (Chinese, Latin, Hindi) Sanches (2014) and Arabic numerals, as il-
lustrated in Figure 1. We evaluated the representationsâ€™ ability to differentiate between watermarked
and normal classes using AUC ROC, a widely used performance metric for binary classiï¬ers. To
do so, we utilized the true labels provided by the two datasets, where class 1 represents images
with a watermark and class 0 represents those without. We ï¬rst calculated the scalar activations
from a speciï¬c neural representation for all images from both classes. Then, utilizing the binary
labels, we calculated the AUC ROC classiï¬cation score based on the differences in activations.
AUC ROC score of 1 indicates a perfect classiï¬er, ranking the watermarked images consistently
higher than normal ones, and 0.5 a random classiï¬er. However, we can also observe scores less
than 0.5, such as the score of 0 illustrating the perfect classiï¬er, that is de-activated by the water-
marked images. To measure the general ability of representations to differentiate between the two
classes and provide evidence that the concept has been learned, we deï¬ned a differentiability mea-
sured= max (A;1"," This paper examines the vulnerability of pre-trained architectures to watermarks in the ImageNet dataset, and proposes a method to reduce the dependence of deep neural networks on Chinese watermarks present in ImageNet by ignoring the most sensitive representations from the feature-extractor model. Results indicate that the sensitivity to watermarks is a common trait among all studied networks, and that Chinese watermarks had the highest average AUC ROC scores. The paper also discusses the TrustML-(un)Limited workshop accepted to ICLR 2023, and the dataset generation approach for the workshop."
39," Multiplexed gradient descent: Fast online training of
modern datasets on hardware neural networks without
backpropagation
A. N. McCaughan1, B. G. Oripov2, N. Ganesh1, S. W. Nam1,
A. Dienstfrey1, S. M. Buckley1
1National Institute of Standards and Technology, Boulder, CO 80305
2University Colorado Boulder, Boulder, CO 80309
Abstract
We present multiplexed gradient descent (MGD), a gradient descent framework
designed to easily train analog or digital neural networks in hardware. MGD utilizes
zero-order optimization techniques for online training of hardware neural networks. We
demonstrate its ability to train neural networks on modern machine learning datasets,
including CIFAR-10 and Fashion-MNIST, and compare its performance to backprop-
agation. Assuming realistic timescales and hardware parameters, our results indicate
that these optimization techniques can train a network on emerging hardware platforms
orders of magnitude faster than the wall-clock time of training via backpropagation on
a standard GPU, even in the presence of imperfect weight updates or device-to-device
variations in the hardware. We additionally describe how it can be applied to existing
hardware as part of chip-in-the-loop training, or integrated directly at the hardware
level. Crucially, the MGD framework is highly exible, and its gradient descent pro-
cess can be optimized to compensate for specic hardware limitations such as slow
parameter-update speeds or limited input bandwidth.
1arXiv:2303.03986v1  [cs.LG]  5 Mar 2023 1 Introduction
Machine learning has proven an invaluable tool for a variety of applications [1]. However,
machine learning on traditional digital hardware is inecient, leading to a signicant eort
towards building custom hardware that can perform machine learning tasks at high speeds
with lower energy costs [2]. A number of hardware platforms have emerged using analog [3],
digital [4, 5], or mixed-signal processing [6] that will potentially oer increased operational
speeds and/or reduced energy costs [7]. However, many of the most promising hardware
instantiations only perform the inference part of the machine learning algorithm. Meanwhile
the larger portion of the energy cost is spent training on datasets [8], usually via gradient
descent. Backpropagation is by far the most commonly used method of computing the gra-
dient for gradient descent, but has proved to be challenging to implement in novel hardware
platforms [9].
Though often conated, training via gradient descent does not require backpropagation
{ backpropagation is only used to calculate the gradient. Other methods for computing the
gradient in neural networks exist, but are much less ecient in software than backpropagation
and so are rarely used in today's machine learning applications. This is not generally true in
hardware, where backpropagation may not only be challenging to implement, but also may
not be the most ecient way to compute the gradient.
Of particular interest in hardware are model-free methods, in which we require no knowl-
edge of the internal structure of the network (e.g topology, activation function, derivatives,
etc), only the ability to perturb the network's parameters and measure the network's re-
sponse. The simplest example of such a method is nite-dierence [10], which has been
employed for chip-in-the-loop training [11]. However, nite-dierence has several other dis-
advantages that prevent its widespread implementation in hardware, including the require-
ments for extra memory at every synapse and global synchronization. Fortunately, there
are a variety of other model-free methods that overcome some of the issues associated with
nite-dierence [12, 13].
2 In this paper, we show that model-free perturbative methods can be used to eciently
train modern neural network architectures in a way that can be implemented natively within
emerging hardware. These methods were investigated for training VLSI neural networks
beginning in the 1990s [14, 15, 16, 17, 18, 19, 20, 21, 22, 23], and more recently on memristive
crossbars [24] and photonic hardware [25], but all these demonstrations have been very
limited in scale, comprising small datasets with only a few neurons. Below we describe a
framework for applying these techniques to existing hardware at much larger scales, with
an emphasis on creating simple, highly-localized circuits that could be implemented on-chip
if desired. The framework is also extensible to training existing hardware systems via a
chip-in-the-loop technique. We note that these methods have also been adapted in forward
gradient approaches using auto-dierentiation, which have attracted recent interest in the
machine learning literature [26, 27, 28].
We show that under realistic assumptions of the operating timescales of analog and digital
hardware neural networks, one can train hardware to solve modern datasets such as CIFAR-
10 faster than training a software network on a GPU, even in the presence of signal noise
and device-to-device variations in the hardware. A major advantage of this framework is
that it can be used to perform online training of hardware platforms originally designed only
for inference while making minimal hardware modications.
2 Multiplexed gradient descent
2.1 Computing the gradient with perturbations
We begin with the basic assumption that we have some hardware with programmable pa-
rameters (e.g. weights and biases) that can perform inference. Our goal is to augment the
hardware minimally such that it can also be trained via gradient descent. We will show
how to congure the hardware such that the network as a whole automatically performs
gradient descent, without backpropagation. As an example, assume we have a hardware
3 instantiation of a feedforward multi-layer neural network as shown in Fig. 1. The hardware
takes time-varying inputs x(t), training target ^ y(t), has variable parameters , outputs the
inferencey(t), and computes a cost C(y(t);^y(t)). To allow us to compute the gradient of
such a system, we rst add a small time-varying perturbation ~i(t) to each parameter base
valuei(Fig. 1a, inset). This perturbation will slightly modulate the cost C, and that mod-
ulation will be fed back to the parameters. This process will ultimately allow us to extract
the gradient of the system.
C
neuron
synapse
...
Êƒ
 update 
(a)
(c)(b)
...... x1
x2
x3sinusoidalt
sequential
code
Figure 1: (a) Schematic diagram showing the operation of the MGD framework in a feed-
forward neural network using example sinusoidal perturbations. (a, inset) Each parameter
iis modulated slightly from its base value iby the perturbation ~i. The result of these
perturbations causes a modulation in the cost ~C, which is globally broadcast back to all
the parameters. (b) A homodyne detection process is used to compute the partial gradient
approximations Gifrom the integrated product of iand ~C. This partial gradient is then
used to update iin the approximate direction of the gradient. (c) Example perturbation
types that can be used with this process.
Although the perturbations can take a variety of dierent forms, we will rst describe
this process by using sinusoidal perturbations as they are conceptually straightforward to
understand. In this scenario, each parameter iis slightly modulated at a unique frequency
!iand amplitude  , giving the perturbation ~i(t) = sin(!it). As each parameter is
4 modulated, it slightly changes y(t) which in turn changes the cost. Thus, if the parameters
are modulated by frequencies !1,!2,!3, etc, those same frequencies will necessarily appear
as small modulations in the cost ~C(t) on top of the baseline (unperturbed) cost value C0,
such that
C(t) =C0+~C(t) =C0+X
iCisin(!it) (1)
If we remove C0, we are left with a time varying signal ~C(t) =P
iCisin(!it) corre-
sponding only to the eects of our parameter perturbations. The amplitude  Ciis simply
the amplitude of change in the cost due to ~i(t), the perturbation of parameter i.
Since the gradient with respect to the cost dC=d is composed solely from the partial
gradientsdC=d = (@C=@ 1; @C=@ 2; :::), if we can extract  Cifor each parameter we
can produce an estimate of the complete gradient G= (C1=1;C2=2;:::). Now the
task becomes to extract individual  Ciout of the summed signal ~C(t). Fortunately, to
extract a given  Ci, all we need to do is integrate the product of the input perturbation
~i(t) with ~C(t). The integration takes the form of a homodyne detection, where unwanted
perturbations (frequencies) from other parameters are eliminated via integration:
Gi=1
2
i1
TZT
t=0X
kCksin(!kt)isin(!it)dt
=Ci
iasT!1(2)
where 1=2
iis a normalization constant.
The valueGiis the approximation for the partial gradient for parameter i.Gapproaches
the exact gradient when both T!1 and the amplitude of the perturbation  iapproaches
zero, and is only an approximation otherwise. Fortunately, even at realistic timescales and
amplitudes, Gcontains meaningful information and can be used to perform gradient de-
scent [12].
5 For illustrative purposes we have described the algorithm using sinusoidal parameter
perturbations. However, any collection of orthogonal, mean zero perturbations can be used
[13], including a variety of analog and discrete perturbations as shown in Fig. 1c. In general,
we will be integrating the product ei(t) = ~C(t)~i(t)=2
i, which we refer to as the error
signal, and Giwill be given by1
Gi=ZT
t=0~C(t)~i(t)
2
idt (3)
We discuss the eects of changing the perturbation type in Section 3.4. We also note that
although many of the quantities described here are time-varying, in the following sections
we will drop the explicit time dependence notation for the sake of brevity.
2.2 Gradient descent in the MGD framework
Here we describe the practical implementation of a model-free gradient descent framework
in hardware, which we term multiplexed gradient descent (MGD). To better understand
the algorithm from a hardware perspective, we will run through the same computation
previously described, but from the viewpoint of a single parameter (e.g. a synapse weight in
a hardware neural network). The process begins with the application of a local perturbation
~ithat slightly modies the base value of the parameter i(Fig. 1a, inset). As previously
described, this perturbation { and any other perturbations from other parameters { induce
a change in the cost ~Con top of the baseline cost C0such that the cost at the output is
C=C0+~C.~Cmay be extracted from Ceither by direct subtraction of C0or, in some
analog scenarios, by a simple highpass lter. The resulting ~Csignal is broadcast globally
to all parameters, so our parameter ihas access to it. (Note that although Fig. 1 shows a
wireless broadcast tower for purposes of clarity, in most hardware platforms this will be a
1Note that here and in the simulation results, Giis being accumulated with time and is not normalized by
1=T, unlike Eq. 2. As described later, this allows us to vary the integration time without greatly impacting
the rate of training{equivalently, one can integrate for a long time resulting in a large step down the gradient,
or one can take a series of shorter steps instead and travel approximately the same distance along the gradient.
6 wired connection). However, we must assume that parameters other than the ith are also
causing modulations in the cost as well. To our parameter i, these other modulations are
unwanted and must be ltered out. As shown in Fig. 1b, for the parameter ito extract only
its own eect on the cost, it can just integrate the product of its local perturbation ~iand
the global cost signal ~Cit receives. This has the eect of isolating the contribution from i
due to the pairwise orthogonality of the perturbation signals. From Eq. 3, this integration
produces the partial gradient approximation Gi/Ci=i. The parameter can then use
theGivalue to directly to reduce the cost by updating itself according to a gradient descent
step
i!i"," This paper presents the Multiplexed Gradient Descent (MGD) algorithm, a model-free perturbative technique for training hardware platforms based on emerging technologies. It is orders of magnitude faster than backpropagation and can be adjusted during training. It is applicable to a wide range of systems and can be used in the presence of noise and device imperfections. The paper also reviews research on the development of analog VLSI neural networks, FPGA implementations, memristor-based neural networks, photonic deep neural networks, and other hardware systems, as well as various learning rules and algorithms for spiking neural networks."
40," SYMBOLIC SYNTHESIS OF NEURAL NETWORKS
Eli Whitehouse
New York, NY 10024
eliw55@gmail.com
ABSTRACT
Neural networks adapt very well to distributed and continuous representations, but struggle to learn
and generalize from small amounts of data. Symbolic systems commonly achieve data efï¬cient
generalization by exploiting modularity to beneï¬t from local and discrete features of a representation.
These features allow symbolic programs to be improved one module at a time and to experience
combinatorial growth in the values they can successfully process. However, it is difï¬cult to design
components that can be used to form symbolic abstractions and which are highly-overparametrized
like neural networks, as the adjustment of parameters makes the semantics of modules unstable.
I present Graph-based Symbolically Synthesized Neural Networks (G-SSNNs), a form of neural
network whose topology and parameters are informed by the output of a symbolic program. I
demonstrate that by developing symbolic abstractions at a population level, and applying gradient-
based optimization to such neural models at an individual level, I can elicit reliable patterns of
improved generalization with small quantities of data known to contain local and discrete features.
The paradigm embodied by G-SSNNs offers a route towards the communal development of compact
and composable abstractions which can be ï¬‚exibly repurposed for a variety of tasks and high-
dimensional media. In future work, I hope to pursue these beneï¬ts by exploring more ambitious
G-SSNN designs based on more complex classes of symbolic programs. The code and data associated
with the reported results are available here.
Keywords neural networkssymbolic programs graph neural networks library learningdistributional program
search
1 Introduction
Most conventional modes of human communication naturally occur in a high-dimensional medium such as text, audio,
or images. When processing these media, slight errors can easily accrue across many dimensions of the input where
features are distributed. With adequate data, neural networks adapt effectively to these patterns by adjusting many
interdependent real-valued parameters. In their basic form, however, neural models are data inefï¬cient. In settings
where more data cannot be sourced, pretraining has arisen as the most general and data-driven answer to this challenge.
Pretraining allows practitioners to repurpose data that is not speciï¬cally suited to a task to enrich a representation or
initialize parameters of a neural model. While pretraining grants a model exposure to out-of-distribution data which
may be irrelevant or inappropriate to the task at hand, the beneï¬ts of this exposure can outweigh the costs.
In symbolic systems, modularity is often used to stimulate greater data efï¬ciency and generalization. By examining the
particular dimensions and values at which systems fail, developers can trace issues back to speciï¬c modules. When a
failure in one module is isolated and corrected, the system beneï¬ts from this across all combinations of values and
dimensions, witnessing potentially exponential growth in the number of inputs on which it succeeds. This approach
relies on the locality and discreteness of the representations associated with the task so that modular functionalities
can be developed and debugged. Unfortunately, it is difï¬cult to design a fundamental unit of a system that gains the
beneï¬ts of modularity and of neural networks, as it is difï¬cult to compose stable abstractions from components that
contain many adjustable parameters. Nonetheless, this is a more direct solution to the problem of data inefï¬ciency
and inadequate generalization in circumstances where high-dimensional data are known to exhibit both locality and
discreteness.arXiv:2303.03340v1  [cs.NE]  6 Mar 2023 Symbolic Synthesis of Neural Networks
In this work, I propose a technique for structuring modular neural networks that utilizes symbolic programs to
inform the networkâ€™s topology and to determine the values of some of its parameters. This allows the symbolic
programs themselves to be developed so as to exhibit increasing degrees of abstraction at a population level, while
allowing resulting individual networks to be trained and evaluated with standard techniques. I present Graph-based
Symbolically-Synthesized Neural Networks (G-SSNNs) and apply populations of G-SSNNs to a binary prediction task
over high-dimensional data containing many local and discrete features. I show that these populations exhibit reliable
patterns of improved generalization from small quantities of data compared to a population of baseline models which
are not structured according to the output of symbolic programs.
2 Related Work
2.1 Neural Architecture Search
Neural Architecture Search (NAS) is the process of using automated methods to explore the discrete space of neural
network topologies. Though varying in the design of their search space [Jin et al., 2022], search strategies [Real
et al., 2020], and model evaluation strategies [Abdelfattah et al., 2021], all approaches I reviewed assume that model
parameters learnable through gradient-based optimization will be learned in this fashion once search is complete. That
is, they serve to explore a (potentially hierarchical) space of hyperparameters in which topology often plays a central
role. This differs from G-SSNNs, in which symbolic programs play a role in determining both the topology and the
parameters of a model.
2.2 Embedding Spaces and Preprocessing
The act of adding ï¬xed transformations into a neural network that could otherwise be performed with the help of
learnable parameters seems more analogous to an act of preprocessing, as might be performed with word embeddings
[Mikolov et al., 2013] or positional encoding [Vaswani et al., 2017]. However, I found no works in which similar acts
of preprocessing were designed with the help of automated program synthesis.
2.3 Program Synthesis
The program synthesis apparatus used in this work is inspired by the DreamCoder system [Ellis et al., 2021] and uses
the same cycle of library learning and distributional program search between iterations of G-SSNN training, though I
utilize the more recent STITCH tool [Bowers et al., 2023] and heap search algorithm [Matricon et al., 2022] for these
respective functionalities. G-SSNNs have a deeper analogy with the DreamCoder system in that the process of training
a G-SSNN on a dataset generalizes the evaluation mechanisms for tasks and symbolic programs used in DreamCoderâ€™s
domains. The greater generality of G-SSNNs introduces concerns about performance on unseen data that are not
relevant when measuring the performance of purely symbolic programs, and must be addressed by separate mechanisms.
However, in principle, nothing prevents the multitask Bayesian program learning framework of DreamCoder from being
applied to the development of multiple, parallel populations of G-SSNNs.
In the broader neurosymbolic literature, I did not ï¬nd other examples of systems in which adjacent parametric and
nonparametric modules are separately optimized through gradient-based learning and the development of increasingly
hierarchical symbolic abstractions.
3 Methods
3.1 Evolutionary Framework
While the parameters of a G-SSNN may be optimized with ordinary training methods, we must utilize a separate
mechanism to optimize their symbolic structure. Since a G-SSNN is characterized by a single symbolic program, we
must retain a population of G-SSNNs in order to conduct program search. This search is guided in two respects: by the
structure of the DSL, and by the parameters of a distribution over programs. The structure of the DSL is determined by structure of the DSL, and by the parameters of a distribution over programs. The structure of the DSL is determined by
the results of library learning performed with STITCH [Bowers et al., 2023]. STITCHâ€™s library learning functionality
operates by extracting novel primitives from a corpus according to which provides the greatest degree of compression
(i.e. reduction in aggregate program size). A distribution over programs may also be inferred from such a corpus by
counting how many times n-grams of primitives from the DSL are used.1Thus, if we are able to select an approximately
optimal corpus of symbolic programs based on the training performance of a population of G-SSNNs, we may both
1In experiments, I utilize a unigram distribution.
2 Symbolic Synthesis of Neural Networks
bias compression towards the discovery of modules common to successful programs and bias program search towards
the discovery of increasingly complex programs which utilize those modules.
Because there is always the possibility that a G-SSNN performs differently on unseen data, there is no heuristic that is
unquestionably best for encouraging the greatest generalization. Perhaps the simplest and most generally agreeable,
however, are those based on discarding G-SSNNs with the Lowest Training Performance (LTP). I refer to the heuristic I
use in the experiments presented here as rank-LTP-50, which involves discarding the bottom half of G-SSNNs in terms
of the rank of their training performance among the population.
3.2 G-SSNNs
There are many ways that the output of a symbolic program could be incorporated into the topology and parameter
values of a neural network. However, the use of learned abstractions forces a consideration: how do we make symbolic
programs increasingly sophisticated without simply making their corresponding neural networks larger? In order that
our models donâ€™t become increasingly costly to train as the symbolic programs that structure them utilize increasingly
complex modules, the number of parameters optimized with gradient-based learning should remain ï¬xed regardless of
how the symbolic program ï¬xes their topology or values. This can be achieved by repurposing generic graph neural
networks (GNNs).
Lets2Skbe relational structures whose elements are accompanied by symbolic feature vectors v2Nk. let
e:NkRm!Rnbe an embedding function that maps each symbolic feature vector vand a vector x2Rmto
another real-valued feature vector. Lastly, let graph_map :SkRm!Gnbe the function that maps from relational
structures and input vectors to graphs with the corresponding real-valued features given by e(v; x)for each v2s. We
may then deï¬ne a G-SSNN as a model m:Rm!Rqconsisting of a GNN mg:Gn!Rq, a relational structure s,
and an embedding function e, for which
m(x) =mg(graph_map (e; x; s )):
Provided that eis differentiable with respect to x, a G-SSNN may function as a generic neural module.
There are many ways one could design the class of relational structures Skand the embedding function edepending on
the degree and forms of control we want to grant symbolic programs over the parameter space and topology of the
network. For the experiments conducted in this paper, I adopt a simple design: I utilize a subset of the class S2of
single-component undirected graphs with node and edge features. The natural numbers associated with each graph
element correspond to a unique ID and a neighborhood rank. IDs are 0-indexed and reï¬‚ect the order in which the
elements were created. I denote the number of unique IDs in a graph with d= 1+max v2sv2. The neighborhood ranks
are natural numbers in a limited range which distinguish the edges of a particular neighborhood. The neighborhood rank
of a node is 0, while the neighborhood rank of an edge ranges from 1 to a ï¬xed maximum degree. Since neighborhood
ranks function to distinguish edges, even if their endpoints are the same, this class of relational structures could be
understood as permitting multiple edges. I denote the number of distinct neighborhood ranks with r= 1 + max v2sv2.
To process these symbolic features, I utilize the embedding function
e(v; x) =tile_expand (xidx(v1):idx(v1+1)) +2d_pos (v1; v2)
where idx(w) = ( mmodl) +wlforl=bm=dc. The function tile_expand :Rt!Rnimplements the
differentiable operation of concatenating dn=tecopies of its input and truncating the result to a dimensionality of n,
and the function 2d_pos :N2!Rnproduces computes a vector b=2d_pos (d; r)such that2
bi=8
>><
>>:sin(reorder_1 (d; r)=10000imod ( n=4)) 1 < in=4
cos(reorder_1 (d; r)=10000imod ( n=4))n=4< i2n=4
sin(reorder_2 (d; r)=10000imod ( n=4)) 2n=4< i3n=4
cos(reorder_2 (d; r)=10000imod ( n=4)) 3n=4< in: cos(reorder_1 (d; r)=10000imod ( n=4))n=4< i2n=4
sin(reorder_2 (d; r)=10000imod ( n=4)) 2n=4< i3n=4
cos(reorder_2 (d; r)=10000imod ( n=4)) 3n=4< in:
This embedding function constructs node and edge features by selecting values from a subset of the dimensions of x
and adding them to a bias vector, where both the subset of dimensions and the value of the vector are chosen based
on the unique values of each graph elementâ€™s symbolic feature vector. This incentivizes greater modularity in mby
ensuring that the parameters of mgfunction differently when applied to the same values depending on the dimensions
2The functions reorder_1 andreorder_2 are an implementation detail due to mistaken indexing which did not affect the validity
of the experiment. These functions are deï¬ned as reorder_1 (d; r) = (dr+r) mod dandreorder_2 (d; r) =b(dr+r)=dc
where dandrare the maximal values of dandr. These functions may be replaced by f1(d; r) =dandf2(d; r) =rrespectively
to simplify the computation of 2d_pos .
3 Symbolic Synthesis of Neural Networks
ofxin which they appear. Similarly, this behavior incentivizes antecedent neural modules to exhibit greater modularity
by ensuring that their parameters function differently based on the dimensions of xthat they inï¬‚uence. These incentives
rely crucially on the bias term of e, which allows the symbolic program generating the relational structure sto inï¬‚uence
the parameter space of m. Without this term, the symbolic program would still inï¬‚uence the topology of mthrough the
structure of the graph convolutions applied by mgand the distribution of values from speciï¬c dimensions of xinto
speciï¬c node and edge features under e.3However, this alone would create no obligation for different parameters of
mgor antecedent neural modules to behave differently with regard to the various dimensions of x. In general, while
topology may allow or disallow particular parameters from inï¬‚uencing each other, it cannot guarantee that they behave
differently with respect to the output for the same input. This can only be achieved by systematically varying the values
different parameters may take.
3.3 Symbolic Programs
The symbolic programs used to generate the relational structures described above are of type S2!S2and are all
evaluated by application to the same initial relational structure. The primitive operations of the initial DSL are such that
symbolic programs may only make decisions based on the information contained in the relational structure. Since the
initial relational structure is uninformative, symbolic programs therefore only have access to information about their
own semantics as it manifests in the relational structure they construct. More detailed information on the operations of
the initial DSL is available in the documentation of the antireduce-graphs library.
During program search, symbolic programs are considered novel if they generate a relational structure that is unique
under isomorphism when symbolic features are not considered. Isomorphism testing is performed with the VF2++
algorithm [JÃ¼ttner and Madarasi, 2018].
4 Experiments
4.1 Setup & Hyperparameters
To facilitate comparison, I utilize a base model architecture consisting of a transformer with a convolutional stem [Xiao
et al., 2021]. I use subpixel convolution to perform downsampling from 128128to88[Shi et al., 2016], followed
by a pointwise convolution and three residual convolutional units. The patches are then ï¬‚attened and fed to a simpliï¬ed
Vision Transformer (ViT) [Beyer et al., 2022] with 2 transformer blocks. Each block has an MLP dimension of 512 and
4 128-dimensional attention heads. Global average pooling is then applied to produce an output of the target dimension
for baseline models, or with the dimensionality of a graph element for experimental models in which the output is fed
to a G-SSNN unit.
To construct G-SSNNs, I use the Graph Isomorphism Network with Edge features (GINE) of Hu et al. [2020] as
implemented in the DGL library [Wang et al., 2019]. I use 512-dimensional node and edge representations, which
are passed through three GINE units parametrized by an MLP layer with identical input and output dimensionalities.
Between GINE units, I apply 30% droput [Srivastava et al., 2014]. To produce the ï¬nal output, I apply average pooling
followed by another MLP layer which projects its input to the target output.
For both baseline and experimental models I use a batch size of 8, train each model for 16 epochs with the Adam
optimizer [Kingma and Ba, 2015], and reduce the learning rate by a factor of 1/2 when a new low in the loss has not
been experienced in the ï¬rst 50 batches, or in the most recent 65 batches since the learning rate was last reduced.
Across iterations of evolutionary selection, I retain a population of at most 50 and apply the rank-LTP-50 heuristic if
the size of the population is greater than or equal to 25. I run distributional program search for a 15 second period. In the size of the population is greater than or equal to 25. I run distributional program search for a 15 second period. In
the course of this run, I retain only the most likely 50"," This paper presents Graph-based Symbolically Synthesized Neural Networks (G-SSNNs), a new approach to neural networks which combines the advantages of neural networks and symbolic systems to improve data efficiency and generalization. G-SSNNs use symbolic programs to inform the topology and parameters of the neural network, allowing for the development of compact and composable abstractions that can be repurposed for a variety of tasks. Experiments are conducted on a binary prediction task over high-dimensional data and show improved generalization from small quantities of data compared to baseline models. The paper also discusses strategies for pre-training graph neural networks and the Deep Graph Library, Dropout, Adam, RAVEN, and AI Evaluation Beyond Metrics for conceptual abstraction benchmarks."
41," MAP-Elites with Descriptor-Conditioned Gradients and
Archive Distillation into a Single Policy
Maxence Faldor
m.faldor22@imperial.ac.uk
Imperial College London
London, United KingdomFÃ©lix Chalumeau
f.chalumeau@instadeep.com
InstaDeep
Cape Town, South Africa
Manon Flageat
manon.flageat18@imperial.ac.uk
Imperial College London
London, United KingdomAntoine Cully
a.cully@imperial.ac.uk
Imperial College London
London, United Kingdom
ABSTRACT
Quality-Diversity algorithms, such as MAP-Elites, are a branch of
Evolutionary Computation generating collections of diverse and
high-performing solutions, that have been successfully applied
to a variety of domains and particularly in evolutionary robotics.
However, MAP-Elites performs a divergent search based on random
mutations originating from Genetic Algorithms, and thus, is limited
to evolving populations of low-dimensional solutions. PGA-MAP-
Elites overcomes this limitation by integrating a gradient-based
variation operator inspired by Deep Reinforcement Learning which
enables the evolution of large neural networks. Although high-
performing in many environments, PGA-MAP-Elites fails on several
tasks where the convergent search of the gradient-based operator
does not direct mutations towards archive-improving solutions. In
this work, we present two contributions: (1) we enhance the Policy
Gradient variation operator with a descriptor-conditioned critic
that improves the archive across the entire descriptor space, (2) we
exploit the actor-critic training to learn a descriptor-conditioned
policy at no additional cost, distilling the knowledge of the archive
into one single versatile policy that can execute the entire range
of behaviors contained in the archive. Our algorithm, DCG-MAP-
Elites improves the QD score over PGA-MAP-Elites by 82% on
average, on a set of challenging locomotion tasks.
1 INTRODUCTION
A fascinating aspect of evolution is its ability to generate a large
variety of different species, each being adapted to their ecological
niche. Inspired by this idea, Quality-Diversity (QD) optimization is
a family of evolutionary algorithms that aims to generate a set of
both diverse and high-performing solutions to a problem [ 3,7,32].
Contrary to traditional optimization methods that return a single
high-performing solution, the goal of QD algorithms is to illuminate
a search space of interest called descriptor space [27]. Producing
a large collection of diverse and effective solutions enables to get
multiple alternatives to solve a single problem which is useful
in robotics to improve robustness, recover from damage [ 6] or
reduce the reality gap [ 4]. Furthermore, conventional optimization
methods are prone to get stuck in local optima whereas keeping
diverse solutions to a problem can help to find stepping stones that
lead to globally better solutions [ 27,28]. Another benefit of diversity
Figure 1: DCG-MAP-Elites performs a standard MAP-Elites
loop of selection, variation, evaluation and addition. Two
complementary variation operators are applied: (1) a stan-
dard Genetic Algorithm (GA) variation operator for explo-
ration, (2) a Descriptor-Conditioned Policy Gradient (PG)
variation operator for fitness improvement. Concurrently to
the criticâ€™s training, the knowledge of the archive is distilled
in the descriptor-conditioned actor as by-product.
search is efficient exploration in problems where the reward signal
is sparse or deceptive [2, 8, 31].
MAP-Elites [ 27] is a conceptually simple but effective QD opti-
mization algorithm that has shown competitive results in a variety
of applications, to generate large collections of diverse skills. How-
ever, MAP-Elites relies on random variations that can cause slow
convergence in large search space [ 5,28,31], making it inadequate
to evolve neural networks with a large number of parameters.
In contrast, Deep Reinforcement Learning (DRL) [ 25,26] algo-
rithms combine reinforcement learning with the directed search to evolve neural networks with a large number of parameters.
In contrast, Deep Reinforcement Learning (DRL) [ 25,26] algo-
rithms combine reinforcement learning with the directed search
power of gradient-based methods in order to learn a single solu-
tion. DRL can surpass human performance at video games [ 40],
beat world champions in board games [ 35] and control complex
robots in continuous action spaces [ 17], which is a long-standing
challenge in artificial intelligence. Policy Gradient methods have
shown state-of-the-art results to learn large neural network policies
with thousands of parameters in high-dimensional state space and
continuous action space [18, 24, 36].
PGA-MAP-Elites [ 28] is an extension of MAP-Elites that inte-
grates the sample efficiency of DRL using the TD3 algorithm [ 15].arXiv:2303.03832v1  [cs.NE]  7 Mar 2023 This algorithm uses a Policy Gradient (PG) variation operator for
efficient fitness improvement, coupled with the usual Genetic Algo-
rithm (GA) variation operator. The PG variation operator leverages
gradients derived from DRL to improve fitness and drive mutations
towards the global optimum and is supported by the divergent
search of the GA variation operator for both exploration and opti-
mization [ 10]. Other recent works have also introduced methods to
combine the strength of QD algorithms with reinforcement learn-
ing [31, 38] on complex robotics tasks.
PGA-MAP-Elites achieves state-of-the-art performances in most
of the environments considered so far in the literature [ 28,31,38].
However, the PG variation operator becomes ineffective in tasks
where the global optimum is in an area of the search space that is
not likely to produce offspring that are added to the archive. For
example, consider a locomotion task where the fitness is the oppo-
site of the energy consumption and the descriptor is defined as the
final position of the robot. The global optimum for the fitness is the
solution that does not move in order to minimize energy consump-
tion. Thus, the PG variation operator will encourage solutions to
stay motionless, collapsing their descriptors to a single point, the
descriptor of the global optimum. Consequently, the PG variation
operator generates offspring that are discarded and no interesting
stepping stone is found, thereby hindering diversity.
In this work, we introduce Descriptor-Conditioned Gradients
MAP-Elites (DCG-MAP-Elites) that builds upon PGA-MAP-Elites
algorithm by enhancing the PG variation operator with a descriptor-
conditioned critic that provides gradients depending on a target de-
scriptor. The descriptor-conditioned critic takes as input a state and
a descriptor to evaluate actions. With such a descriptor-conditioned
critic, the PG variation operator can mutate solutions to produce
offspring with higher fitness while targeting a desired descriptor,
thereby avoiding to collapse the descriptor to a single point.
Furthermore, TD3 which is the DRL algorithm used by the PG
variation operator, requires to train an actor and a critic in parallel.
We take advantage of this intertwined actor-critic training to make
the actor descriptor-conditioned as well, allowing it to take actions
based on the current state and on an input descriptor we want to
achieve. Thus, instead of taking actions that maximize the fitness
globally, the actor now takes actions that maximize the fitness
while achieving a desired descriptor. At the end of training, we
can condition the actor on a desired descriptor to execute a policy
that takes actions that achieve the desired descriptor. On half of
the tasks, we observe that the descriptor-conditioned actor can
achieve the entire range of descriptors contained in the archive
with a similar QD-score, negating the burden of dealing with a
collection of thousands of solutions.
In summary, we present two contributions: (1) we enhance the
PG variation operator with a descriptor-conditioned critic, (2) we
distill the knowledge of the archive into one single versatile policy
at no additional cost. We compare our algorithm to four state-of-the-
art QD algorithms on four high-dimensional robotics locomotion
tasks. The results demonstrate that DCG-MAP-Elites has a QD-
score 82% higher than PGA-MAP-Elites on average.2 BACKGROUND
2.1 Problem Statement
We consider an agent sequentially interacting with an environment
at discrete time steps ğ‘¡for an episode of length ğ‘‡. At each time step
ğ‘¡, the agent observes a state ğ‘ ğ‘¡, takes an action ğ‘ğ‘¡and receives a
scalar reward ğ‘Ÿğ‘¡. We model it as a Markov Decision Process (MDP)
which comprises a state spaceS, a continuous action spaceA, a
stationary transition dynamics distribution ğ‘(ğ‘ ğ‘¡+1|ğ‘ ğ‘¡,ğ‘ğ‘¡)and a
reward function ğ‘Ÿ:SÃ—Aâ†’ R. In this work, a policy (also called
solution ) is a deterministic neural network parameterized by ğœ™âˆˆÎ¦, stationary transition dynamics distribution ğ‘(ğ‘ ğ‘¡+1|ğ‘ ğ‘¡,ğ‘ğ‘¡)and a
reward function ğ‘Ÿ:SÃ—Aâ†’ R. In this work, a policy (also called
solution ) is a deterministic neural network parameterized by ğœ™âˆˆÎ¦,
and denoted ğœ‹ğœ™:Sâ†’A . The agent uses its policy to select actions
and interact with the environment to give a trajectory of states,
actions and rewards. The fitness of a solution is given by ğ¹:Î¦â†’R,
defined as the expected discounted return Eğœ‹ğœ™Ãğ‘‡âˆ’1
ğ‘¡=0ğ›¾ğ‘¡ğ‘Ÿğ‘¡
.
The objective of QD algorithms in this MDP setting is to find
the highest-fitness solutions in each point of the descriptor space
D. The descriptor function ğ·:Î¦â†’D is generally defined by the
user and characterize solutions in a meaningful way for the type of
diversity desired. With this notation, our objective is to evolve a
population of solutions that are both high-performing with respect
toğ¹and diverse with respect to ğ·.
2.2 MAP-Elites
Multi-dimensional Archive of Phenotypic Elites (MAP-Elites) [ 27]
is a simple yet effective QD algorithm that discretizes the descriptor
spaceDinto a multi-dimensional grid of cells called archive Xand
searches for the best solution in each cell, see Alg. 4. The goal of the
algorithm is to return an archive that is filled as much as possible
with high-fitness solutions. MAP-Elites starts by generating ran-
dom solutions and adding them to the archive. The algorithm then
repeats the following steps until a budget of ğ¼solutions have been
evaluated: (1) a batch of solutions from the archive are uniformly
selected and modified through mutations and/or crossovers to pro-
duce offspring, (2) the fitnesses and descriptors of the offspring are
evaluated, and each offspring is placed in its corresponding cell if
and only if the cell is empty or if the offspring has a better fitness
than the current solution in that cell, in which case the current
solution is replaced. As most evolutionary methods, MAP-Elites
relies on undirected updates that are agnostic to the fitness objec-
tive. With a Genetic Algorithm (GA) variation operator, MAP-Elites
performs a divergent search that may cause slow convergence in
high-dimensional problems due to a lack of directed search power,
and thus, is performing best on low-dimensional search space [ 28].
2.3 Deep Reinforcement Learning
Deep Reinforcement Learning (DRL) [ 25,26] combines the rein-
forcement learning framework with the function approximation
capabilities of deep neural networks to represent policies and value
functions in high-dimensional state and action spaces. In opposition
to black-box optimization methods like evolutionary algorithms,
DRL leverages the structure of the MDP in the form of the Bellman
equation to achieve better sample efficiency. The objective is to
find an optimal policy ğœ‹ğœ™, which maximizes the expected return or
fitnessğ¹(ğœ‹ğœ™). In reinforcement learning, many approaches try to
estimate the action-value function ğ‘„ğœ‹(ğ‘ ,ğ‘)=Eğœ‹Ãğ‘‡âˆ’1
ğ‘¡=0ğ›¾ğ‘¡ğ‘Ÿğ‘¡|ğ‘ ,ğ‘
2 defined as the expected discounted return starting from state ğ‘ ,
taking action ğ‘and thereafter following policy ğœ‹.
The Twin Delayed Deep Deterministic Policy Gradient (TD3)
algorithm [ 15] is an actor-critic, off-policy reinforcement learn-
ing method that achieves state-of-the-art results in environments
with large and continuous action space. TD3 indirectly learns a
policyğœ‹ğœ™via maximization of the action-value function ğ‘„ğœƒ(ğ‘ ,ğ‘).
The approach is closely connected to Q-learning [ 15] and tries
to approximate the optimal action-value function ğ‘„âˆ—(ğ‘ ,ğ‘)in or-
der to find the optimal action ğ‘âˆ—(ğ‘ )=arg maxğ‘ğ‘„âˆ—(ğ‘ ,ğ‘). How-
ever, computing the maximum over action in maxğ‘ğ‘„ğœƒ(ğ‘ ,ğ‘)is in-
tractable in continuous action space, so it is approximated using
maxğ‘ğ‘„ğœƒ(ğ‘ ,ğ‘)=ğ‘„ğœƒ(ğ‘ ,ğœ‹ğœ™(ğ‘ )). In TD3, the policy ğœ‹ğœ™takes actions
in the environment and the transitions are stored in a replay buffer.
The collected experience is then used to train a pair of critics ğ‘„ğœƒ1,
ğ‘„ğœƒ2using temporal difference and target networks ğ‘„ğœƒ1â€²,ğ‘„ğœƒ2â€²are
updated to slowly track the main networks. Both critics use a single
regression target ğ‘¦, calculated using whichever of the two critics
gives a smaller target value and using target policy smoothing by
sampling a noise ğœ–âˆ¼clip(N(0,ğœ),âˆ’ğ‘,ğ‘):
ğ‘¦=ğ‘Ÿ(ğ‘ ğ‘¡,ğ‘ğ‘¡)+ğ›¾min
ğ‘–=1,2ğ‘„ğœƒğ‘–â€²
ğ‘ ğ‘¡+1,ğœ‹ğœ™â€²(ğ‘ ğ‘¡+1)+ğœ–
(1)
Both critics are learned by regression to this target and the policy
is learned with a delay, only updated every Î”iterations simply by
maximizing ğ‘„ğœƒ1withmaxğœ™E
ğ‘„ğœƒ1(ğ‘ ,ğœ‹ğœ™(ğ‘ ))
. The actor is updated
using the deterministic policy gradient:
âˆ‡ğœ™ğ½(ğœ™)=Eh
âˆ‡ğ‘ğ‘„ğœƒ1(ğ‘ ,ğ‘)|ğ‘=ğœ‹ğœ™(ğ‘ )âˆ‡ğœ™ğœ‹ğœ™(ğ‘ )i
(2)
2.4 PGA-MAP-Elites
Policy Gradient Assisted MAP-Elites (PGA-MAP-Elites) [ 28] is an
extension of MAP-Elites that is designed to evolve deep neural
networks by combining the directed search power and sample effi-
ciency of DRL methods with the exploration capabilities of genetic
algorithms, see Alg. 5. The algorithm follows the usual MAP-Elites
loop of selection, variation, evaluation and addition for a budget of
ğ¼iterations, but uses two parallel variation operators: half of the
offspring are generated using a standard Genetic Algorithm (GA)
variation operator and half of the offspring are generated using
a Policy Gradient (PG) variation operator. During each iteration
of the loop, PGA-MAP-Elites stores the transitions from offspring
evaluation in a replay buffer Band uses it to train a pair of critics
based on the TD3 algorithm, described in Alg. 6. The trained critic
is then used in the PG variation operator to update the selected
solutions from the archive for ğ‘šgradient steps to select actions
that maximize the approximated action-value function, as described
in Alg. 7. At each iteration, the critics are trained for ğ‘›steps of
gradients descents towards the target described in Eq. 1 averaged
overğ‘transitions of experience sampled uniformly from the replay
bufferB. The actor (also named greedy actor [ 28]) learns with a
delay Î”via maximization of the critic according to Eq. 2.
3 RELATED WORK
3.1 Scaling QD to Neuroevolution
The challenge of evolving diverse solutions in a high-dimensional
search space has been an active research subject over the recentyears. ME-ES [ 5] scales MAP-Elites to high-dimensional solutions
parameterized by large neural networks. This algorithm leverages
Evolution Strategies to perform a directed search that is more effi-
cient than random mutations used in Genetic Algorithms. Fitness
gradients are estimated locally from many perturbed versions of
the parent solution to generate a new one. The population tends
towards regions of the parameter space with higher fitness but it
requires to sample and evaluate a large number of solutions, mak-
ing it particularly data inefficient. In order to use the time step
level information and hence improve data efficiency, methods that
combine MAP-Elites with Reinforcement Learning [ 28,30,31,38]
have emerged and proved to efficiently evolve populations of high- level information and hence improve data efficiency, methods that
combine MAP-Elites with Reinforcement Learning [ 28,30,31,38]
have emerged and proved to efficiently evolve populations of high-
performing and diverse neural network for complex tasks. PGA-
MAP-Elites [ 28] uses policy gradients for part of its mutations, see
section 2.4 for details. CMA-MEGA [ 38] estimates descriptor gradi-
ents with Evolution Strategies and combines the fitness gradient
and the descriptor gradients with a CMA-ES mechanism [ 12,19].
QD-PG [ 31] introduces a diversity reward based on the novelty of
the states visited and derives a policy gradient for the maximiza-
tion of those diversity rewards which helps exploration in settings
where the reward is sparse or deceptive. PBT-MAP-Elites [ 30] mixes
MAP-Elites with a population based training process [ 21] to opti-
mize hyper-parameters of diverse RL agents. Interestingly, recent
work [ 37] scales the algorithm CMA-MAE [ 13] to high-dimensional
policies on robotics tasks with pure Evolution Strategies while
showing comparable data efficiency to QD-RL approaches. It shows
competitiveness but is still outperformed by PGA-MAP-Elites.
3.2 Conditioning the critic
None of the above methods takes a descriptor into account when
deriving policy gradients used to mutate solutions. In other words,
they do not use descriptor-conditioned policies nor descriptor-
conditioned critics as our method DCG-MAP-Elites does. The con-
cept of descriptor-conditioned critic is related to the concept of
Universal Value Function Approximators [ 33] and the most related
field to Quality-Diversity that uses it is Skill Discovery Reinforce-
ment Learning [ 1]. In VIC, DIAYN, DADS, SMERL [ 9,16,23,34],
conditioned actor-critic are used but the condition is a sampled prior
and does not correspond to a real posterior like in DCG-MAP-Elites.
Furthermore, those methods use diversity at the step level and not
explicitly at the trajectory level like ours. Finally, they do not use an
archive to store their population, resulting in much smaller sets of
final policies. Ultimately, it has been shown that behaviors evolved
by QD methods are competitive with skills learned by this family of
methods [ 1], in regards to their use for adaptation and hierarchical
learning.
3.3 Archive distillation
Distilling the knowledge of an archive into a single neural model
is an alluring process that reduces the number of parameters out-
putted by the algorithm and enables generalization and interpo-
lation/extrapolation. Although distillation is usually referring to
policy distillation â€” learning the observation/action mapping from
a teacher policy â€” we present archive distillation as a general term
referring to any kind of knowledge transfer from an archive to
3 another model, should it be the policies, transitions experienced in
the environment, full trajectories or discovered descriptors.
To the best of our knowledge, two QD-related works use the
concept of archive distillation. Go-Explore [ 8] stores an archive of
reached states and trains a goal-conditioned policy to reproduce the
trajectory of the policy that reached that state. Another interesting
approach to archive distillation is to learn a generative policy net-
work [ 22] over the policy contained in the archive. Our approach
DCG-MAP-Elites distills the experience of the archive into a single
versatile policy.
4 DCG-MAP-ELITES
Our new method Descriptor-Conditioned Gradients MAP-Elites
(DCG-MAP-Elites) overcomes limitations of PGA-MAP-Elites by
leveraging a descriptor-conditioned critic to improve the PG varia-
tion operator and concurrently distills the knowledge of the archive
in a single versatile policy as a by-product of the actor-critic train-
ing. The pseudocode is provided in Alg. 1. The algorithm follows
the usual MAP-Elites loop of selection, variation, evaluation and
addition for a budget of ğ¼iterations. Two complementary and inde-
pendent variation operators are used in parallel: 1) a standard GA
operator 2) a descriptor-conditioned PG operator. At each iteration,
the transitions from the evaluation step are stored in a replay buffer
and used to train an actor-critic pair based on TD3.
Contrary to PGA-MAP-Elites, the actor-critic pair is descriptor-
conditioned. In addition to the state ğ‘ and actionğ‘, the criticğ‘„ğœƒ(ğ‘ ,ğ‘|
ğ‘‘)also depends on the descriptor ğ‘‘and estimates the expected dis-
counted return starting from state ğ‘ , taking action ğ‘and thereafter
following policy ğœ‹andachieving descriptor ğ‘‘. Achieving descrip-
torğ‘‘means that the descriptor of the trajectory generated by the
policyğœ‹should have descriptor ğ‘‘. In addition to the state ğ‘ , the
actorğœ‹ğœ™(ğ‘ |ğ‘‘)also depends on the descriptor ğ‘‘and maximizes the
expected discounted return conditioned on achieving descriptor ğ‘‘.
Thus, the goal of the descriptor-conditioned actor is to achieve the
input descriptor ğ‘‘while maximizing fitness.
4.1 Descriptor-Conditioned Critic
Instead of estimating the action-value function with ğ‘„ğœƒ(ğ‘ ,ğ‘), we
want to estimate the descriptor-conditioned action-value function
withğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘). When a policy ğœ‹interacts with the environment
for an episode of length T, it generates a trajectory ğœ, which is a
sequence of transitions:
(ğ‘ 0,ğ‘0,ğ‘Ÿ0,ğ‘ 1),...,(ğ‘ ğ‘‡âˆ’1,ğ‘ğ‘‡âˆ’1,ğ‘Ÿğ‘‡âˆ’1,ğ‘ ğ‘‡)
with descriptor ğ·(ğœ‹)=ğ‘‘. We extend the definition of a transition
(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²)to include the descriptor ğ‘‘of the policy(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘).
Thus, a trajectory ğœwith descriptor ğ‘‘gives a sequence of transitions:
(ğ‘ 0,ğ‘0,ğ‘Ÿ0,ğ‘ 1,ğ‘‘),...,(ğ‘ ğ‘‡âˆ’1,ğ‘ğ‘‡âˆ’1,ğ‘Ÿğ‘‡âˆ’1,ğ‘ ğ‘‡,ğ‘‘)
However, the descriptor is only available at the end of the episode,
therefore the transitions can only be augmented with the descriptor
after the episode is done. In all the tasks we consider, the reward
function is positive ğ‘Ÿ:SÃ—Aâ†’ R+and hence, the fitness function
ğ¹and action-value function are positive as well. Thus, for any
sampled descriptor ğ‘‘â€²âˆˆD, we define the descriptor-conditioned
critic as equal to the normal action-value function when the policy
achieves the sampled descriptor ğ‘‘â€²and as equal to zero when theAlgorithm 1 DCG-MAP-Elites
Input: batch sizeğ‘, number of GA variations ğ‘”â‰¤ğ‘
Initialize archiveXwithğ‘random solutions and replay buffer B
Initialize critic networks ğ‘„ğœƒ1,ğ‘„ğœƒ2and actor network ğœ‹ğœ™
ğ‘–â†0
whileğ‘–<ğ¼do
train_actor_critic (ğ‘„ğœƒ1,ğ‘„ğœƒ2,ğœ‹ğœ™,B)
ğœ‹ğœ“1,...,ğœ‹ ğœ“ğ‘â†selection(X)
ğœ‹bğœ“1,...,ğœ‹ bğœ“ğ‘”â†variation_ga(ğœ‹ğœ“1,...,ğœ‹ ğœ“ğ‘”)
ğœ‹bğœ“ğ‘”+1,...,ğœ‹ bğœ“ğ‘â†variation_pg(ğœ‹ğœ“ğ‘”+1,...,ğœ‹ ğœ“ğ‘,ğ‘„ğœƒ1,B)
addition(ğœ‹bğœ“1,...,ğœ‹ bğœ“ğ‘,X,B)
ğ‘–â†ğ‘–+ğ‘
function addition (X,B,ğœ‹ğœ™,ğœ‹bğœ“...)
forğ‘‘â€²âˆˆD sampled from ğ‘solutions inXdo
(ğ‘“,transitions)â†ğ¹(ğœ‹ğœ™(.|ğ‘‘â€²))
insert(B,transitions)
forğœ‹bğœ“...do
(ğ‘“,transitions)â†ğ¹(ğœ‹bğœ“),ğ‘‘â†ğ·(ğœ‹bğœ“)
insert(B,transitions)
ifX(ğ‘‘)=âˆ…orğ¹(X(ğ‘‘))<ğ‘“then
X(ğ‘‘)â†ğœ‹bğœ“
policy does not achieve the sampled descriptor ğ‘‘â€². Given a transition
(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘), andğ‘‘â€²âˆˆD,
ğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘â€²)=(
ğ‘„ğœƒ(ğ‘ ,ğ‘),ifğ‘‘=ğ‘‘â€²
0, ifğ‘‘â‰ ğ‘‘â€²(3) insert(B,transitions)
ifX(ğ‘‘)=âˆ…orğ¹(X(ğ‘‘))<ğ‘“then
X(ğ‘‘)â†ğœ‹bğœ“
policy does not achieve the sampled descriptor ğ‘‘â€². Given a transition
(ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘), andğ‘‘â€²âˆˆD,
ğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘â€²)=(
ğ‘„ğœƒ(ğ‘ ,ğ‘),ifğ‘‘=ğ‘‘â€²
0, ifğ‘‘â‰ ğ‘‘â€²(3)
However, with this piecewise definition, the descriptor-conditioned
action-value function is not continuous and violates the universal
approximation theorem continuity hypothesis [ 20]. To address this
issue, we introduce a similarity function ğ‘†:D2â†’]0,1]defined
asğ‘†(ğ‘‘,ğ‘‘â€²)=ğ‘’âˆ’||ğ‘‘âˆ’ğ‘‘â€²||D
ğ‘™ to smooth the descriptor-conditioned critic
and relax Eq. 3 into:
ğ‘„ğœƒ(ğ‘ ,ğ‘|ğ‘‘â€²)=ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘„ğœƒ(ğ‘ ,ğ‘)=ğ‘†(ğ‘‘,ğ‘‘â€²)Eğœ‹""ğ‘‡âˆ’1âˆ‘ï¸
ğ‘¡=0ğ›¾ğ‘¡ğ‘Ÿğ‘¡ğ‘ ,ğ‘#
=Eğœ‹""ğ‘‡âˆ’1âˆ‘ï¸
ğ‘¡=0ğ›¾ğ‘¡ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿğ‘¡ğ‘ ,ğ‘#
(4)
With Eq. 4, we demonstrate that learning the descriptor-conditioned
critic is equivalent to scaling the reward by the similarity ğ‘†(ğ‘‘,ğ‘‘â€²)
between the descriptor of the trajectory ğ‘‘and the sampled descrip-
torğ‘‘â€². Therefore, the critic target in Eq. 1 is modified to include the
similarity scaling and the descriptor-conditioned actor:
ğ‘¦=ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿ(ğ‘ ğ‘¡,ğ‘ğ‘¡)+ğ›¾min
ğ‘–=1,2ğ‘„ğœƒğ‘–â€²
ğ‘ ğ‘¡+1,ğœ‹ğœ™â€²(ğ‘ ğ‘¡+1|ğ‘‘â€²)+ğœ–|ğ‘‘â€²
(5)
If the sampled descriptor ğ‘‘â€²is approximately equal to the observed
descriptorğ‘‘of the trajectory ğ‘‘â‰ˆğ‘‘â€²then we have ğ‘†(ğ‘‘,ğ‘‘â€²)â‰ˆ1so the
reward is unchanged. However, if the descriptor ğ‘‘â€²is very different
from the observed descriptor ğ‘‘then, the reward is scaled down to
ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿ(ğ‘ ğ‘¡,ğ‘ğ‘¡)â‰ˆ0. The scaling ensures that the magnitude of the
reward depends not only on the quality of the action ğ‘with regards
to the fitness function ğ¹, but also on achieving the descriptor ğ‘‘â€².
Given one transition (ğ‘ ,ğ‘,ğ‘Ÿ,ğ‘ â€²,ğ‘‘), we can generate infinitely many
critic updates by sampling ğ‘‘â€²âˆˆD. This is leveraged in the new
4 actor-critic training introduced with DCG-MAP-Elites, which is
detailed in Alg. 2 and section 4.3.
Algorithm 2 Descriptor-conditioned Actor-Critic Training
function train_actor_critic (ğ‘„ğœƒ1,ğ‘„ğœƒ2,ğœ‹ğœ™,B)
forğ‘¡=1â†’ğ‘›do
Sampleğ‘transitions(ğ‘ ,ğ‘,ğ‘Ÿ(ğ‘ ,ğ‘),ğ‘ â€²,ğ‘‘,ğ‘‘â€²)fromB
Sample smoothing noise ğœ–
ğ‘¦â†ğ‘†(ğ‘‘,ğ‘‘â€²)ğ‘Ÿ(ğ‘ ,ğ‘)+ğ›¾min
ğ‘–=1,2ğ‘„ğœƒâ€²
ğ‘–"," This paper presents DCG-MAP-Elites, a Quality-Diversity algorithm that combines deep reinforcement learning with MAP-Elites to generate collections of diverse and high-performing solutions. The algorithm uses a descriptor-conditioned critic and policy to improve the archive across the entire descriptor space. Results show that DCG-MAP-Elites outperforms the previous state-of-the-art, PGA-MAP-Elites, on omnidirectional tasks while maintaining similar performance on unidirectional tasks. The paper also provides hyperparameters for DCG-MAP-Elites and all baselines."
42," A Computer Vision Enabled damage detection model with
improved YOLOv5 based on Transformer Prediction Head
Arunabha M. Roy1and Jayabrata Bhaduri2
1Aerospace Engineering Department, University of Michigan, Ann Arbor, MI
48109, USA
2Capacloud AI, Deep Learning &Data Science Division, Kolkata, WB 711103,
India.
Abstract
Objective. Computer vision-based up-to-date accurate damage classification and localization
are of decisive importance for infrastructure monitoring, safety, and the serviceability of civil
infrastructure. Current state-of-the-art deep learning (DL)-based damage detection models,
however, often lack superior feature extraction capability in complex and noisy environments,
limiting the development of accurate and reliable object distinction. Method. To this end,
we present DenseSPH-YOLOv5, a real-time DL-based high-performance damage detection
model where DenseNet blocks have been integrated with the backbone to improve in preserving
and reusing critical feature information. Additionally, convolutional block attention modules
(CBAM) have been implemented to improve attention performance mechanisms for strong and
discriminating deep spatial feature extraction that results in superior detection under various
challenging environments. Moreover, an additional feature fusion layers and a Swin-Transformer
Prediction Head (SPH) have been added leveraging advanced self-attention mechanism for more
efficient detection of multiscale object sizes and simultaneously reducing the computational
complexity. Results. Evaluating the model performance in large-scale Road Damage Dataset
1arXiv:2303.04275v1  [cs.CV]  7 Mar 2023 2
(RDD-2018), at a detection rate of 62.4 FPS, DenseSPH-YOLOv5 obtains a mean average
precision (mAP) value of 85 :25%, F1-score of 81 :18%, and precision (P) value of 89 :51%
outperforming current state-of-the-art models. Significance. The present research provides
an effective and efficient damage localization model addressing the shortcoming of existing
DL-based damage detection models by providing highly accurate localized bounding box
prediction. Current work constitutes a step towards an accurate and robust automated damage
detection system in real-time in-field applications.
Keywords: Automated damage detection; You Only Look Once (YOLOv5) algorithm; Swin
Transformer Object Detection (OD); Computer vision; Deep Learning (DL)
1. Introduction :
In recent years, automated damage detection plays an important role in various industrial
applications including product quality assessment (Agarwal and Singh, 2015; Hanzaei et al.,
2017), infrastructure monitoring (Eisenbach et al., 2017; Gopalakrishnan, 2018), safety and
the serviceability of civil infrastructure (Koch et al., 2015; Hartmann and Trappey, 2020).
Early-stage accurate crack detection is critical for pavement damage rating and subsequent
sealing or rehabilitation activities (Chen et al., 2021; Chen and Cho, 2022). Therefore, it
is important for roadway infrastructure engineers to detect pavement cracks accurately so
that the best cost-effective plans of maintenance and rehabilitation could be employed (Ni
et al., 2022; Dong et al., 2021). While traditional damage detection techniques mainly include
visual inspection, however, such labor-intensive methods have disadvantages due to their low
efficiency, high cost, and individual biases (Xu et al., 2022; Shang et al., 2023). Additionally, it
is also limited in reproducibility, reliability, and objectivity due to the requirement of qualified
personnel for domain-specific experience, knowledge, and skill sets (Fang et al., 2020). To
circumvent such issues, more recently, various automatic and semi-automatic crack detection
algorithms have gained significant attraction (Gopalakrishnan, 2018).
For the last three decades, image-based crack detection (Mohan and Poobal, 2018; Koch
et al., 2015) that include various image processing approaches, such as edge detection (Zhao 3
et al., 2010; Hanzaei et al., 2017; Li et al., 2022), dynamic thresholding (Oliveira and Correia,
2009; Wang et al., 2021b), and different morphological operations (Anitha et al., 2021; Li
and Zhao, 2021) have been the central focus for detecting damage in challenging real-world
scenarios. However, the aforementioned methods are quite sensitive to noise and varying
illumination intensities, and hence, not suitable in real-world complex conditions (Koch et al.,
2015). To circumvent such issues, later, conventional machine learning (ML) approaches
have been introduced for damage detection (Mohan and Poobal, 2018; Koch et al., 2015). In
general, such methods utilize a trained classifier such as a Support Vector Machine (SVM)
on local feature descriptors that can be either Local Binary Patterns (LBP) (Varadharajan
et al., 2014; Quintana et al., 2015) or Histogram of Oriented Gradient (HOG) (Kapela et al.,
2015). Although, compared to conventional image processing approaches, ML-based models
significantly improve the accuracy and efficiency of the damage detection, however, due to large
errors in classification performances remains a serious bottleneck for deploying such models in
real-world applications (Fang et al., 2020).
More recently, deep learning (DL) characterized by multilayer neural networks (NN) (LeCun
et al., 2015) has shown remarkable breakthroughs in pattern recognition for various fields
including image classification (Rawat and Wang, 2017; Jamil et al., 2022; Khan et al., 2022b,a),
computer vision (Voulodimos et al., 2018; Roy and Bhaduri, 2021; Roy et al., 2022c; Roy and
Bhaduri, 2022; Roy et al., 2022a), object detection (Zhao et al., 2019a; Chandio et al., 2022;
Roy et al., 2022b; Singh et al., 2023a), brain-computer interfaces (Roy, 2022b,a,c; Singh et al.,
2023b), signal classification (Jamil and Roy, 2023, 2022) and across diverse scientific disciplines
(Bose and Roy, 2022; Roy and Bose, 2023b; Roy and Guha, 2022; Roy and Bose, 2023a; Roy
and Guha, 2023). Following the success, there is an increasing thrust of research works geared
towards damage classification tasks employing DL techniques, mostly convolutional neural
networks (CNN), such as ResNet (Bang et al., 2018), AlexNet (Dorafshan et al., 2018; Li
et al., 2018), VGG-net (Gopalakrishnan et al., 2017; Silva and Lucena, 2018) and various
others (Chow et al., 2020; Nath et al., 2022; Li et al., 2021). Particularly in object localization,
DL methods have demonstrated superior accuracy (Han et al., 2018) that can be categorized
into two classes: two-stage and one-stage detector (Lin et al., 2017a). Two-stage detectors
including Region Convolution Neural Network (R-CNN) (Girshick, 2015), faster R-CNN (Ren 4
et al., 2016), mask R-CNN (He et al., 2017) etc that have shown a significant improvement
in accuracy in object localization. In recent times, You Only Look Once (YOLO) variants
(Redmon et al., 2016; Redmon and Farhadi, 2017, 2018; Bochkovskiy et al., 2020) have been
proposed that unify target classification and localization. In (Roy et al., 2022c; Roy and
Bhaduri, 2022, 2021), DenseNet (Huang et al., 2017) blocks attaching Spatial Pyramid Pooling
(SPP) (He et al., 2015) with an improved modified Path Aggregation Network (PANet) (Liu
et al., 2018) has been integrated to enhance the representation of receptive fields and extraction
of important contextual features in the original YOLOv4 leading to significant improvement in
the detection speed and accuracy. In order to enhance gradient performance and reduce the
computational cost, YOLOv4 (Bochkovskiy et al., 2020) designs a cross-stage partial (CSP)
network. To further improve detection accuracy, YOLOv4 implements Mish activation (Misra,
2020) and CIoU loss (Zheng et al., 2020). Recently, Scaled-YOLOv4 (Wang et al., 2021a)
demonstrated its superior performance in detecting the vast range of linearly scaled objects for
various applications. As the latest generation of the YOLO series, the YOLOv5 (Jocher et al.,
2021) has been rated top among state-of-the-art object detection models which inherit all the
above advantages. Thus, in the present work, YOLOv5 has been considered a benchmark model
for multiclass damage detection. More recently, improved YOLOv5 Based on Transformer
Prediction Head (TPH-YOLOv5) (Zhu et al., 2021) has been proposed integrating convolutional
block attention module (CBAM) (Woo et al., 2018) for closely packed object detection and
Swin Transformer-enabled YOLOv5 (SPH-YOLOv5) (Gong et al., 2022) has been designed
incorporating Normalization-based Attention Modules (NAM) that demonstrate significant
improvement in accuracy while simultaneously reducing the computational complexity of the
model which are the main motivations for the network architectural development of the current
work.
1.1 Related Works :
In this section, some recent and relevant DL works have been highlighted in the field of road
damage detection. In recent years, multiple studies have adopted various ML and DL-based
approaches for automated road surface damage classification and detection (Zhang et al., 2017a; 5
Stricker et al., 2019; Bi cici and Zeybek, 2021) For instance, a smartphone-based supervised deep
convolutional neural network (D-CNN) has been proposed for pavement damage classification
(Zhang et al., 2016). Along a similar line, deep neural network (DNN) architecture has been
employed for detecting cracks and potholes (Anand et al., 2018; Silva and Lucena, 2018) as well
as pavement condition assessment (Fan et al., 2018). In Nhat-Duc et al. (2018), the superiority
of the DCNN-based approach has been demonstrated over edge-detection-based approaches for
pavement crack detection. In Maeda et al. (2018), a real-time road damage detection model
based on SDD has been proposed that has been trained on a publicly available large-scale
road damage dataset (RDD-2018) for eight different categories of road damages. Due to the
popularity of the dataset, various attempts have been made, notably using YOLO (Alfarrarjeh
et al., 2018), Faster R-CNN (Kluger et al., 2018), Faster R-CNN with ResNet-152 (Wang et al.,
2018a), Ensemble models with Faster R-CNN and SSD (Wang et al., 2018b), and RetinaNet
(Angulo et al., 2019) to further improve the detection performance. In addition, RetinaNet
(Angulo et al., 2019) has been used on a modified RDD-2018 dataset which demonstrates
significant performance improvement. Following the work of Maeda et al. (2018), progressive
growing- generative adversarial networks (PG-GANs) (Maeda et al., 2021) with Poisson blending
have been used to generate new training data (RDD-2019) in order to improve the accuracy of
road damage detection. More recently, transfer learning (TL)-based road damage detection
model (Arya et al., 2021a) has been proposed introducing large-scale open-source dataset
RDD2020 (Arya et al., 2020, 2021b) considering multiple countries. In Naddaf-Sh et al. (2020),
EfficientDet-D7 has been employed for the detection of asphalt pavement distress. Whereas,
YOLO CSPDarknet53 (Mandal et al., 2020) has been used for road damage detection. Similarly,
the YOLO network has been used for detecting pavement distress from high-resolution images
(Du et al., 2021). In Majidifard et al. (2020), YOLOv2 model has been utilized for pavement
distress classification from Google street view images. Along a similar line, a CNN-based
predictive model trained in Google API images has been employed for detecting potholes
in Patra et al. (2021). In a separate work in Guan et al. (2021), a stereo-vision integrated
segmentation-based DL model with modified depth-wise separable convolution U-net has
been deployed for crack and pothole detection where multi-feature image datasets have been
used to train the model. More recently, a semi-supervised DL-based pixel-level segmentation 6
model (Karaaslan et al., 2021) has been proposed utilizing attention guidance for cracks and
spalls localization that reduces computational cost significantly. In separate work, an improved
YOLOv5 road damage detection algorithm (Guo and Zhang, 2022) has been proposed leveraging
MobileNetV3 as a backbone feature extractor. In Hacefendio glu and Ba sa ga (2022), Faster
R-CNN has been employed for concrete pavement crack detection under various illumination and
weather conditions. Although, there exist several state-of-the-art works for damage detection
including multi-class damage localization models, however, they often suffer from low accuracy,
missed detection, and relatively large computational overhead (Cao et al., 2020; Azimi et al.,
2020; Naddaf-Sh et al., 2020).
1.2 Motivations :
Despite illustrating outstanding performance in damage detection, current state-of-the-art
DL algorithms still require further improvement due to their insufficient fine-grain contextual
feature extraction capability leading to missed detection and false object predictions for various
damages/cracks which possess a wide range of textures, shapes, sizes, and colors (Cao et al.,
2020; Azimi et al., 2020; Naddaf-Sh et al., 2020). Between various damage classes, accurate
detection and localization tasks can be challenging due to significant variability of lightening
conditions, low visibility, the coexistence of multi-object classes with various aspect ratios, and
other morphological characteristics (Azimi et al., 2020; Naddaf-Sh et al., 2020). Additionally,
visual similarities, complex backgrounds, and various other critical factors offer additional
difficulties for the state-of-the-art damage detection models (Naddaf-Sh et al., 2020). To
this end, the current works aim to develop an efficient and robust damage classification and
accurate damage localization model simultaneously productive in terms of training time and
computational cost which is currently lacking in the recent state-of-the-art endeavors.
1.3 Contributions :
To address the aforementioned shortcomings, in the current study, we present DenseSPH-YOLOv5
based on an improved version of the state-of-art YOLOv5 detection model for accurate real-time 7
damage detection. The major contributions of the present research work can be summarized as
follows:
â€¢In Dense-SPH-YOLOv5, we have attached DenseNet blocks with CSP modules in the
CSPDarknet53 to preserve critical feature maps and efficiently reuse the discriminating
feature information.
â€¢Secondly, we have introduced an additional detection head specifically for detecting tiny
objects in the head part of the proposed DenseSPH-YOLOv5 network.
â€¢In addition, the convolutional block attention module (CBAM) has been implemented for
the construction of progressive feature attention with large coverage along both channel
and spatial dimensions for strong and discriminating deep spatial feature extraction during
object detection.
â€¢Furthermore, the regular CNN prediction heads (CPH) in YOLOv5 have been upgraded
with Swin transformer Prediction Heads (SPHs) employing Swin transformer (STR)
encoder block leveraging advanced self-attention mechanisms for efficient detection of
multi-scale object sizes and simultaneously reducing the computational complexity.
â€¢Spatial Pyramid Pooling (SPP) has been tightly attached to the backbone to enhance
the representation of receptive fields and extraction of important contextual features.
â€¢Finally, an improved modified Path Aggregation Network (PANet) has been utilized
to efficiently preserve fine-grain localized information by feature fusion in a multi-scale
feature pyramid map.
With the aforementioned modifications, the detection accuracy of the model has been
significantly enhanced for multi-scale object detection. An extensive ablation study has been
performed for different combinations of backbone-neck architecture in order to optimize both
accuracies of detection and detection speed. The proposed DenseSPH-YOLOv5 has been
employed to detect distinct eight different damage classes that provide superior and accurate
detection under various complex and challenging environments. The present work effectively
addresses the shortcoming of existing DL-based crack detection models and illustrates its 8
Figure 1: Sample images from RDD-2018 dataset (Maeda et al., 2018): (a) to (g) correspond
to each of the eight categories with the legends.
superior potential in real-time in-field applications. The rest of the paper is organized as follows:
description of the dataset has been described in Section 2; Section 3 introduces the proposed
methodology for damage detection; the relevant finding and discussion of the proposed model
have been discussed in Sections 4 and 5, respectively. Finally, the conclusions of the present
work have been discussed in section 6.
2. Road Damage Dataset :
In the current study, large-scale Road Damage Dataset (RDD-2018) (Maeda et al., 2018)
has been used that consists of 9,053 labeled road damage images of resolution 600 600 pixels
containing a total number of 15,435 annotated bounding boxes for eight different types of
road damage. To avoid biases, the images have been photographed in various weather and
illumination conditions from different regions of Japan including Chiba, Muroran, Ichihara,
Sumida, Nagakute, and Numazu. During annotation, professional road damage expertise
has been employed to verify various damage classes that ensure the reliability of the dataset.
Various damage types and corresponding class identifiers have been listed in Table. 1. Each 9
Table 1: Various road damage types and corresponding class identifiers in RDD-2018 dataset
(Maeda et al., 2018).
Class
IdentifierDamage
typeAlignment Details
D00 Linear Crack Longitudinal Wheel-marked part
D01 Linear Crack Longitudinal Construction joint part
D10 Linear Crack Lateral Equal interval
D11 Linear Crack Lateral Construction joint part
D20 Alligator Crack - Partial pavement, overall pavement
D40 Other Crack - Pothole, rutting, separation
D43 Other Crack - White line blur
D44 Other Crack - Cross walk blur
type of damages have been illustrated in Fig. 1. Primarily, the damage has been classified into
cracks or different corruptions. Then, the cracks have been divided into linear and alligator
cracks. Whereas, other corruptions include both potholes and rutting as well as other road
damage classes such as blurring of white lines.
3. Proposed Methodology for damage detection:
In object detection, target object classification and localization are performed simultaneously
where the target class has been categorized and separated from the background. The purpose
of object localization is to locate objects by drawing bounding boxes (BBs) on input images
containing the entire object. This is particularly useful for counting endangered species for
accurate surveying. To this end, the main goal of the current work is to develop an efficient and
robust damage classification and accurate damage localization model. In this regard, different
variants of YOLO (Redmon et al., 2016; Redmon and Farhadi, 2017, 2018; Bochkovskiy et al.,
2020) are some of the best high-precision one-stage object detection models. More recently, 10
 
Î· 
d 
wp 
hp 
wgt 
hgt 
(a) (b) Damage  detection  
Input  N Ã—N  grids  
BBs+ confidence  score  
Class probability   
 
 
 
Figure 2: Schematic of (a) YOLO object localization process for damage localization; (b)
Schematic of CIoU offset regression for target BBs predictions.
YOLOv5 (Jocher et al., 2021) has been introduced that currently achieves the best detection
performance and has four different model variants including YOLOv5s, YOLOv5m, YOLOv5l,
and YOLOv5x depend on different model widths and depths. In general, the overall architecture
of YOLOv5 consists of the following parts: a backbone for deep feature extraction, followed by
the neck for gathered semantic feature fusion, and finally head network for object classification
and localization. The original version of YOLOv5 utilizes CSPDarknet53 (Wang et al., 2020;
Bochkovskiy et al., 2020) with SPP and PANet (Liu et al., 2018) as backbone and neck,
respectively. Whereas, YOLO detection head (Redmon et al., 2016) has been employed in
the detection head. The YOLO model transforms the object detection task into a regression
problem by generating BBs coordinates and probabilities for each class as shown in Fig. 2.
During the process, the inputted image size has been uniformly divided into NNgrids where
Bpredictive BBs have been generated. Subsequently, a confidence score has been assigned if
the target object falls inside that particular grid. It detects the target object for a particular
class when the center of the ground truth lies inside a specified grid. During detection, each
grid predicts NBnumbers of BBs with the confidence value  Bas:
B=Pr(obj)IoUt
p_P r(obj)20;1 (1) 11
wherePr(obj) infers the accuracy of BB prediction, i.e., Pr(obj) = 1 indicates that the target
class falls inside the grid, otherwise, Pr(obj) = 0. The degree of overlap between ground truth
and the predicted BB has been described by the scale-invariant evaluation metric intersection
over union (IoU) which can be expressed as
IoU =Bp\Bgt
Bp[Bgt(2)
where BgtandBpare the ground truth and predicted BBs, respectively.
3.1 Loss in BBs regression :
To further improve BBs regression and gradient disappearance, generalized IoU (GIoU)
(Rezatofighi et al., 2019) and distance-IoU (DIoU) (Zheng et al., 2020) as been introduced
considering aspect ratios and orientation of the overlapping BBs. More recently, complete IoU
(CIoU) (Zheng et al., 2020) has been proposed for improved accuracy and faster convergence
speed in BB prediction which can be expressed as
LCIoU= 1 ++2(bp;bgt)
2"," This paper presents a novel deep learning-based damage detection model, DenseSPH-YOLOv5, which integrates DenseNet blocks and convolutional block attention modules (CBAM) to improve feature extraction in complex and noisy environments. The model was tested on the RDD-2018 dataset and achieved superior results in terms of classification accuracy and localized bounding box prediction for all damage classes."
43," Using a Variational Autoencoder  to Learn Valid Search Spaces of 
Safely Monitored Autonomous Robots for Last-M ile Delivery 
Peter J. Bentley 
Department of Computer 
Science, UCL, Autodesk 
Research 
London, United Kingdom  
 p.bentley@cs.ucl.ac.u k Soo Ling Lim 
 Department of Computer 
Science, UCL  
 London, United 
Kingdom  
 s.lim@cs.ucl.ac.uk  Paolo Arcaini 
 National Institute of 
Informatics  
 Tokyo, Japan  
 arcaini@nii.ac.jp  Fuyuki Ishikawa 
National Institute of 
Informatics  
 Tokyo, Japan  
 f-ishikawa@nii.ac.jp  
ABSTRACT  
The use of autonomous robots for delivery of goods to customers 
is an exciting new way to provide a reliable and sustainable 
service. However, in the real world, autonomous robots still require human supervision for safety reasons. We tackle the real -
world problem of optimizing autonomous robot timings to maximize deliveries, while ensuring that there are never too m any 
robots running simultaneously  so that they can be monitored 
safely . We assess the use of a recent  hybrid machine- learning -
optimization approach COIL (constrained optimization in learned 
latent space) and compare it with a baseline  genetic algorithm for 
the purposes of exploring variations of this problem. We also investigate new methods for improving the speed and efficiency 
of COIL . We show that only COIL can find valid solutions where 
appropriate  numbers of robots run simultaneou sly for all problem 
variations tested. We also show that when COIL has learned its latent representation, it can optimize 10% faster than the GA, 
making it a good choice for daily re -optimization of robots where 
delivery requests for each day are allocated to robots while 
maintaining safe numbers of robots running at once.  
CCS CONCEPTS 
â€¢ Computing methodologies~Search methodologies  â€¢ Computing 
methodologies~Learning latent representations  â€¢ C omputing 
methodologies~Robotic planning  
KEYWORDS 
Variational autoencoder , autonomous robots, scheduling, learning 
latent representations , genetic algorithm  
 
  
 1 INTRODUCTION  
Home delivery of groceries and other goods is rapidly becoming a 
major new industry worldwide, accelerated by the COVID 
pandemic. The use of automobiles for last -mile delivery (from 
store to customer) caus es environmental concerns [1] and in 
countries such as Japan  where our problem originates, there may 
be a lack of labor. O ur industry partner , a major electronics 
corporation, is currently trialing their solution: an automatic 
delivery service performed by autonomous robots. Customers 
order goods which are then collected from a supermarket or drug 
store by a robot and delivered to the customer. The robots are 
autonomous but have human monitors that intervene should a 
problem occur, such as a potential collision with a pedestrian , 
Figure 1. The use of robots for this purpose is in the 
experimentation phase, with details such as number of robots and human monitors  still under consideration.  
 
  
Figure 1: Home delivery service using low speed robots with 
human operators performing safety monitoring.  Map shows 
section  of actual location. P. Bentley  et al.  
 
 
 In this real -world problem there is a clear conflict between 
fulfilling orders and maintaining  safety. More robots operating 
simultaneously will mean more orders could be fulfilled, yet too 
many robots operating at once would be dangerous as the human 
operators can only monitor a limited number of robots. The 
problem of how best to schedule  different numbers of robots such 
that maximum orders are delivered safely is therefore difficult.  It 
is also a problem that must be solved repeatedly for every new set of customer orders.  This problem is likely to become increasingly 
relevant as autonomous robot deliveries become more prevalent, 
yet safety is rarely considered in the literature.  
We address this problem by using a hybrid machine learning  
and evolutionary computation approach  [2, 3]. This method  uses a 
variational autoencoder to learn the valid  regions of the search 
space, i.e., the areas of the search space where safe numbers of robots are scheduled to work simultaneously. A genetic algorithm 
(GA) is then used to search in this learned latent space to find 
optimal timings for robots suc h that the maximum number of 
orders can be delivered safely. We compare this approach with a 
baseline  genetic algorithm optimizing robot timings  while solving 
the constraint, without the use of machine learning. We investigate how well both approaches  enable us to examine 
different design variations and we assess suitability for long term 
use once the design variables are determined . 
The contributions of this work can be summarized as follows:  
â€¢ The first study to explore real-world autonomous robot 
routing  while satisfying a safety monitoring requirement. 
â€¢ Adapting the hybrid ML -EA approach (COIL)  [2, 3] to a 
real-world problem for the first time.  
â€¢ Evaluation of COIL by comparing to  a baseline GA to 
explore problem variations,  showing better  solution 
quality and optimization speed for daily robot scheduling.  
â€¢ COIL performance is enhanced on th e problem through  
reduction of the training set and number of latent 
variables.  
The rest of the paper is organized  as follows: Section 2 
provides a literature review of relevant research, Section 3 describes the method, Section  4 describes the experiments , results  
and discusses findings for the problem . We conclude in Section 5. 
2 BACKGROUND  
2.1 Autonomous Robots for Home Delivery 
Autonomous delivery robots have the potential to significantly reduce energy consumption and CO
2 emissions in urban areas  [1]. 
There are several examples of solutions. Mercedes -Benz Vans 
partnered with Starship Technologies to propose the concept of 
autonomous del ivery robots launched from trucks [4]. The truck 
can replenish robots at decentralized depots to launch more  until 
all its customers are supplied. Boysen et al. [4] developed  
scheduling procedures which determine the truck route, such that 
the weighted number of late custom er deliveries is minimized.  
Yu et al. [5] considered a variant of this problem and  proposed 
an LV -SAV (large vehicle - small full y automated ground vehicles) model where multiple LVs cooperate with their 
associated SAVs. Safety was one of their concerns, and having 
slow moving SAVs is safer in urban delivery, and was considered 
to be safer than using drones in the HVDRP (hybrid vehi cle-drone 
routing problem) proposed by Karak and Abdelghany [6]. 
Chen et al. [7] introduced another variant called  a new vehicle 
routing problem with time windows and delivery robots (VRPTWDR). They showed that c onsiderable operational time 
savings can be achieved by dispatching delivery robots to serve 
nearby customers while a driver is also serving a customer . 
Since delivery robots share sidewalks with pedestrians, Bakach 
et al. investigated the option to ch oose paths for them that avoid 
zones with high pedestrian  density  [8]. They  considered  path Since delivery robots share sidewalks with pedestrians, Bakach 
et al. investigated the option to ch oose paths for them that avoid 
zones with high pedestrian  density  [8]. They  considered  path 
flexibility given the presence of zones with varying pedestrian 
level of service .  
The study of vehicle routing problems (VRP) continues to 
develop, with  many  variants includ ing real-life constraints and 
assumptions, which makes the models more realistic and the 
approaches more applicable in practice [9]. Autonomous delivery 
vehicles introduce  safety concerns  whilst driving autonomously 
on the public road networks and performance risk s while 
delivering  parcels (e.g., risk of malfunctioning of the technology) 
[10]. A study of  public perceptions and acceptance of autonomous 
vehicles found that people expressed high concerns around safety, 
cyber -security, legal liability, and regulat ion issues  [11]. 
In this work we focus on safety  and a key component of the 
solution created by our i ndustry collaborator. New to this field, f or 
our problem, human operators monitor the robots so that they can 
manually operate the m when unexpected obstacles are detected , 
or they can talk with the users.  Similar monitoring will be 
required for many other real -world examples, so methods to solve 
this problem are likely to be widely useful. 
2.2 Evolving Latent Variables  
Autoencoder s [12] are neural network s first used for 
dimensionality reduction . Since their inception they have become 
popular for  learning generative models of the data. An 
autoencoder co mprises  two parts - an encoder ğ‘, which maps the 
observations ğ‘¥ to a (lower dimensional) embedding space ğ‘§ and a 
decoder ğ‘, which  maps the embeddings back to the original 
observation space.  When trained, the autoencoder minimizes the 
error in reconstruction of output compared to input.  The 
variational autoencoder (VAE) is a probabilistic autoencoder [13, 
14]. Instead of encoding an observation as a single point, VAEs 
encode it as a distribution over the latent space.  
Recent work in the field of evolutionary computation makes 
use of VAE s to learn representations and then evolve using those 
representations, searching in the latent space  (LVE â€“ latent 
variable evolution). Game levels  [15], fingerprints to foil security 
systems [16], and program synthesis  [17] include some of the 
applications. Researchers also make use of quality -diversity 
approaches  [18] with LVE  to improve optimi zation in high 
dimensional problems, for example DDE -Elites  [19] which uses a 
combination of the direct encoding with a learned latent encoding to accelerate search. Learn ing Valid Search Spaces of Autonomous Robots   
 
 Most recently, COIL (constrained optimization in learned 
latent space) [2] and SOLVE (search space optimization with 
latent variable evolution) [3] present an LVE approach to learn a 
latent rep resentation that is biased towards solutions that satisfy a 
constraint or additional objective. This is very relevant to the real -
world problem we investigate in our work. However, while COIL  
[2] and SOLVE  [3] have been demonstrated on simple constraints 
and benchmark functions, the technique has not been tested on a 
real-world problem. In this work we app ly the concepts in COIL 
for the first time to the problem of scheduling a safe number of 
autonomous robots for home delivery of a maximum number of 
orders by customers .  
3 METHOD  
We base our approach on the system under development  by our 
industry partner. Their automated delivery service will enable 
customers to order goods from a local store which are delivered 
by autonomous robots. Customers submit requests through  an app. 
Each request is scheduled centrally with a robot allocate d to serve 
it. Robots are monitored by human operator s who can intervene if 
the robot encounters problems, helping to initiate the appropriate response in the robot or talk to users , Figure 1. 
We focus on  two stages to this problem: 
1. Investigate possible design variations, with different numbers of robots, human operators, request durations . 
2. On completion of the first stage, provide an efficient method for daily optimizatio n of robot timings.  
For the first stage,  we investigate optimization methods 
capable of exploring design variations . The algorithms must 
successfully  schedul e the robots to maximize delivery of requests 
while ensuring there are never too many robots run ning 
simultaneously, such that the human operators can safely monitor 
them. For the second stage , with the design variables now 
determined,  we investigate the fastest method of scheduling 
robots to meet the human operator constraint, daily , because  this 
decision- making process reoccurs every day with new customer 
requests.  
We formulate the problem as a constrained optimization 
problem.  Given a randomly generated set Reqs  comprising Rq 
customer requests, each with duration Rqdur: 
 Reqs  = {Rqdur
1, .., Rqdur Rq} 
 
where Rqdur j = random[ 60..dr] and given a set of robots Rbts 
comprising Rb pairs of robot starting time Rst and running time  
Rrt: 
 
Rbts = {Rst1, Rrt1, .., R stRb, RrtRb} 
 
allocate each request  Rqdur j in order from j = 1 to Rq (i.e., on a 
first-come, first -served basis) to the most appropriate robot using 
a simple scheduler created for this work , Algorithm 1. (Should 
this solution be commissioned for use on the real robots, this 
algorithm will be replaced with the industrial partnerâ€™s internal 
scheduler.)  Algorithm 1: First -come first -served scheduler used to 
allocate customer requests to robots. totalRm  count s the total 
number of requests met out of a maximum of Rq. 
totalRm  = 0 
for i = 1 to Rb 
    remaining_dur i = RrtiÃ—10 
endfor  
for j = 1 to Rq 
    if there exists a remaining_dur k such that  
        0 <= ( remaining_dur k  - Rqdur j ) < 10 and 
        there are no other  closer matches then 
            remaining_dur k  âˆ’= Rqdur j 
            totalRm  ++ 
            break 
    else find largest remaining_dur k such that  
        ( remaining_dur k  - Rqdur j ) > 0 then 
        remaining_dur k  âˆ’= Rqdur  
        totalRm  ++ 
            break  
endfor  
 The task is then to use an optimizer to find a suitable set of 
Rbts such that the number of requests fulfilled by the robots is 
maximized by efficiently fitting robot start times and running 
times to the set Reqs while ensuring that the number of robots 
running simultaneously at any point in time remains below the maximum robot threshold RT. 
We assume that robots operate 12 hours in a day (e.g., 7am to running simultaneously at any point in time remains below the maximum robot threshold RT. 
We assume that robots operate 12 hours in a day (e.g., 7am to 
7pm)  and they run at a fixed speed . The minimum running time 
for a robot is one hour. Robots only operate for a single period per day. We divide the 12 -hour period into 10 -minute time slots such 
that every start time and duration for each robot may be defined by an integer from 0 to 66, wh ere Rst
i = 0 corresponds to a robot 
start time of 7am and Rrti = 0 corresponds to the minimum 
duration of 1 hour. The set of requests Reqs is built from Rq 
random integers from 60 to 180 (i.e., customer requests take 
robots anything from 60 to 180 minutes  to fulfil). Customer 
requests must be fulfilled within the 7am to 7pm working period 
of robots and goods may be delivered at any point during that 
period for all requests . By default Rq = 120 to present a 
significant challenge for the robots; for experimen ts with shorter 
request durations we double Rq to 240.  
In this work we measure the success of solutions for the 
problem using the objective function  to be maximised : 
ğ‘“(ğ‘¥Ì…)=ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘…ğ‘š  
where totalRm  is the total number of requests from Reqs  allocated 
by the scheduler to the current set of robots Rbts. 
We use a single constraint:  
ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ğ‘…ğ‘ğ‘¡ğ‘  â‰¤ğ‘…ğ‘‡ 
where totalRbts  is the total number of robots working 
simultaneously in any one timeslot.  As a huma n operator must 
monitor each robot in this problem, RT directly correlates  with the 
number of human operators. Figure 2 illustrates the calculation of  
totalRbts. P. Bentley  et al.  
 
 
 Rbts  0-10 10-20 20-30 30-40 40-50 50-60 60-70 70-80 80-90 90-100 100-110 110-120 
1 0 0 0 1 1 1 1 0 0 0 0 0 
2 0 0 0 0 1 1 1 1 1 1 1 1 
3 1 1 1 1 1 0 0 0 0 0 0 0 
4 1 1 1 1 1 1 1 1 1 1 1 1 
+ 2 2 2 3 4 3 3 2 2 2 2 2 
Figure 2: Example calculation showing  totalRbts  = 4, for four 
robots in a two -hour period (ignoring the minimum duration 
of 60 for this example) . If the threshold RT = 2 then the 
constraint would not be met on 4 out of the 12 possible 
timeslots , marked in bold. When totalRbts <= RT  for every 
timeslot for all robots, the constraint is met fully. In this case 
the constraint score being minimized is 4 - 2 = 2.  With the 
constraint not satisfied, this is not a valid solution.  
3.1 Optimization with Genetic Algorithm 
Our baseline approach to address this problem is to use a genetic algorithm to evolve start times and durations for a set of robots 
such that the constraint is met and the objective is  maximized for 
a given set of customer requests Reqs . 
Our search variables 
ğ‘¥Ì… comprise:  
ğ‘¥Ì…=[ğ‘¥!""#,ğ‘¥$""#,..,ğ‘¥!""%&,ğ‘¥$""%&] 
where we map ğ‘¥!""',ğ‘¥$""' to Rsti, Rrti respectively  for every i. Should 
any i exist such that ğ‘¥!""'+ğ‘¥$""'>65 then the corresponding values 
of Rrti is corrected such that the robot ceases its shift at the end of 
the working day.  Values are corrected during this mapping stage 
rather than modifying  the evolving parameters as this has been 
shown to be more conducive to search [20]. During evolution the 
fitness and constraint is calculated as described above. This is the 
worst -case scenario for the constraint as it assumes that every 
robot will run for its maximum permitted time. In reality, after requests have been scheduled some robots may run for shorter 
durations depending on which requests were allocated. Thus , for 
accuracy, o ur reported results for all experiments first updates  
robot durations  according to the scheduler  in Algorithm 1 : 
âˆ€ğ‘–âˆˆ{1..ğ‘…ğ‘}	ğ‘…ğ‘Ÿğ‘¡'âˆ’=Eğ‘Ÿğ‘’ğ‘šğ‘ğ‘–ğ‘›ğ‘–ğ‘› ğ‘”($'/10K 
and then measure s the actual number of scheduled robots that ran 
simultaneously, as shown in Figure 2. 
We use a constrained optimization algorithm [21] using DEAP  
[22] with tournament fitness (see [2] for the algorithm) to enable 
the equal contribution of constraint and objective to evolution.  
This is a widely used approach in constraint -handling used by 
numerous other researchers [23]. In this method, fitness of each 
individual is the number of times its separate criteria win a series 
of tournaments held between randomly selected subgroups  of 3 
individuals. Within each tournament, the fitness  of an individual 
is increased if its solution is better (lower) for the number of times 
the constraint is not satisfied, and also when its solutio n is better 
(higher) for the objective  ğ‘“(ğ‘¥Ì…) compared to the others in the 
tournament.  We use a Gaussian  Integer creep mutation. 
   
Figure 3: Constrained optimization in learned latent space 
(COIL) applied to real -world autonomous robot scheduling 
problem.  
3.2 Optimization with COIL  
We are tackling a challenging constrained optimization problem, so our proposed approach to be compared with the baseline is 
COIL  [2] â€“ a new hybrid machine learning and optimization 
method  designed to learn valid regions of the search space and 
improve the ability of optimizers to find valid solutions. COIL has 
the advantage that , unlike other constrained optimizers, it does not 
rely on complex operators, weight -tuning, or specialized 
expertise. So far COIL has been tested only on simple test 
functions for constrained optimization ; this is the first research to 
apply this approach to a real -world problem.  
COIL operates using three steps  (Figure 3): 
1. Dataset generation from constraint  
2. Learning new latent represen tation from dataset 
3. Optimization using latent representation  using 
constraint and objective  
For the first step, we use a simple genetic algorithm (using 2. Learning new latent represen tation from dataset 
3. Optimization using latent representation  using 
constraint and objective  
For the first step, we use a simple genetic algorithm (using 
DEAP) with a population size of 200 for running for at most 200 
generations. Our search variables 
ğ‘¥Ì… are exactly as described for 
the baseline GA.  The objective function for this data- generation 
GA is minimization of the number of times the constraint  is not 
satisfied , with any solution that satisfies the constraint added to 
the dataset, and the GA restarting. The threshold RT, which 
determines how many robots may work simultaneously , is varied 
during experiments. Solutions that specify robot durations that 
finish beyo nd the 12- hour working period  are corrected as 
described in 3.1 before being normalized and added to the dataset.  
To encourage the dataset -generating GA not to â€œcheatâ€ and only 
provide solutions with minimal robot running times (the simplest 
way to satisfy  the constraint), we also add a selective pressure 
towards longer robot durations by adding 100 âˆ‘ ğ‘¥$""' )%
#â„  to the 
fitness term. We run this GA repeatedly until DS vectors  are 
generated. Each vector represents a valid set of robot start times 
and duration s such that the constraint is satisfied. The overall 
objective to find robot times and durations that enable the most 
customer requests is not used at this point.  
In the second step, we provide  the dataset to a simple 
variational autoencoder [2] with 4 linear layers , a prior  of N(0,I), 
KLD = 1, for 200 epochs using the Adam optimizer with a 
learning rate of 0.001. We run the VAE 10 times and choose the 
learned model with the lowest error. This is our learned latent 
representation , with latent variables:  
ğ‘§Ì…=[ğ‘§#,ğ‘§*,..,ğ‘§*Ã—,-./0] Learn ing Valid Search Spaces of Autonomous Robots   
 
 In the third step, we use the same GA as described in section 
3.1, to ensure a completely fair comparison. For this GA, the 
search variables ğ‘§Ì… are encoded as real -valued variables with 
ranges between -2.0 and 2.0, and a Gaussian creep mutation. We 
convert ğ‘§Ì… into ğ‘¥Ì… by using the learned VAE model  to express the 
values , and then  perform a scalar inverse transform, 
unnormalization, and conversion to intege r to convert the VAE 
output into the desired 0..66 range.  We then map ğ‘¥!""',ğ‘¥$""' to Rsti, 
Rrti respectively  for every i as described in section 3.1  with the 
same robot duration updates performed according to the scheduler  
and use the identical tournament fitness approach to measure 
fitness for the objective and constraint. 
4 EXPERIMENTS 
4.1 Experiments  
We perform experiments to investigate the following research 
questions, which reflect the two stages to this problem : 
 
RQ1: Does COIL help us explore valid design variations more 
effectively than the baseline GA?  
We explore this question in several experiments . 
E1.1: Can the baseline GA and  COIL help us explore valid 
solutions ? Before we can explore different design variations we 
need to check that we can solve this problem at all. Experiment 1 
tackles this by directly comparing the output of the baseline GA with COIL.  Following the training of the VAE within COIL, the 
same learn ed model is used in all repeated runs. We use a small 
population size of 20 for just 50 generations following  [2, 3]. Both 
GAs are run 100 times and mean results are shown.  A new set of 
requests Reqs  is randomly generated for every run.  
E1.2: Can the GA and COIL explore  valid solutions varying 
RT? In this experiment we explore variants  of the problem by 
varying RT to the values: 10, 15, 20. This explores solutions 
where we permit more robots to run simultaneously (at the cost of 
requiring more human monitoring.)  
E1.3: Can the GA and COIL explore  valid solutions varying 
Rb? In the second problem variant, we fix RT to 10 and vary the 
number of robots Rb to the values: 2 0, 25, 30.  This explores 
solutions where we have fewer robots overall, with at most 10 running simultaneously.  
E1.4: Can the GA and COIL explore  valid solutions varying 
dr? In our final set of problem variants, w e vary the duration of 
requests; instead of random from 60 to 180, we try 60 to dr, where 
dr 
âˆˆ {60, 80, ..,  360}.  
For all RQs, parameters other than those being varied remain 
unchanged. COIL is run 100 times for each setting, with a new set Reqs  of random requests each run.  
 
RQ2: Is COIL an efficient algorithm for daily optimization?  
Once the company decides on the number of robots and operators to use, we arrive at the second stage. Here we investigate the 
suitability of COIL for use as a daily optimizer, investigating 
whether the method can be tuned with this goal in mind.  E2.1: Can we use smaller  dataset size s for COIL without 
affect ing its ability to generate usef ul latent representations?  We 
need a fast way of optimizing robot schedules every day for the new set of requests, while always meeting the constraint. O ne 
drawback of COIL is the need to generate a dataset first  and train 
the VAE. Although this is a one -off, offline computation, it is still 
significant . This experiment  addresses this by varying the dataset 
size DS to four different values: 2500, 5000, 7500, 10000. All 
other parameters remain unchanged. COIL is run 100 times (with 
a new set Reqs  of random requests each run) and mean results are 
shown. We also measure the difference in data generation and 
training times and the error rate of the VAE.  
E2.2: Can we imp rove the performance of COIL by reducing 
the number of latent variables?  Here we investigate an idea for 
improving the performance of COIL.  While COIL was described E2.2: Can we imp rove the performance of COIL by reducing 
the number of latent variables?  Here we investigate an idea for 
improving the performance of COIL.  While COIL was described 
as a method to improve the search space while keeping the number of latent variables the sa me as the number of input 
variables, other work has shown that VAEs may be able to provide the additional benefit of reducing the search  space size 
[24]. We investigate this question with the number of robots Rb = 
30 (giving us 60 problem variables) by varying maxlv  to the 
values: 5, 10, 15, 20, 25, 30 (i.e., 10 to 60 latent variables) . All 
other parameters remain unchanged.  COIL is run 100 times for 
each setting, with a new set Reqs  of random requests each run.  
Table 1 summarizes the parameters investigated in each 
experiment. All processing was performed on a MacBook Air 
2020 M1 with 16Gb memory. All code was implemented in 
Python and is available
1. 
 
Table 1. Parameters for the experiments  
Exp DS maxlv  RT Rb dr 
E1.1 10000 30 10 30 180 
E1.2 10000 30 10,15,20  30 180 
E1.3  10000 30 10 20,25,30  180 
E1.4  10000 30 10 30 60..360  
E2.1 2500..10000  30 10 30 180 
E2.2  10000 5..30  10 30 180 
 
4.2 Results  and Analysis 
In this section we describe the results for  research question RQ1 
(experiments E1.1, E1.2, E1.3 and E1.4) and for RQ2 (experiments E2.1 and E2.2).  
 Table 2. E1. 1: COIL vs GA.  Better results in bold.  
 COIL  GA 
avg objective  (stdv) 66.43 (6.80) 93.6 (5.55)  
min objective 51 76 
max objective  77 107 
avg constraint  (stdv) 23.93 ( 8.43) 44.7 (3.89) 
min constraint  0 35 
max constraint  30 52 
 
1 GitHub link temporarily removed for purposes of paper anonymization. P. Bentley  et al.  
 
 
  
Figure 4: Example s ingle best run baseline GA. 
 
 
Figure 5: Example best run COIL . 
 
E1.1: Can the GA and COIL help us explore valid solutions ? 
In this experiment we compare the output of the baseline GA with 
COIL to check that both can find valid solutions for our default 
parameter values. Table 2 summarizes the results. The results 
show that only  COIL is able to provide valid solutions for this 
variant of the problem. COIL provides superior results in terms of constraint satisfaction, with the best results being a perfect zero, 
and average of 23.9, compared t o the baseline GA best of 35 
(worse than the worst score of COIL) and average of 44.7. The scores for the objective shows that GA allocates more tasks on 
average than COIL, managing 107 at best compared to COILâ€™s much lower 77. However, the scores are mean ingless when the 
constraint is broken â€“ the baseline GA cheats by not meeting the 
constraint in order to allocate more requests, and such solutions 
are not viable or useful.  
Examining a single best run for the baseline GA and COIL, 
Figure 4 and Figure 5 show the difference in evolution. The GA 
attempts to improve the constraint while keeping request 
allocation constant but never achieves a single valid solution â€“ 
showing a failure of this algorithm to tackle the problem effectively. In contrast COIL start s better and optimizes the 
constraint to zero very rapidly while keeping the number of requests allocated constant. To assess whether the GA could be 
coerced into focusing more on the constraint, we increased the 
weighting by 10 times in the tournament sel ection algorithm for the constraint; we also tried much larger population sizes and number of generations. The results were barely changed and the 
GA still failed to find any solutions that satisfied the constraint. Figure 4 and Figure 5 (grey line) also show how effectively 
ğ‘¥Ì… is 
being optimized, with both algorithms ensuring that  91% of the 
robotsâ€™ time is being used.  While COIL does not find perfect 
solutions every time for this difficult problem (unlike findings of [2, 3]) it is clear that its learned latent representation is biased 
towards solutions  that satisfy the constraint more, with Figure 6 
top left showing that the baseline GA results (orange cir cles) are 
all worse than the COIL results (blue circles).  
 
E1.2 : Number of simultaneously running robots  RT 
When we increase the value of RT, we make the constraint easier 
as more robots are permitted to run simultaneously. The results show that in all problem variants, COIL successfully finds valid 
solutions to the problem. However, as the optimization problem becomes easier, the baseline GA begins to function more usefully 
(Figure 6 top left). When RT = 10, COIL performs better than the 
baseline GA. When RT = 15, COIL is able to find more solutions 
that satisfy the constraints, while the baseline GA still finds none. But when RT = 20 (the problem is no longer diffic ult) there is no 
longer any significant difference between the GA and COIL, with COIL finding slightly more valid solutions, but the GA finding a 
few solutions that satisfy the constraint and fulfil the objective 
slightly better.  
 
E1.3 : Total n umber of robots  Rb 
Similar to the previous experiment, when we reduce the value of Rb, we make the constraint easier as fewer robots in total are 
running, so fewer are likely to run simultaneously. However, with RT fixed we do not see improvements in objective scores (keeping 
the number of simultaneously running robots constant, limits the number of requests that can be served). When reducing Rb from 
30 to 25, the baseline GA comes closer to finding valid solutions. When Rb = 20, the GA finds several valid solutions. H owever, for 
all values tested, COIL always finds valid solutions to the 
problem, becoming more consistent as the problem is easier 
(Figure 6 top right).  
 E1.4 : Changi ng request durations dr all values tested, COIL always finds valid solutions to the 
problem, becoming more consistent as the problem is easier 
(Figure 6 top right).  
 E1.4 : Changi ng request durations dr 
If we alter the request durations (increasing the number of requests from 120 to 240 to make up for smaller durations), we change the difficulty of the problem in a new way: shorter tasks 
are easier to allocate while longer tasks are more difficult. Figure 
7 shows how the average number of constraints broken slightly 
improves (lowers) as the request duration increases for COIL, 
suggesting that COIL scales better to gre ater problem difficulty. 
As expected, the number of requests that can be allocated falls as the task durations increase, with the baseline GA always allocating more (because it cheats by not satisfying the 
constraint). Figure 6: Best result at final generation for 100 runs  for each algorithm , plotted with objective score against constraint . Lower 
means constraint is better satisfied, more to the right means more tasks are allocated. Only solutions on y = 0 satisfy the c onstraint 
fully and thus are valid. Top left: E1.1 Comparing GA and COIL and E1.2 Varying RT. Top right: E. 1.3 Varying Rb. Bottom left: 
E2.1 Varying  COIL  DS. Bottom right: E2.2 Varying  COIL  maxlv . 
 
 
Figure 7: E1.4: Altering maximum random request durations.  
 
E2.1: Reducing dataset size DS 
The previous  experiments showed that COIL clearly outperforms 
the baseline GA for this real -world problem  â€“ only COIL has 
permitted us to explore valid solutions for all design variations 
tested . However, there is a difference in computation time 
required. When evolving the solutions for E1.1, the baseline GA 
took 1 .89 minutes to complete 100 runs. COIL took a slightly 
shorter 1.81  minutes â€“ despite the additional need to express the 
evolving latent variables into the problem variables using the VAE. However, COI L also required a one -off pre -computation to generate valid data and use the VAE to learn the latent 
representation. This computation was substantial, requiring 25.80 
hours  to generate 10,000 datapoints, and 8.95 minutes for the 
VAE to learn (running 10 ti mes and choosing the best learned 
model, which had loss of 0.9114).  These times reduced when the 
problem was easier, for example in E1.2, 10,000 valid points were generated in just 19.28 minutes when RT = 15, and just 8.08 
minutes when RT = 20.  
In the next experiment, we investigate the effects of the dataset 
size to see if COIL can still achieve acceptable results when the VAE is trained with smaller datasets.  We achieved this by simply 
running the data generator each time with DS = 2500, 5000, 7500, 
and 10000. The datasets were checked to see if they contained any redundancy through duplication; analysis revealed that every 
point in each dataset is unique and not repeated.  
Figure 8 shows the differences in computation time vs the 
VAE loss , indicating that the dataset of size 5000 has the smallest 
loss; detailed results from COIL for the constraint and objective 
for each dataset size  are provided in Supplementary Materials . 
While the best average constraint satisfaction is achieved using 
the largest dataset, performance is still relatively unaffected for 
even the smallest size. Figure 6 (bottom left) shows that valid 
solutions on y = 0 are generated by all dataset sizes, and all also 
have a similar trend in the solution space. P. Bentley  et al.  
 
 
  
E2.2 : Modifying num ber of  latent variables  maxlv  
Finally we investigate whether we can improve the performance 
of COIL in terms of the quality its solutions. Applying COIL with 
different numbers of latent variables shows an important effect on 
the distribution of solutions, Figure 6 (bottom right) and 
Supplementary Materials . Reducing the number of latent variables 
generally improves the ability of COIL to find solutions that satisfy the constraint.  Fewer latent vari ables mean faster training 
time for the VAE, and faster optimization for the GA using the smaller latent representations. But as the number of latent 
variables decreases to 10, the VAE loss becomes worse ( Figure 
9). The smaller search space also appears to impact the objective, 
with fewer tasks being allocated.  
In contrast, increasing to 50 or more latent variables appears to 
provide an unwelcome bias away from valid so lutions on y = 0. 
For this problem, there appears to be a â€œsweet spotâ€ between 
maxlv=15 and maxlv=25 (30 and 50 latent variables  respectively), 
where solutions with high number of request allocations and perfect constraint scores are generated ( Figure 6 bottom right). 
For our problem it appears that having fewer latent variables 
compared to problem variables is advantageous.  
 
 
Figure 8: Computation time and VAE loss  for E2.1 . Bar chart 
using left y-axis: Data generation (hours), VAE training 
(minutes), blue line using right y-axis: VAE loss. 
 
 
Figure 9: Computation time and VAE loss fo r E2.2 . Bar chart 
using left y-axis: VAE training (minutes), blue line using right 
y-axis: VAE loss. 
 4.3 Discussion of Findings Relating to Problem  
COIL has enabled a useful exploration of the design space for this 
real-world problem. Our findings indicated that the amount of 
available time spent by robots delivering requests rarely changes (usually at around 90%). This appears to be the best use of the 
robotsâ€™ time as determined by the scheduler , and both optimizers 
are always able to find appropriate start times and durations for 
the autonomous robots to reach this efficiency. However, results 
from the baseline GA were often unusable as the safety constraint 
was not met. COIL provided usable results for all setups. The experiments also showed that when customer requests were likely 
to take less time, more would be delivered successfully by the robots. The safety constraint was slightly more likely to be 
satisfied by COIL for longer duration requests; for the baseline 
GA there was no difference.  
Over all, COILâ€™s exploration of the problem space  indicate s 
that when we keep the total number of robots Rb constant but 
allow more to run simultaneously (i.e., more human monitors are employed), the number of customer requests tha t can be satisfied 
will increa se. In contrast, if we keep the number of simultaneously 
running robots RT constant and reduce the overall numbers of 
robots that are running, there is little change to the number of 
customer requests met. Thus, with the fixed relationship between 
the numb er of simultaneously running robots and the number of 
human monitors, there appears to be a direct correlation between the number of human monitors and customer satisfaction.   
5 CONCLUSIONS 
The problem of scheduling autonomous robots safely such that sufficient human monitors are available is challenging , and 
relatively  unexplored in the literature . Our work shows that a  
standard genetic algorithm using a well-established method  for 
constrained optimization (the baseline GA ) was unable to find 
solutions tha t satisfied the constraint except for variations where 
the problem was relatively easy. In contrast a new ML -EA hybrid 
approach (constrained optimization in learned latent space: COIL ) 
was able to find valid solutions for all problem variants, enabling 
us to perform a useful investigation of the effects of each approach (constrained optimization in learned latent space: COIL ) 
was able to find valid solutions for all problem variants, enabling 
us to perform a useful investigation of the effects of each 
parameter on solutions. This work has also shown for the first 
time that the data -generation and training stage of COIL can be 
improved by reducing the dataset size and number of latent 
variables. This means that once suitable parameters are selected, 
and the initial one -off training is performed  to learn the latent 
representation , COIL is able to optimize new schedules rapidly 
and reliably. Indeed, with these improvements, COIL is 10% 
faster to run than  the baseline GA. COIL is thus an ideal choice 
for an everyday optimizer for this problem.  
Future work will examine further problem variables of interest 
to our industrial partner such as robot speed and will integrate 
with other schedulers. Other  improvements to COIL will be 
examined, such as the use of more advanced VAEs and optimizers such as MAP -Elites for the data generation and optimization 
stages, to further improve speed and efficiency. Learn ing Valid Search Spaces of Autonomous Robots   
 
 REFERENCES 
[1] M. Figliozzi and D. Jennings, ""Autonomous delivery robots and their potential 
impacts on urban freight energy consumption and emissions,"" Transportation 
research procedia, vol. 46, pp. 21 -28, 2020. 
[2] P. J. Bentley, S. L. Lim, A. Gaier, and L. Tran, ""COIL: Constrained 
Optimi zation in Learned Latent Space --Learning Representations for Valid 
Solutions,"" in ACM Genetic and Evolutionary Computation Conference 
(GECCO'22) Companion , 2022, pp. 1870 â€“1877.  
[3] P. J. Bentley, S. L. Lim, A. Gaier, and L. Tran, ""Evolving through the look ing 
glass: Learning improved search spaces with variational autoencoders,"" in 
International Conference on Parallel Problem Solving from Nature (PPSN) , 
2022, pp. 371 -384. 
[4] N. Boysen, S. Schwerdfeger, and F. Weidinger, ""Scheduling last -mile deliveries 
with truck -based autonomous robots,"" European Journal of Operational 
Research, vol. 271, no. 3, pp. 1085 -1099, 2018.  
[5] S. Yu, J. Puchinger, and S. Sun, ""Two -echelon urban deli veries using 
autonomous vehicles,"" Transportation Research Part E: Logistics and 
Transportation Review, vol. 141, p. 102018, 2020.  
[6] A. Karak and K. Abdelghany, ""The hybrid vehicle -drone routing problem for 
pick-up and delivery services,"" Transportation Research Part C: Emerging 
Technologies, vol. 102, pp. 427 -449, 2019.  
[7] C. Chen, E. Demir, Y. Huang, and R. Qiu, ""The adoption of self -driving 
delivery robots in last mile logistics,"" Transportation research part E: logistics 
and transportation review, vol. 146, p. 102214, 2021.  
[8] I. Bakach, A. M. Campbell, and J. F. Ehmke, ""Robot -Based Last -Mile 
Deliveries With Pedestrian Zones,"" Frontiers in Future Transportation, p. 32, 
2022.  
[9] K. Braekers, K. Ramaekers, and I. Van Nieuwenhuyse, ""The vehicle routing  
problem: State of the art classification and review,"" Computers & industrial 
engineering, vol. 99, pp. 300 -313, 2016.  
[10] S. Kapser and M. Abdelrahman, ""Acceptance of autonomous delivery vehicles 
for last- mile delivery in Germany â€“Extending UTAUT2 with ri sk perceptions,"" 
Transportation Research Part C: Emerging Technologies, vol. 111, pp. 210 -
225, 2020.  
[11] H. Liu, R. Yang, L. Wang, and P. Liu, ""Evaluating initial public acceptance of highly and fully autonomous vehicles,"" International Journal of Human â€“
Computer Interaction, vol. 35, no. 11, pp. 919 -931, 2019.  
[12] G. E. Hinton and R. R. Salakhutdinov, ""Reducing the dimensionality of data 
with neural networks,"" Science, vol. 313, no. 5786, pp. 504 -507, 2006.  [13] D. P. Kingma and M. Welling, ""Auto -encoding  variational bayes,"" in 
Proceedings of the International Conference on Learning Representation (ICLR), 2014.  
[14] Ã–. Yeniay, ""Penalty function methods for constrained optimization with genetic 
algorithms,"" Mathematical and Computational Applications, vol. 10, no. 1, pp. 
45-56, 2005. 
[15] V. Volz, J. Schrum, J. Liu, S. M. Lucas, A. Smith, and S. Risi, ""Evolving Mario 
levels in the latent space of a deep convolutional generative adversarial 
network,"" in Proceedings of the Genetic and Evolutionary Computation 
Conference (GECCO) , 2018, pp. 221 -228. 
[16] P. Bontrager, A. Roy, J. Togelius, N. Memon, and A. Ross, ""Deepmasterp rints: 
Generating masterprints for dictionary attacks via latent variable evolution,"" in 
Proceedings of the 2018 IEEE 9th International Conference on Biometrics 
Theory, Applications and Systems (BTS) , 2018, pp. 1 -9. 
[17] P. Liskowski, K. Krawiec, N. E. Toklu, and J. Swan, ""Program synthesis as latent continuous optimization: Evolutionary search in neural embeddings,"" in 
Proceedings of the 2020 Genetic and Evolutionary Computation Conference , 
2020, pp. 359 -367. 
[18] J. K. Pugh, L. B. Soros, and K. O. Stanley , ""Quality diversity: a new frontier for 
evolutionary computation,"" Frontiers in Robotics and AI, vol. 3, p. 40, 2016. 2020, pp. 359 -367. 
[18] J. K. Pugh, L. B. Soros, and K. O. Stanley , ""Quality diversity: a new frontier for 
evolutionary computation,"" Frontiers in Robotics and AI, vol. 3, p. 40, 2016.  
[19] A. Gaier, A. Asteroth, and J. -B. Mouret, ""Discovering representations for 
black -box optimization,"" in Proceedings of the Genetic and  Evolutionary 
Computation Conference (GECCO) , 2020, pp. 103 -111. 
[20] T. Yu and P. Bentley, ""Methods to evolve legal phenotypes,"" in Proceedings of 
the International Conference on Parallel Problem Solving from Nature (PPSN) , 
1998, pp. 280 -291. 
[21] K. Deb,  ""An efficient constraint handling method for genetic algorithms,"" 
Computer Methods in Applied Mechanics and Engineering, vol. 186, no. 2 -4, 
pp. 311 -338, 2000.  
[22] F.-M. De Rainville, F. -A. Fortin, M. -A. Gardner, M. Parizeau, and C. GagnÃ©, 
""Deap: A python framework for evolutionary algorithms,"" in Proceedings of the 
14th annual conference companion on Genetic and evolutionary computation , 
2012, pp. 85 -92. 
[23] C. A. C. Coello, ""Theoretical and numerical constraint -handling techniques 
used with evolutionary  algorithms: a survey of the state of the art,"" Computer 
methods in applied mechanics and engineering, vol. 191, no. 11 -12, pp. 1245 -
1287, 2002.  
[24] X. Ding, Z. Zou, and C. L. Brooks III, ""Deciphering protein evolution and fitness landscapes with latent s pace models,"" Nature communications, vol. 10, 
no. 1, pp. 1 -13, 2019. SUPPLEMENTA RY MATERIA LS  
 
 
Table S1: E1.2 : Modifying RT:  number of simultaneously running robots , COIL . 
COIL 10 robots at once  15 robots at once  20 robots at once  
avg objective (stdv)  66.43 (6.80)  73.94 (3.99)  89.86 (3.14)  
min objective  51 63 83 
max objective  77 84 98 
avg constraint (stdv)  23.93 (8.43)  9.91 (10.78)  0.81 (2.86)  
min constraint  0 0 0 
max constraint  30 29 16 
 
Table S2: E1.2 : Modifying RT:  number of simultaneously running robots , GA. 
GA 10 robots at once  15 robots at once  20 robots at once  
avg objective (stdv)  93.6 (5.55)  91.09 (5.43)  92.24 (4.32)  
min objective  76 80 80 
max objective  107 108 103 
avg constraint (stdv)  44.7 (3.89)  26.69 (5.56)  0.8 (2.97)  
min constraint  35 10 0 
max constraint  32 41 17 
 Table S3: E1.3: Modifying Rb: total number of robots , COIL . 
COIL 20 total robots  25 total robots  30 total robots  
avg objective (stdv)  50.67 ( 3.63) 57.96 ( 7.59) 66.43 (6.80)  
min objective  44 47 51 
max objective  62 72 77 
avg constraint (stdv)  4.4 (8.4) 15.39 ( 13.13)  23.93 (8.43)  
min constraint  0 0 0 
max constraint  27 32 30 
 Table S4: E1.3: Modifying Rb: total number of robots , GA. 
GA 20 total robots  25 total robots  30 total robots  
avg objective (stdv)  63.47 ( 5.33) 81.01 ( 6.49)  93.6 (5.55)  
min objective  51 64 76 
max objective  75 102 107 
avg constraint (stdv)  23.71 ( 7.97) 38.35 ( 4.71) 44.7 (3.89)  
min constraint  0 26 35 
max constraint  41 48 32 
 
Table  S5: E2.1 : Modifying dataset size  DS 
 2500 data points  5000 data points  7500 data points  10000 data points  
avg objective (stdv)  66.75 (5.87)  68.2 (8.15)  65.45 (8.09)  66.43 (6.80)  
min objective  51 49 48 51 
max objective  81 82 80 77 
avg constraint (stdv)  26.52 (4.22)  25.66 (8.02)  23.28 (8.18)  23.93 (8.43)  
min constraint  0 0 0 0 
max constraint  31 33 31 30 
 
Table  S6: E2.2 : Modifying number of latent variables  maxlv  
 10 latent variables 20 latent variables 30 latent variables 40 latent variables 50 latent variables 60 latent variables 
avg objective (stdv)  50.1 (2.26)  52.08 (2.40)  53.19 (2.86)  53.26 (3.38)  53.47 (3.56)  66.43 (6.80)  
min objective  45 47 47 44 47 51 
max objective  56 59 61 63 70 77 
avg constraint (stdv)  9.25 (5.64)  1.96 (3.03)  4.69 (6.11)  4.41 (6.78)  6.69 (7.83)  23.93 (8.43)  
min constraint  0 0 0 0 0 0 
max constraint  19 13 24 25 32 30"," This paper explores the use of a hybrid machine-learning-optimization approach called COIL to optimize autonomous robot timings for last-mile delivery services. It compares COIL with a baseline genetic algorithm and investigates new methods for improving the speed and efficiency of COIL. Results show that COIL can find valid solutions where appropriate numbers of robots run simultaneously and that it can optimize 10% faster than the GA, making it a good choice for daily re-optimization of robots. The paper also discusses various methods of evolutionary computation, such as quality diversity, black-box optimization, constraint handling, and latent space models."
44," Vectorial Genetic Programming { Optimizing
Segments for Feature Extraction
Philipp Fleck1;2?[0000"," This paper presents Vectorial Genetic Programming (Vec-GP), an extension of Genetic Programming (GP) which allows vectors as input features. It introduces strategies for optimizing a window for aggregation functions, including random and guided sampling. Results indicate that the random sampling strategies perform better than the guided strategies, which can become stuck in local optima. The paper also compares the performance of random versus guided direction and range reduction for feature extraction, with random range being the better option in most cases."
45," Networksâ€™ modulation: How diï¬€erent structural
network properties aï¬€ect the global
synchronization of coupled Kuramoto oscillators.
Juliette Courson1;2;3, Thanos Manos2, and Mathias Quoy2;4
1Laboratoire de Physique ThÃ©orique et ModÃ©lisation (LPTM), CNRS, UMR 8089,
CY Cergy Paris UniversitÃ©, Cergy-Pontoise Cedex, France
juliette.courson@cyu.fr
2Equipes Traitement de lâ€™Information et SystÃ¨mes (ETIS), CNRS, UMR 8051,
ENSEA, CY Cergy Paris UniversitÃ©, Cergy-Pontoise Cedex, France
thanos.manos@cyu.fr
3Department of Computer Science, University of Warwick, Coventry, UK
4IPAL CNRS Singapore
mathias.quoy@cyu.fr
Abstract. Inalargevarietyofsystems(biological,physical,socialetc.),
synchronizationoccurswhendiï¬€erentoscillatingobjectstunetheirrhythm
when they interact with each other. The diï¬€erent underlying network
deï¬ningtheconnectivitypropertiesamongtheseobjectsdrivestheglobal
dynamics in a complex fashion and aï¬€ects the global degree of synchrony
of the system. Here we study the impact of such types of diï¬€erent net-
work architectures, such as Fully-Connected, Random, Regular ring lat-
tice graph, Small-World and Scale-Free in the global dynamical activity
of a system of coupled Kuramoto phase oscillators. We ï¬x the external
stimulation parameters and we measure the global degree of synchrony
whendiï¬€erentfractionsofnodesreceivestimulus.Thesenodesarechosen
either randomly or based on their respective strong/weak connectivity
properties (centrality, shortest path length and clustering coeï¬ƒcient).
Our main ï¬nding is, that in Scale-Free and Random networks a sophis-
ticated choice of nodes based on their eigenvector centrality and average
shortest path length exhibits a systematic trend in achieving higher de-
gree of synchrony. However, this trend does not occur when using the
clustering coeï¬ƒcient as a criterion. For the other types of graphs consid-
ered, the choice of the stimulated nodes (randomly vs selectively using
the aforementioned criteria) does not seem to have a noticeable eï¬€ect.
1 Introduction
Complex networksâ€™ theory is a powerful tool in various ï¬elds that allow us to
investigate and understand the real world [1,2]. For example, diï¬€erent ensembles
of neurons connected by synapses coordinate their activity to perform certain
tasks (in biology), infrastructures like the Internet are formed by routers and
computer cables and optical ï¬bers (in hardware communication) and the human
personal or professional relationships (in social sciences) to name a few [3].arXiv:2303.03099v1  [nlin.AO]  24 Feb 2023 1. INTRODUCTIONCourson et al.
Nonlinearity is a very important feature in complex systems giving a rich
repertoire of diï¬€erent activity patterns, such as stable, unstable, periodic etc. A
modiï¬cation of some parameter might also produce a change in their stability,
and therefore in the dynamics of the system. Furthermore, such systems may
have a high sensitivity to initial conditions, or to any external input, that could
completely change their dynamics [4].
Suchdynamicsoftenyieldtoaself-organisedcoherentactivity,i.e.tosynchro-
nization. The latter can be loosely deï¬ned as the capacity of diï¬€erent oscillating
objects to adjust their rhythm due to their interaction and plays a key role in a
large variety of systems, whether biological, physical, or even social (see e.g. [5]).
In a more formal way, synchronization emerges from the interaction of several
autonomous oscillators, also called self-sustained oscillators. That is, nonlinear
dynamicalsystemsthatproduceoscillationswithoutanyneedofexternalsource.
Their dynamics is given by a nonlinear diï¬€erential equation or, in the case of
multiple coupled oscillators, by several coupled diï¬€erential equations.
The relative way that autonomous oscillators are connected within a given
network can aï¬€ect their global activity and synchronization properties. Neural
networks can be represented as a graph of connections between the diï¬€erent neu-
rons. Since the introduction of small-world networks and scale-free networks (see
e.g. [6,8]), the ï¬eld of network graph analysis has attracted the attention of many
studies aimed to better understand complex systems (see e.g. [9,10,11,12,13]).
Furthermore, modern network connectivity techniques allow us to capture var-
ious aspects of their topological organization, as well as to quantify the local
contributions of individual nodes and edges to networkâ€™s functionality (see e.g.
[14]).
In neuroscience, synchronization plays a very important role. The human
brain is a very large and complex system whose activity comprises the rapid
and precise integration of a gigantic amount of signals and stimulus to perform
multiple tasks (see e.g. [14,15,16]). One example occurs in epileptic seizures,
where periods of abnormal synchronization in the neural activity can spread
within diï¬€erent regions of the brain, and cause an attack in the aï¬€ected person
(see e.g. [17]). More examples are found in other brain diseases such as Parkinson
disease, where an excessively synchronized activity in a brain region correlates
with motor deï¬cit (see e.g. [18,19] and references therein) or tinnitus (see e.g.
[20,21,22] and references therein).
In this study, we focus at a rather theoretical framework. We set out to in-
vestigate the impact of diï¬€erent network architectures, such as Fully-Connected,
Random, Regular ring lattice graph, Small-World and Scale-Free in the global
dynamical activity of a system of coupled Kuramoto phase oscillators [23]. The
Kuramoto model has been broadly used to study various types of oscillatory
complex activity, see e.g. [24,25,26] (to name only a few) and references therein.
Our goal is to investigate the impact of the network (graph) structure in the sys-
temâ€™sglobaldegreeofsynchronizationwhenapplyingidenticalandï¬xedexternal
stimulus to diï¬€erent subsets of nodes which are chosen according to various net-
work connectivity criteria. We ï¬nd that, in scale-free and random networks, a
2 Courson et al.
2. METHODS AND MATERIALS
sophisticated choice of nodes based on graph connectivity properties exhibits a
systematic trend in achieving higher degree of synchrony. For the other types of
graphs considered, the choice of the stimulated nodes (randomly vs selectively
using the aforementioned criteria) seems to not have a noticeable eï¬€ect.
2 Methods and Materials
2.1 Connectivity measurements
We here study the dynamics of phase oscillators coupled via binary, undirected
graphsG= (V;E), containing a set of NverticesV=fv2J1 :NKgand a set
E=f(v;w)2J1 :NK2gof edges. Let Abe the corresponding adjacency matrix,
withAvw= 1if there is a connection between node vand nodew,0otherwise.
Self-connections are excluded, so Av;v= 0for any vertex v. For our analysis
later on, we will use the following graph connectivity measurements [27]:
â€“ Shortest path length. The shortest path length Lv;wbetween any two
nodesvandwis the number of connections on the shortest path going
from one to another, computed following Dijkstraâ€™s algorithm. We deï¬ne
the shortest path length of a node vas the average shortest path between v
and any other node of the network:
<Lv>=X
w2VLv;w
N: (1)
Note thatLv;wmight not be deï¬ned if there is no way connecting node vto
nodew. The lower the shortest path length, the fastest the information goes
from one node to another. For example, when building a subway network
(that is, a graph where diï¬€erent stations are interconnected), one might
want to minimize the stationsâ€™ average shortest path length so the users can
easily navigate across the city.
â€“ Centrality. The eigenvector centrality is used to quantify the importance
of a node in the network. Let be the highest eigenvalue for A, so that all
the corresponding eigenvectorâ€™s components are non null. The eigenvector
centralityxvof vertexvis deï¬ned as the vthcomponent the eigenvector,
namely:
xv=1
X
w2VAw;vxw: (2)
Keeping in mind the subway network example, a station with a high cen-
trality would be densely connected to other stations, in particular to other
central ones.
â€“ Clustering. Letkv=P
wAvwbe the degree of node v. In the case of a
undirected graph,kv(kv"," This paper examines the impact of different network structures, such as Fully-Connected, Random, Regular ring lattice graph, Small-World and Scale-Free, on the global dynamical activity of a system of coupled Kuramoto phase oscillators. It finds that in Scale-Free and Random networks, a sophisticated choice of nodes based on their eigenvector centrality and average shortest path length can lead to higher degrees of synchrony. The paper also discusses magnetoencephalographic functional connectivity in Alzheimer's disease and random graphs in nature, society, and the brain."
46," arXiv:2303.01695v1  [cs.NE]  3 Mar 2023EVOLUTIONARY MULTI -OBJECTIVE ALGORITHMS FOR THE
KNAPSACK PROBLEMS WITH STOCHASTIC PROFITS
A P REPRINT
Kokila Perera
Optimisation and Logistics
School of Computer and Mathematical Sciences
The University of Adelaide
Adelaide, AustraliaAneta Neumann
Optimisation and Logistics
School of Computer and Mathematical Sciences
The University of Adelaide
Adelaide, Australia
Frank Neumann
Optimisation and Logistics
School of Computer and Mathematical Sciences
The University of Adelaide
Adelaide, Australia
ABSTRACT
Evolutionary multi-objective algorithms have been widely shown to be successful when utilized
for a variety of stochastic combinatorial optimization pro blems. Chance constrained optimization
plays an important role in complex real-world scenarios, as it allows decision makers to take into
account the uncertainty of the environment. We consider a ve rsion of the knapsack problem with
stochastic proï¬ts to guarantee a certain level of conï¬dence in the proï¬t of the solutions. We in-
troduce the multi-objective formulations of the proï¬t chan ce constrained knapsack problem and
design three bi-objective ï¬tness evaluation methods that w ork independently of the speciï¬c conï¬-
dence level required. We evaluate our approaches using well -known multi-objective evolutionary
algorithms GSEMO and NSGA-II. In addition, we introduce a ï¬l tering method for GSEMO that
improves the quality of the ï¬nal population by periodically removing certain solutions from the in-
terim populations based on their conï¬dence level. We show th e effectiveness of our approaches on
several benchmarks for both settings where the knapsack ite ms have ï¬xed uniform uncertainties and
uncertainties that are positively correlated with the expe cted proï¬t of an item.
Keywords Multi-objective optimization, stochastic knapsack probl em, chance constrained problems
1 Introduction
Real world optimization problems involve often uncertain p roperties imposed by some stochastic components in the
problem or noise in its environment Peng (2019); He and Shao ( 2009). Such uncertainties must be considered in the
optimization to ï¬nd reliable and useful solutions to proble ms. Chance constraints are a natural way to model uncer-
tainties in problems. They can capture the effects of uncert ain variables on the inequality constraints and formulate
the optimization problems under uncertainties Peng (2019) ; Neumann et al. (2020); Doerr et al. (2020). A chance
constraint is usually an inequality constraint on some stoc hastic variable of the problem, which can be violated by a
slight chance (a small probability) when optimizing the problem Neumann a nd Sutton (2019); Neumann and Neumann
(2020). Chance constraints enable one to set the desired con ï¬dence level of getting the maximal proï¬t when implement-
ing a solution, unlike using a solution from a deterministic approach. The study of problems with chance constraints
leads to developing efï¬cient applications to solve complex optimization problems and is crucial in developing real
world solutions for complex problems, such as in the mining i ndustry Xie et al. (2021a); Mohtasham et al. (2021),
power systems Geng and Xie (2019), communication systems Ab e et al. (2020) and transportation Kepaptsoglou et al.
(2015). Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
This work considers a variation of the classical knapsack pr oblem (KP), where the items have stochastic proï¬ts and
deterministic weights. As the weights of items are determin istic, the constraint on the weights remains the same
as in the classical KP. An additional constraint is introduc ed to this problem to capture the uncertainty of the proï¬t
variable, which is a chance constraint on the proï¬t Neumann e t al. (2022). This constraint guarantees that the solution
has maximal proï¬t P and only drops below P for a small probabil ity (Î±). In summary, the optimization process for
this problem is to ï¬nd the solution(s) that maximize the proï¬ t P, subjected to the weight constraint and proï¬t chance
constraint, which guarantees that the proï¬t P is obtained wi th probability at least Î±.
In the literature, the KP with a chance constraint on the weig ht (as elements have deterministic proï¬ts and stochastic
weights) is more prevalent Xie et al. (2019, 2020). On the con trary, the proï¬t chance constrained KP is explored
only in one study, which appears in recent literature Neuman n et al. (2022). This work considers single-objective
evolutionary approaches to address this problem Neumann et al. (2022). This scenario makes it possible to identify
the risk of not achieving the expected proï¬t by implementing a particular solution for the problem and making better
decisions in planning. This problem reï¬‚ects a beneï¬cial and valid real-world problem scenario like mine planning as
mentioned in Neumann et al. (2022).
Evolutionary algorithms (EAs) perform well in addressing s tochastic optimization problems Doerr and Neumann
(2021); Singh and Branke (2022). Also, they can produce opti mal or feasible solutions in a reasonable amount of
time for complex combinatorial optimization problems like chance constrained knapsack and job shop scheduling
problems. EAs may consider a different number of objectives depending on how the deï¬nition of the underlying
problem. Usually, when an EA considers a single objective, i t generates a single solution that optimizes the objective
value. In contrast, a multi-objective EA generates a set of s olutions that gives a trade-off between given objectives.
Such a solution set makes it possible to have more insights in to improving the algorithms and search space than having
a single solution as the outcome Coello et al. (2013); Deb (20 01). Therefore, multi-objective algorithms help one to
make informed decisions on selecting a solution to implemen t.
In this work, we explore the use of the multi-objective evolu tionary approaches for the chance constrained KP with
stochastic proï¬ts introduced in Neumann et al. (2022). Here we introduce multi-objective ï¬tness evaluation for EAs
to address this problem and methods to enhance their perform ance.
1.1 Related Work
The use of evolutionary computation for chance constrained problems appears in the early literature He and Shao
(2009); Loughlin and Ranjithan (1999); Liu et al. (2013); Ma sutomi et al. (2013). Those works consider computation-
ally expensive methods like simulations and sampling to cat er for chance constraints. More recent studies have looked
into tail-bound inequalities, which more efï¬ciently deal w ith chance constraints Neumann et al. (2022); Xie et al.
(2019); Assimi et al. (2020).
The chance constrained KP where the proï¬ts are deterministi c and weights are stochastic is considered in several
papers Xie et al. (2019, 2020). Xie et al. (2019) presents how to use well-known deviation inequalities: Chebyshevâ€™s
inequality and Hoeffding bound to estimate the probability of constraint violation. In Xie et al. (2020), where the same
KP variation is considered, they introduce problem-speciï¬ c operators for EAs with both single- and multi-objective
formulations. In the study Assimi et al. (2020), dynamic cha nce constrained KP with stochastic proï¬ts is studied. formulations. In the study Assimi et al. (2020), dynamic cha nce constrained KP with stochastic proï¬ts is studied.
In addition to the objective function on the proï¬t of a given s tochastic solution, a second objective is introduced to
address the dynamic capacity constraint. It captures the mi nimal capacity bound for the solution that meets the chance
constraints.
Run-time analysis is an essential topic in studying problem s with chance constraints. The ï¬rst paper on run time
analysis for chance constraint problems considers the KP wi th stochastic weights Neumann and Sutton (2019). This
work considers different cases of that problem and studies t he run time of (1+1) EA for them. In Xie et al. (2021b),
they perform the run time analysis of simple EAs for chance co nstrained KPs with uniform weights. The papers
Neumann and Witt (2022) and Shi et al. (2022) study the run tim e of simple EAs for different chance constrained
problems. InNeumann and Witt (2022), the authors consider s ingle- and multi-objective EAs for chance constrained
problems with normally distributed random problem variabl es. They also show how to use the proposed evolutionary
approaches for chance constrained minimum spanning tree pr oblems Neumann and Witt (2022). In Shi et al. (2022),
they analyze the run time of random local search and (1+1) EA f or the chance constrained makespan problem.
In the study Neumann et al. (2022), the authors simple EAs for the proï¬t chance constrained KP. Those algorithms
include (1+1) EA with standard bit-ï¬‚ip mutation and heavy-t ail mutation operators and population based ( Âµ+1) EA,
which uses a speciï¬c crossover operator for the KP. This stud y evaluates the performance of all these algorithms
using the single objective ï¬tness evaluation. The overall r esults show that (1+1) EA with heavy tail mutation operator
signiï¬cantly improved over other algorithms.
2 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
This work is motivated by the recent study on evolutionary mu lti-objective algorithms that compute trade-offs with
respect to the expected value and the variance of solutions p resented in Neumann and Witt (2022). Here we explore the
multi-objective formulations for the proï¬t chance constra ined KP based on that work. In addition to the variance of the
solutions, we consider the standard deviation and also the c ount of elements in the solutions (under certain conditions )
to introduce ï¬tness evaluations for the problem. The signiï¬ cance of these ï¬tness functions is that they can evaluate the
ï¬tness of a solution independent of any speciï¬c conï¬dence le vel of its proï¬t (i.e. independent of speciï¬c value for Î±).
Since this generates a set of solutions that gives a trade-of f of speciï¬c objectives for each ï¬tness formulation with eac h
algorithm, it allows one to make more informed decisions whe n selecting a solution to implement. For example, to
identify the solution that gives the best proï¬t with a partic ularÎ±value, we can calculate the proï¬t of all the solutions
for that value and select the solution that gives the best pro ï¬t among the ï¬nal population.
This study considers two well-known multi-objective EAs: G SEMO Giel (2003) and NSGA-II Deb et al. (2002).
Furthermore, we introduce a ï¬ltering method for GSEMO which aims to improve the quality of the ï¬nal population
resulting from the algorithm. This ï¬ltering method is appli ed regularly after a ï¬xed number of evaluations in the
evolutionary process. It considers whether a solution can b e the best solution for any Î±âˆˆ[0.0,1/2]considering the
interim population at the time and, otherwise, removes it fr om the population. For all experimental settings, in additi on
to the two algorithms, GSEMO and NSGA-II, we consider this ï¬l tering method combined with GSEMO as a separate
algorithm.
The structure of this paper is as follows. Section 2 introduc es the problem formulation, and Section 2 discusses the
algorithms we consider in this study. Section 3 discusses th e multi-objective formulation, including the objective
function on proï¬t, ï¬tness functions and how to use the probab ility bounds to estimate the conï¬dence level of the
solutions. Section 4 and 5 discuss the EAs considered in this paper and the new Filtering method introduced in this
work. Section 6 presents the details of the experimental set tings and the results. Finally, Section 7 gives the conclusi ons
of this study.
2 Problem Deï¬nition
In the classical KP, the proï¬t and weight values of the items a re deterministic. Let the KP has n items
{x1,...,x i,...,x n}with proï¬t piand weight wiand weight bound B. A solution to the problem can be represent ed as
{0,1}nsuch that xi= 1only when xiis selected in the solution. Given the proï¬t of solution xasp(x) =/summationtextn
i=1pi.xi
and weight w(x) =/summationtextn
i=1wi.xi, the classical KP is to ï¬nd the solution xâˆ—that maximize p(xâˆ—)subjected to the
weight constraint w(xâˆ—)â‰¤B.
In this work, we consider a stochastic version of the classic al KP where the proï¬ts of the knapsack items are stochastic
while weights remain deterministic. Therefore the proï¬t of a solution will be uncertain and may vary from the expected
maximal proï¬t value. A chance constraint on the proï¬t is used to capture the stochastic behaviour of the problem. This
constraint ensures that for each feasible solution x, the maximum probability that the proï¬t will drop below proï¬ t value
P is only a small probability 0< Î± <1/2.
We can formally present this problem as follows:
maxP (1)
s. t.Pr(p(x)< P)â‰¤Î± (2)
and w (x)â‰¤B (3)
whereÎ±is a parameter determining the allowed failure probability which is a small value <= 1/2. Equation 2
speciï¬es the chance constraint on the proï¬t.
2.1 Estimating Proï¬t of a Solution whereÎ±is a parameter determining the allowed failure probability which is a small value <= 1/2. Equation 2
speciï¬es the chance constraint on the proï¬t.
2.1 Estimating Proï¬t of a Solution
Computing the probability of violating a given chance const raint is intractable in general Doerr and Neumann (2021).
Therefore, it is not straightforward to estimate the proï¬t o f a solution under uncertainties. However, tail bounds can
be used to upper bound the probability of chance constraint v iolationDoerr and Neumann (2021). In Neumann et al.
(2022), the authors present proï¬t estimates for the problem based on the tail bounds: Chebyshevâ€™s inequality and
Hoeffding bound. Each of these applies to the problem under c ertain conditions.
If the expectation and variance of the solutionsâ€™ proï¬ts are known for a given problem instance, we can use Cheby-
shevâ€™s inequality to calculate the proï¬t of a solution for it Doerr (2020). Neumann et al. (2022) present a proï¬t estimate
in Equation 4, that ensure the proï¬t chance constraint Pr(p(x)< P)â‰¤Î±is held. We can guarantee that the solution
3 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
xwill give the proï¬t Ë†pCheb(x,Î±)except for a small probability Î±as follows:
Ë†pCheb(x,Î±) =Âµ(x)âˆ’/radicalbig
(1âˆ’Î±)/Î±Â·/radicalbig
v(x). (4)
The above equation gives a very general setting for the proï¬t of a solution that can be used in any scenario where the
expected value and the variance are known. For example, we ca n consider that the proï¬ts pitake a uniform distribution
such that piâˆˆ{Âµiâˆ’Î´,Âµi+Î´}which gives the expected value Âµiand varianceÎ´2
3.|x|1.
The Hoeffding bound can be used to formulate a proï¬t estimate if the proï¬ts are taken randomly from a uniform
random distribution independent of each other Doerr (2020) . From Neumann et al. (2022), we get the formulation for
the proï¬t of solution xusing the Hoeffding bound ( Ë†pHoef(x,Î±)) as follows:
Ë†pHoef(x,Î±) =Âµ(x)âˆ’Î´Â·/radicalbig
ln(1/Î±)Â·2Â·|x|1. (5)
3 Multi-Objective Formulation
In this section, we introduce the multi-objective formulat ions of the proï¬t chance constrained KP. As presented in
Section 2, the optimal solution for the KP maximizes the proï¬ t subjected to the weight bound constraint. For the proï¬t
chance constrained KP with deterministic weights, the mult i-objective formulation needs to consider the uncertainty
of the proï¬ts of knapsack items. In the following subsection s, we present the multi-objective formulations and the
functions to estimate proï¬ts.
3.1 Fitness Functions
In general, we need to ensure that the expectation of proï¬t is maximized while the variance is minimized to maximize
the proï¬t of the solution. Considering this, we introduce th e ï¬tness function g(x) = (Âµ(x),v(x))that will produce
a set of solutions that gives a trade-off between the two obje ctives, irrespective of Î±the guarantee of the proï¬t of the
individual solutionâ€™s proï¬t value. The formula for the two o bjectives is given in Equation 6 and 7 where vmax=/summationtextn
i=1vi.
Âµ(x) =/braceleftbigg/summationtextn
i=1Âµixiw(x)â‰¤B
Bâˆ’w(x)w(x)> B(6)
v(x) =/braceleftbigg/summationtextn
i=1Ïƒ2
ixi w(x)â‰¤B
vmax+(w(x)âˆ’B)w(x)> B(7)
When evaluating the ï¬tness of solutions, we need to determin e their dominance concerning the different objectives.
For two solutions A and B, we say that Adominates B(denoted as A/{ollowsequalB)iffÂµ(A)â‰¥Âµ(B)âˆ§v(A)â‰¤v(B), andA
strongly dominates B(denoted as Aâ‰»B)iffA/{ollowsequalBandÂµ(A)> Âµ(B)âˆ¨v(A)< v(B). For an infeasible solution
that violates the weight capacity constraint ( w(A)> B ), the above formula penalises the two objective values (see
Equation 6 and 7). This formulation ensures that any feasibl e solution dominates the infeasible solution instances.
Next, we consider the ï¬tness function gâ€²(x) = (Âµ(x),s(x)). Only the second objective of this ï¬tness function differs
fromgâ€²(x)while the ï¬rst objective Âµremains the same and can be deï¬ned as given in Equation 6. We de note the
maximal standard deviation as smax=/summationtextn
i=1Ïƒiin Equation 8 which deï¬nes the second objective of this ï¬tnes s
functiongâ€²(x).
s(x) =/braceleftbigg/radicalbig/summationtextn
i=1Ïƒ2
ixi w(x)â‰¤B
smax+(w(x)âˆ’B)w(x)> B.(8)
For simple EAs like GSEMO, the ï¬nal population when optimizi ngg(x)is equivalent to when optimizing gâ€²(x)as
the difference between the two is that the second objective o f the latter is the square root of the second objective of the
former. Therefore it does not change the order of search poin ts of such algorithms. However, it should be noted that
some popular EMO algorithms like NSGA-II would encounter a d ifference in the diversity mechanism when working
withv(x)instead of s(x). Therefore, we investigate both g(x)andgâ€²(x)in this work.
4 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
3.2 Fitness Function for Proï¬ts with Same Dispersion
When the value for Î´is the same for all elements, we can consider the number of ite ms selected in the solution ( |x|1)
as the second objective. This objective enables the deï¬niti on of a ï¬tness function that performs independent of both
the conï¬dence level of the solution ( Î±) and the uncertainty level of the individual proï¬t values ( Î´). We denote the
ï¬tness function for this scenario as gâ€²â€²(x) = (Âµ(x),c(x)). The ï¬rst objective of the new ï¬tness function is based on
the expectation of the proï¬t of xÂµ(x), similar to previous functions and calculated as given in Eq uation 6. The second
objective c(x)is calculated as follows,
c(x) =/braceleftbigg/summationtextn
i=1xi w(x)â‰¤B
n+(w(x)âˆ’B)w(x)> B.(9)
3.3 Estimating the Best Proï¬t Value
As the ï¬nal output of the multi-objective evolutionary appr oaches, we get a set of solutions that gives a trade-off of
the objectives independent of the conï¬dence level of the pro ï¬ts. We need to identify the solution with the best proï¬t
for a given conï¬dence level Î±using these ï¬nal solutions. We can use Equations 4 and 5 from N eumann et al. (2022)
and calculate the proï¬t of all the solutions in the ï¬nal popul ation for the required conï¬dence levels ( Î±). The solution
giving the highest proï¬t value for each Î±is the best solution for that particular setting.
3.4 Conï¬dence Level of a Solutionâ€™s Proï¬t
Different solutions in the ï¬nal population produced by mult i-objective approaches become the best solution for differ -
ent conï¬dence levels. We can identify the conï¬dence level of each solution in the ï¬nal population for which it gives
the highest proï¬t value. First, we obtain the Î±threshold for a pair of solutions such that one becomes bette r than the
other by comparing the proï¬t estimates mentioned in Subsect ion 2.1. Based on the threshold Î±value between solution
pairs in the ï¬nal population, we deï¬ne a conï¬dence level inte rval for each solution such that they give the best proï¬t
value for any Î±in that interval.
3.4.1 Conï¬dence Level Threshold using Chebyshevâ€™s Inequal ity
Let the solutions xandysuch that Âµ(x)> Âµ(y)andv(x)> v(y), then we can say that the proï¬t of the solution xis
better than ywhen the minimum required conï¬dence level( Î±x,y) is as follows:
Î±Cheb(x,y)=1
1+(R(x,y))2s.t. R(x,y) =Âµ(x)âˆ’Âµ(y)/radicalbig
v(x)âˆ’/radicalbig
v(y)(10)
For the conï¬dence level Î±â‰¥1/(1+(R(x,y))2), the solution Xwill have a better proï¬t value than the solution Y.
Theorem 3.1. Let0< Î± <1,and x andybe two feasible solutions such that Âµ(x)> Âµ(y)andv(x)> v(y), holds.
IfÎ±â‰¥1
1+(R(x,y))2holds such that R(x,y) =Âµ(x)âˆ’Âµ(y)âˆš
v(x)âˆ’âˆš
v(y)thenË†pCheb(x,Î±)â‰¥Ë†pCheb(y,Î±).
Proof. We have
Î±â‰¥1
1+(R(x,y))2
â‡â‡’ Î±+Î±(R(x,y))2â‰¥1
â‡â‡’ (R(x,y))2â‰¥(1âˆ’Î±)/Î±
5 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
As we assume 0< Î± <1,Âµ(x)> Âµ(y)andv(x)> v(y), we have R(x,y)>0and1âˆ’Î±
Î±>0.
This implies,
R(x,y)â‰¥/radicalbig
(1âˆ’Î±)/Î±
â‡â‡’Âµ(x)âˆ’Âµ(y)/radicalbig
v(x)âˆ’/radicalbig
v(y)â‰¥/radicalbig
(1âˆ’Î±)/Î±
â‡â‡’ Âµ(x)âˆ’Âµ(y)â‰¥/radicalbigg
1âˆ’Î±
Î±Â·/parenleftBig/radicalbig
v(x)âˆ’/radicalbig
v(y)/parenrightBig
â‡â‡’ Âµ(x)âˆ’/radicalbigg
1âˆ’Î±
Î±Â·/radicalbig
v(x)â‰¥Âµ(y)âˆ’/radicalbigg
1âˆ’Î±
Î±Â·/radicalbig
v(y)
â‡â‡’ Ë†pCheb(x,Î±)â‰¥Ë†pCheb(y,Î±)
3.4.2 Conï¬dence Level Threshold using Hoeffding Bound
Consider the solutions xandysuch that Âµ(x)> Âµ(y)andv(x)> v(y). From the Ë†pHoef we can derive the minimum
conï¬dence level Î±x,yfor which solution xgives a better proï¬t than yw.r.t.Ë†pHoef as follows:
Î±Hoef(x,y)=eâˆ’(S(x,y))2s.t. S(x,y) =Âµ(x)âˆ’Âµ(y)
Î´/parenleftBig/radicalbig
2|x|1âˆ’/radicalbig
2|y|1/parenrightBig (11)
Theorem 3.2. Let0< Î± <1,and x andybe two feasible solutions such that Âµ(x)> Âµ(y)andv(x)> v(y), holds.
IfÎ±â‰¥eâˆ’(S(x,y))2holds then Ë†pHoef(x,Î±)â‰¥Ë†pHoef(y,Î±).
Proof. We have,
Î±â‰¥eâˆ’(S(x,y))2
â‡â‡’ e(S(x,y))2â‰¥1/Î±
â‡â‡’ (S(x,y))2â‰¥ln(1/Î±)
As we assume 0< Î± <1,Âµ(x)> Âµ(y)andv(x)> v(y), we have S(x,y)>0andln1
Î±>0.
This implies,
S(x,y)â‰¥/radicalbig
ln(1/Î±)
â‡â‡’Âµ(x)âˆ’Âµ(y)
Î´/parenleftBig/radicalbig
2|x|1âˆ’/radicalbig
2|y|1/parenrightBigâ‰¥/radicalbig
ln(1/Î±)
â‡â‡’ Âµ(x)âˆ’Âµ(y)â‰¥Î´Â·/radicalBigg
2ln/parenleftbigg1
Î±/parenrightbigg/parenleftBig/radicalbig
|x|1âˆ’/radicalbig
|y|1/parenrightBig
â‡â‡’ Âµ(x)âˆ’Î´Â·/radicalBigg
ln/parenleftbigg1
Î±/parenrightbigg
Â·2Â·|x|1â‰¥Âµ(y)âˆ’Î´Â·/radicalBigg
ln/parenleftbigg1
Î±/parenrightbigg
Â·2Â·|y|1
â‡â‡’ Ë†pHoef(x,Î±)â‰¥Ë†pHoef(y,Î±)
3.4.3 Conï¬dence Level Interval for Solutions in the Final Po pulation
We can use the Î±threshold value in the previous subsections, to introduce t he conï¬dence level range for solutions in
a population as follows. As the Î±threshold we can use either Î±Cheb(x,y)orÎ±Hoef(x,y). Despite the speciï¬c equation
to estimate the Î±threshold, we can introduce the Î±interval for a solution.
First, we sort all the solutions in the given population P as {x1,...xn}such that Âµ(x1)â‰¥Âµ(x2)â‰¥...â‰¥Âµ(xn). Then,
we can deï¬ne a (n+1)Ã—(n+1) symmetric matrix of conï¬dence level thresholds as:
6 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
Algorithm 1 GSEMO
1:Choosexâˆˆ{0,1}nuniformly at random ;
2:Sâ†{x};
3:while stopping criterion not met do
4: choosexâˆˆSuniformly at random;
5:yâ†ï¬‚ip each bit of xindependently with probability of1
n;
6: if(/\e}atio\slashâˆƒwâˆˆS:wâ‰»y)then
7:Sâ†(Sâˆª{y})\{zâˆˆS|y/{ollowsequalz};
8: end if
9:end while
Î±(i,j)=/braceleftbigg
1 i= 0orj= 0
Î±Cheb(i,j)orÎ±Hoef(i,j)i= 1,...,n(12)
Finally, using the conï¬dence level threshold values, we can get the conï¬dence level range for solution k as given
in Equation 13. If there exists a valid Î±interval for a particular solution, then for the Î±values in that interval, that
solution will give the best proï¬t value. If the Î±interval is empty for a particular solution, then that solut ion wonâ€™t be
the best solution for any Î±value.
kâˆ’1
min
j=0Î±i,kâ‰¤Î±kâ‰¤nâˆ’1max
j=kÎ±i,j (13)
4 Algorithms
In this study, we consider two widely used multi-objective E As: GSEMO and NSGA-II. GSEMO is the most basic EA
that addresses multi-objective optimization problems. It has been proven to be effective in solving chance constraine d
multi-objective optimization problems in many studies Neu mann et al. (2022). The steps of GSEMO are given in
Algorithm 1.
The population S initially contains a solution that is gener ated randomly. Over the iterations, a parent solution xis
selected uniformly at random from S and an offspring solutio nyis generated by ï¬‚ipping each bit of xwith a probability
of1
n. Ifyis not dominated by any of the existing solutions in S, it is ad ded to S replacing all the existing solutions in S
that are dominated by y. This guarantees at the end of any iter ation, population S will contain a set of non-dominating
solutions that are equally efï¬cient with respect to the give n objective functions.
NSGA-II is the most prominent multi-objective EA that focus es on diversity by ï¬nding near optimal solutions
Deb et al. (2002). If we consider one iteration of the evoluti onary process of NSGA-II, it creates an offspring pop-
ulation from the parent population. First, we use the binary tournament for the selection of two parent solutions and
apply single point crossover to generate two offspring solu tions which are mutated by ï¬‚ipping each bit with a proba-
bility of1
n. When the offspring population is full, all the solutions fr om parent and offspring solutions are considered
together and divided into non-dominating solution fronts ( i.e., the solutions in a front do not dominate other solution s
in it). Starting with the front with the lowest rank, these ar e added to the new population until it reaches capacity. If
only a part of a front is to be taken into the new population, cr owding distance-based sorting is used to decide the
selection. This improves the better spread (diversity) amo ng the solutions. In one iteration of this algorithm, a new
ï¬tness evaluation equal to the size of the offspring populat ion is considered. The number of iterations of the algorithm s
depends on the offspring population size and the maximum num ber of evaluations as considered in the experimental
setup.
5 Filtering for Problems with Chance Constraints
Here we propose a ï¬ltering method for GSEMO to improve its out come by removing solutions that do not have a valid
Î±interval from the interim populations. The ï¬nal population of GSEMO contains solutions that do not give the best
proï¬t value for any probability value for Î±. Such solutions do not add value to the optimization goal of ï¬ nding the
best solutions with given conï¬dence levels. For instance, F igure 1 presents a ï¬nal population from GSEMO using 10
million ï¬tness evaluation of g(x)on uncorr-100: an instance used in the experiments. The plot showsÂµ(x)versus
v(x)for all solutions in the ï¬nal population. Blue star markers i ndicate that the solution has a valid conï¬dence level
interval. These solutionsâ€™ Î±intervals compose the complete probability range [0.0,1.0 ]. At the end of the optimization interval. These solutionsâ€™ Î±intervals compose the complete probability range [0.0,1.0 ]. At the end of the optimization
7 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
0.0 2.0 4.0 6.0 8.0
Âµ(x)[in 1000â€™s]0.0 1.0 2.0 3.0v(x) [in 1000â€™s]Î±1
Î±2
Î±3
Î±4
Î±8
Î±10
Î±12
Î±18
Î±19
Figure 1: A sample of a ï¬nal population from GSEMO
Algorithm 2 Filtering Method
0:Input: Population P0=x1,...,xnordered by the decreasing order of Âµ(xi);
1:setkâ†1;
2:whilekâ‰¤ndo
3: setupperâ†minkâˆ’1
j=0Î±i,k
4: setlowerâ†maxnâˆ’1
j=kÎ±i,j
5: ifupperâ‰¥lower then
6:P1âˆª{xk}
7: end if
8: setkâ†k+1
9:end while
10:returnP1
process, interest is in solutions with these blue markers. I t is one of these solutions that become the best solution for
a givenÎ±value. On the contrary, other solutions marked in black do no t become the best solution for any conï¬dence
level.
The ï¬ltering method removes these solutions that do not beco me the best solution for any conï¬dence level. It is
applied to the interim populations of GSEMO regularly after a certain amount of ï¬tness evaluations. This process
removes the solutions from interim populations, consideri ng theÎ±intervals they represent according to Equation 13.
As the ï¬ltering method keeps only the solutions with valid Î±interval, it increases the change of the evolutionary
optimization to improve on these solutions. Therefore, thi s method helps to improve the quality of the solutions in the
ï¬nal population.
The steps of the ï¬ltering method are given in Algorithm 2. It t akes the population P0as the input, which can be either
the ï¬nal population or an interim population created during the execution of GSEMO. Population P0needs solutions
in the decreasing order of the Âµ(x). For each solution xk, we consider Î±i,kand select the interval for conï¬dence level,
using the inequality given in Equation 13. The solution xkis added to the resulting population P1iff the interval for
Î±kis non-empty.
6 Experiments
In this work, we evaluate the ï¬tness functions introduced pr eviously in different chance constraint settings using mul ti-
objective EAs on different benchmarks; and we use multiple e xperiments for that. Here we present the experimental
settings and the results of these experiments.
8 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINTTable 1: Results for same dispersion using Chebyshevâ€™s ineq uality
BÎ±Î´GSEMO with g(x) (1) GSEMO+Filtering with g(x) (2) NSGA-II with g(x) (3) NSGA-II with gâ€²(x) (4) NSGA-II with gâ€²â€²(x) (5)
mean std stat mean std stat mean std stat mean std stat mean std statuncorr-100
24070.12511029.6826 76.3191 2âˆ’5+11085.6072 0.00001+3+4+5+11007.6251 88.8419 2âˆ’10998.7574 50.6310 2âˆ’11007.7624 52.5740 1âˆ’2âˆ’
5010862.4750 61.4080 2âˆ’5+10907.0000 0.00001+3+4+5+10837.2841 53.1386 2âˆ’10811.4832 80.3604 2âˆ’10832.9581 50.1309 1âˆ’2âˆ’
0.012510620.5264 71.0446 2âˆ’5+10672.3379 0.00001+3+4+5+10602.1969 81.4896 2âˆ’10594.9482 45.5447 2âˆ’10602.8065 46.9209 1âˆ’2âˆ’
5010044.4941 49.7668 2âˆ’5+10079.9649 0.00001+3+4+5+10025.8881 41.6418 2âˆ’10004.2550 67.4364 2âˆ’10023.0463 38.8802 1âˆ’2âˆ’
0.00125 9345.9245 55.2560 2âˆ’5+9384.5150 0.00001+3+4+5+9338.8078 59.0630 2âˆ’5+9336.6045 30.1889 2âˆ’9340.8894 29.5604 1âˆ’2âˆ’3âˆ’
50 7495.5153 17.9630 2âˆ’5+7502.7716 0.00001+3+4+5+7498.7722 13.1282 2âˆ’5+7488.8368 31.6085 2âˆ’7499.2121 9.5267 1âˆ’2âˆ’3âˆ’strong-100
41870.125 8507.0584 130.1420 2âˆ’8606.3413 87.2952 1+3+4+5+8525.5561 125.6131 2âˆ’8500.0805 149.4958 2âˆ’8499.3632 124.5506 2âˆ’
50 8368.0306 94.0118 2âˆ’8422.6322 67.2273 1+3+5+8326.9385 114.3897 2âˆ’8364.0549 124.7364 8319.3263 115.3753 2âˆ’
0.0125 8083.9678 106.1983 2âˆ’8170.3360 69.5792 1+4+5+8102.4388 104.2026 8082.3479 124.2002 2âˆ’8082.2853 103.3765 2âˆ’
50 7502.9361 59.8544 2âˆ’7549.4937 41.2749 1+3+5+7489.7223 73.5765 2âˆ’7513.5174 78.6964 7485.1707 73.8490 2âˆ’
0.00125 6770.3193 41.1347 2âˆ’6814.1197 20.7669 1+4+5+6787.5739 42.8885 6782.2797 48.8989 2âˆ’6784.1694 42.0052 2âˆ’
50 4957.5449 36.7770 2+3âˆ’4âˆ’4894.0039 60.2107 1âˆ’3âˆ’4âˆ’5âˆ’4990.7637 17.9608 1+2+5+4989.4145 13.2248 1+2+5+4991.4701 11.0454 2+3âˆ’4âˆ’uncorr-300
68530.12533935.4067 205.6247 2âˆ’34286.1802 147.5309 1+3+4+5+33681.6883 534.3217 2âˆ’33671.7620 555.4450 2âˆ’33615.8492 489.0223 2âˆ’
5033571.9980 260.8593 2âˆ’33967.3813 159.2433 1+3+4+5+33418.4882 512.5693 2âˆ’33284.5989 450.6255 2âˆ’33319.4651 483.5459 2âˆ’
0.012533237.8865 200.4641 2âˆ’33577.9421 141.7536 1+3+4+5+32992.6756 521.4969 2âˆ’32984.2543 541.8390 2âˆ’32929.2384 476.3437 2âˆ’
5032180.0106 245.8773 2âˆ’32551.5342 144.8963 1+3+4+5+32039.6829 487.7705 2âˆ’31913.5405 429.4896 2âˆ’31946.2435 458.2449 2âˆ’
0.0012531066.6084 186.3571 2âˆ’31372.5619 122.8614 1+3+4+5+30846.1243 482.1829 2âˆ’30841.9917 499.6822 2âˆ’30789.6329 437.0386 2âˆ’
5027843.2948 203.7335 2âˆ’28141.7188 105.9385 1+3+4+5+27745.1612 411.5637 2âˆ’27641.0702 364.7302 2âˆ’27668.0494 380.2576 2âˆ’strong-300
138210.12523809.6581 433.2506 2âˆ’3âˆ’5âˆ’24369.6211 216.9574 1+3+4+24099.5570 327.0870 1+2âˆ’23986.4018 344.2409 2âˆ’24176.0891 232.7994 1+
5023594.2993 335.6481 2âˆ’3âˆ’5âˆ’24135.2769 220.4491 1+3+4+5+23867.9086 293.6342 1+2âˆ’23695.2127 304.2994 2âˆ’23899.3116 223.8869 1+2âˆ’
0.012523176.9548 406.2664 2âˆ’3âˆ’5âˆ’23703.0401 197.3436 1+3+4+23464.5667 299.1984 1+2âˆ’23360.1013 318.6357 2âˆ’23534.8995 212.1891 1+
5022322.7651 282.0126 2âˆ’3âˆ’5âˆ’22797.4912 177.4246 1+3+4+5+22588.5433 240.6771 1+2âˆ’22446.1950 255.5942 2âˆ’22616.9323 182.9564 1+2âˆ’
0.0012521208.9163 322.7908 2âˆ’3âˆ’5âˆ’21626.7053 138.6421 1+4+21486.9475 214.2326 1+21411.6675 240.6127 2âˆ’21536.8345 149.2069 1+
5018388.5805 159.4458 2âˆ’3âˆ’4âˆ’5âˆ’18647.0894 70.1852 1+4+18623.6627 98.1567 1+18569.9473 110.1685 1+2âˆ’18638.7270 63.3870 1+uncorr-500
112430.12557076.8361 748.9305 2âˆ’3+4+58431.4168 311.5788 1+3+4+5+55850.4588 1249.6235 1âˆ’2âˆ’55869.0104 1408.3737 1âˆ’2âˆ’56037.4884 1287.2936 2âˆ’
5056690.8982 859.2445 2âˆ’3+4+5+58120.8249 314.3063 1+3+4+5+55563.0878 1044.9051 1âˆ’2âˆ’54981.1206 1223.7431 1âˆ’2âˆ’55667.0434 1278.2837 1âˆ’2âˆ’
0.012556197.0249 738.3354 2âˆ’3+4+57528.4355 304.4306 1+3+4+5+54995.4516 1230.9769 1âˆ’2âˆ’55013.2733 1387.3025 1âˆ’2âˆ’55179.3063 1266.4267 2âˆ’
5054931.1821 829.5866 2âˆ’3+4+5+56312.8274 298.8610 1+3+4+5+53851.9927 1009.2563 1âˆ’2âˆ’53287.7928 1187.2402 1âˆ’2âˆ’53950.6793 1236.5882 1âˆ’2âˆ’
0.0012553456.0312 705.5039 2âˆ’3+4+54715.2628 282.5314 1+3+4+5+52331.0919 1172.9610 1âˆ’2âˆ’52346.6392 1321.7096 1âˆ’2âˆ’52505.0533 1201.5375 2âˆ’ 0.0012553456.0312 705.5039 2âˆ’3+4+54715.2628 282.5314 1+3+4+5+52331.0919 1172.9610 1âˆ’2âˆ’52346.6392 1321.7096 1âˆ’2âˆ’52505.0533 1201.5375 2âˆ’
5049451.2762 737.5644 2âˆ’3+4+50683.8705 252.3483 1+3+4+5+48521.4630 900.6466 1âˆ’2âˆ’48012.1505 1072.2455 1âˆ’2âˆ’48602.1733 1107.2660 2âˆ’strong-500
222230.12538822.1695 692.1198 2âˆ’3âˆ’4âˆ’5âˆ’40391.0362 449.8195 1+3+4+5+39792.1607 415.5621 1+2âˆ’39754.0904 424.9780 1+2âˆ’39769.7011 392.0549 1+2âˆ’
5038444.0651 620.4975 2âˆ’3âˆ’4âˆ’5âˆ’40078.0983 348.7030 1+3+4+5+39442.9758 605.5909 1+2âˆ’39485.7055 483.2892 1+2âˆ’39416.6356 382.3801 1+2âˆ’
0.012538026.4154 657.3621 2âˆ’3âˆ’4âˆ’5âˆ’39525.2027 425.9579 1+3+4+5+38973.8435 390.8087 1+2âˆ’38936.9771 399.8035 1+2âˆ’38951.8432 369.6260 1+2âˆ’
5036864.1232 555.3952 2âˆ’3âˆ’4âˆ’5âˆ’38332.2087 312.3534 1+3+4+5+37800.5870 535.4997 1+2âˆ’37839.6026 424.3667 1+2âˆ’37781.3920 337.2743 1+2âˆ’
0.0012535546.6995 551.6446 2âˆ’3âˆ’4âˆ’5âˆ’36827.5418 352.7810 1+3+4+5+36424.1740 315.3111 1+2âˆ’36391.1536 322.1788 1+2âˆ’36404.2919 299.3640 1+2âˆ’
5031947.2385 360.7027 2âˆ’3âˆ’4âˆ’5âˆ’32899.2694 206.7434 1+32685.3625 321.9032 1+32727.4059 242.3192 1+32688.8779 201.6241 1+
9 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
6.1 Experimental Setup
For experimental investigations, we use the same benchmark s as the ones that are used in Neumann et al. (2022).
The set of benchmarks includes three correlated instances a nd three bounded strongly correlated instances with the
numbers of knapsack items nâˆˆ{100,300,500}. We consider that the proï¬ts of the knapsack items have a unif orm
distribution, such that the proï¬t of element iis chosen uniformly at random as piâˆˆ{Âµiâˆ’Î´,Âµi+Î´}. This allows to
use bothË†pCheb andË†pHoef when the proï¬ts have the same uncertainty level ( Î´). The experimental investigation covers
two uncertainty levels for each benchmark, Î´âˆˆ{25,50}. Additionally, we consider the scenario where the proï¬ts
have different dispersion such that each item ihas an uncertainty level Î´i, which is chosen uniformly at random as
Î´iâˆˆ[0.0,Âµi]. The benchmarks with different uncertainties are consider ed only with Ë†pCheb sinceË†pHoef requires the
same uncertainty level for all elements.
This study mainly considers three algorithms: two well-kno wn multi-objective evolutionary algorithms GSEMO and
NSGA-II and the third is GSEMO with the ï¬ltering method intro duced in Section 4. The latter is referred to as
GSEMO+Filtering hereafter in this paper. These algorithms are combined with ï¬tness functions as appropriate, to
use in the experiments. For the benchmarks with ï¬xed uncerta inties, using GSEMO or GSEMO+Filtering with any
ï¬tness function ( g(x)orgâ€²(x)orgâ€²â€²(x)) will produce equivalent results as the ï¬nal populations. T herefore, GSEMO
and GSEMO+Filtering are only considered with the ï¬tness eva luationg(x). The ï¬tness function gâ€²â€²(x)considers the
number of items selected in the solution for the scenario whe re proï¬ts have the same dispersion. Therefore, we do
not consider algorithms with that ï¬tness function for the be nchmarks with different uncertainties for proï¬ts. Only
GSEMO and GSEMO+Filtering with g(x), and NSGA-II with g(x)andgâ€²(x)are considered for those benchmarks.
Every algorithm considers the 10 million ï¬tness evaluation and produces a population of solutions that gives a trade-
off concerning the objectives used for ï¬tness evaluation. T he quality of the output of these methods is evaluated
by analyzing the best proï¬t value for different conï¬dence le vels considering Î±âˆˆ{0.1,0.01,0.001}. Each method
generates a ï¬nal population independent of Î±, and we select the best solution from that population for dif ferentÎ±
values using proï¬t estimations Ë†pCheb orË†pHoef as applicable. The results summarise the best proï¬t value gi ven by 30
experimental results for each Î±. This summary requires running the method 30 times for each Î´for benchmarks with
the same proï¬t dispersion and 30 times for benchmarks with di fferent proï¬t dispersion. However, when using gâ€²â€²(x),
as algorithms run independent of Î´value, it is possible to get the best proï¬t values for differe ntÎ´from the same ï¬nal
population.
Finally, we test for the statistical signiï¬cance validity o f the results using the Kruskal-Wallis test with 95% conï¬den ce
with the Bonferroni post-hoc statistical procedure. The st atistical comparison is indicated as X+orXâˆ’to indicate that
the method in the column outperforms Xor vice versa. If there is no signiï¬cant difference between t he two methods,
respective numbers do not appear. For each method, the summa ry of the best proï¬t values is given as mean, std and
stat, which represent the mean and standard deviation of the results and statistical comparison with the corresponding
results from other methods, respectively.
6.2 Results
Table 1 and 2 present the results for the benchmarks with ï¬xed uncertainty levels proï¬ts of elements. According to the
mean values GSEMO with the ï¬ltering method outperforms othe r methods in most of the settings in both tables. The mean values GSEMO with the ï¬ltering method outperforms othe r methods in most of the settings in both tables. The
statistical comparisons give more insights into the perfor mance of the methods when applied to each instance. Results
for uncorr-100 in Table 1 show that GSEMO+Filtering perform s the better than other four methods, and GSEMO
performs better than NSGA-II with gâ€²â€²(x). For smaller conï¬dence levels Î±= 0.001, NSGA-II with g(x)outperforms
that withgâ€²â€²(x). Strong-100 instance gets very different results for Î±= 0.001andÎ´= 50 , than other cases of the same
instance. There, GSEMO with g(x)and NSGA-II with g(x)andgâ€²(x)perform well and GSEMO+Filtering gives the
lowest result. However, the second method performs well in o therÎ±andÎ´settings and NSGA-II with g(x)andgâ€²(x)
also perform similarly in certain settings.
For all settings of uncorr-300, GSEMO+Filtering outperfor ms the other four methods while performing similarly to
each other. For strong-300 instance, GSEMO gives lower resu lts than GSEMO+Filtering and NSGA-II with g(x)
andgâ€²â€²(x). Also, NSGA-II with g(x)produces results as good as GSEMO+Filtering for Î±= 0.001. For uncorr-
500, GSEMO+Filtering gives the best results and GSEMO outpe rforms most of the NSGA-II results. However,
when using gâ€²â€²(x)with NSGA-II on this instance, results show equal performan ce except for Î±={0.1,0.01}con-
ï¬dence levels when considering uncertainty level Î´= 50 . Experiments on strong-500 also get the best results from
GSEMO+Filtering. However, GSEMO is outperformed by other m ethods for all settings considered for this instance.
In comparison, the NSGA-II gives the second best results acr oss settings when Î´= 50 andÎ±= 0.001NSGA-II
methods also perform as well as GSEMO+Filtering.
10 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
Table 2: Results for same dispersion using Hoeffding bound
BÎ±Î´GSEMO with g(x) (1) GSEMO+Filtering with g(x) (2) NSGA-II with g(x) (3) NSGA-II with gâ€²(x) (4) NSGA-II with gâ€²â€²(x) (5)
mean std stat mean std stat mean std stat mean std stat mean std statuncorr-100
24070.12510987.3004 75.7683 2âˆ’11042.7989 0.00001+3+4+5+10965.6291 88.0780 2âˆ’10956.9290 50.1020 2âˆ’10965.9887 51.9898 2âˆ’
5010778.0078 60.1974 2âˆ’10821.5978 0.00001+3+4+5+10753.4968 51.9386 2âˆ’10728.1263 79.0134 2âˆ’10749.4108 48.9647 2âˆ’
0.012510896.5878 74.5928 2âˆ’10951.1744 0.00001+3+4+5+10875.7430 86.4446 2âˆ’10867.4019 48.9713 2âˆ’10876.2792 50.7360 2âˆ’
5010596.7649 57.6057 2âˆ’10638.3488 0.00001+3+4+5+10573.7130 49.3723 2âˆ’10549.2659 76.1316 2âˆ’10569.9917 46.4640 2âˆ’
0.0012510826.9815 73.6938 2âˆ’10880.8684 0.00001+3+4+5+10806.7709 85.1930 2âˆ’10798.7053 48.1051 2âˆ’10807.4426 49.7746 2âˆ’
5010457.6924 55.6226 2âˆ’10497.7369 0.00001+3+4+5+10435.7601 47.4116 2âˆ’10412.0216 73.9290 2âˆ’10432.3187 44.5489 2âˆ’strong-100
41870.125 8463.1467 127.6172 2âˆ’8561.1573 85.4504 1+3+4+5+8481.7278 123.3848 2âˆ’8456.8099 146.8670 2âˆ’8456.3390 122.3538 2âˆ’
50 8278.6327 90.2553 2âˆ’8332.4692 64.4783 1+3+5+8240.4850 110.0787 2âˆ’8276.2257 119.9424 8233.2780 111.0076 2âˆ’
0.0125 8369.3409 122.2698 2âˆ’8464.4621 81.5096 1+3+4+5+8387.9199 118.6225 2âˆ’8364.1958 141.2465 2âˆ’8363.9441 117.6448 2âˆ’
50 8086.8101 82.3211 2âˆ’8139.0049 58.6173 1+3+5+8054.9801 100.8829 2âˆ’8087.7692 109.6779 8048.4883 101.6750 2âˆ’
0.00125 8297.3868 118.1961 2âˆ’8390.2653 78.4972 1+3+4+5+8315.9386 114.9756 2âˆ’8293.1306 136.9396 2âˆ’8293.0470 114.0400 2âˆ’
50 7939.6195 76.3766 2âˆ’7990.5545 54.1630 1+3+5+7912.6372 93.8879 2âˆ’7943.1615 101.8268 7906.6941 94.5672 2âˆ’uncorr-300
68530.12533863.1544 205.0835 2âˆ’34212.8177 146.9244 1+3+4+5+33610.2955 532.9802 2âˆ’33600.5469 554.0346 2âˆ’33545.0211 487.7131 2âˆ’
5033428.2570 259.2905 2âˆ’33821.1723 157.7349 1+3+4+5+33276.1084 510.0035 2âˆ’33143.0191 448.4365 2âˆ’33177.8089 480.9303 2âˆ’
0.012533708.5096 203.9304 2âˆ’34055.7967 145.6324 1+3+4+5+33457.5385 530.1364 2âˆ’33448.1219 551.0166 2âˆ’33392.9168 484.9026 2âˆ’
5033119.8295 255.9406 2âˆ’33507.4493 154.5170 1+3+4+5+32970.6017 504.5017 2âˆ’32839.2289 443.7443 2âˆ’32873.6003 475.3176 2âˆ’
0.0012533589.8465 203.0502 2âˆ’33935.3102 144.6467 1+3+4+5+33340.3278 527.9571 2âˆ’33331.1621 548.7016 2âˆ’33276.2031 482.7469 2âˆ’
5032883.1649 253.3855 2âˆ’33266.7212 152.0660 1+3+4+5+32736.1783 500.2836 2âˆ’32606.1226 440.1485 2âˆ’32640.1729 471.0147 2âˆ’strong-300
138210.12523744.0892 430.4747 2âˆ’3âˆ’5âˆ’24300.5479 214.9589 1+3+4+24033.7421 324.1660 1+2âˆ’23921.4833 341.5510 2âˆ’24109.9465 230.6676 1+
5023462.9510 329.9513 2âˆ’3âˆ’5âˆ’23997.1125 215.9394 1+3+4+5+23735.7246 288.1238 1+2âˆ’23566.2352 299.2535 2âˆ’23767.0263 219.6354 1+2âˆ’
0.012523603.7492 424.5461 2âˆ’3âˆ’5âˆ’24152.7138 210.6726 1+3+4+23892.9269 317.9729 1+2âˆ’23782.5354 335.8005 2âˆ’23967.9043 226.0936 1+
5023181.2241 317.9412 2âˆ’3âˆ’5âˆ’23700.6927 206.3054 1+3+4+5+23452.1877 276.3622 1+2âˆ’23289.4860 288.4378 2âˆ’23482.9419 210.5250 1+2âˆ’
0.0012523496.0973 420.0184 2âˆ’3âˆ’5âˆ’24039.3181 207.2892 1+3+4+23784.9190 313.2317 1+2âˆ’23675.9269 331.3992 2âˆ’23858.9115 222.5879 1+
5022965.0474 308.7926 2âˆ’3âˆ’5âˆ’23473.2418 198.9571 1+3+4+5+23234.6394 267.3758 1+2âˆ’23077.1290 280.1499 2âˆ’23264.9563 203.5545 1+2âˆ’uncorr-500
112430.12556985.6975 747.8288 2âˆ’3+4+58337.8820 310.8352 1+3+4+5+55761.8933 1247.6913 1âˆ’2âˆ’55780.3693 1406.1906 1âˆ’2âˆ’55948.9616 1285.1401 2âˆ’
5056509.1689 856.1817 2âˆ’3+4+5+57934.0703 312.7435 1+3+4+5+55386.3718 1041.2515 1âˆ’2âˆ’54806.2623 1219.9708 1âˆ’2âˆ’55489.9899 1273.9787 1âˆ’2âˆ’
0.012556790.6294 745.4714 2âˆ’3+4+58137.6851 309.2459 1+3+4+5+55572.3326 1243.5564 1âˆ’2âˆ’55590.6468 1401.5183 1âˆ’2âˆ’55758.8493 1280.5162 2âˆ’
5056119.2292 849.6132 2âˆ’3+4+5+57533.3999 309.3150 1+3+4+5+55007.2442 1033.3396 1âˆ’2âˆ’54431.0658 1211.8786 1âˆ’2âˆ’55109.7653 1264.7366 1âˆ’2âˆ’
0.0012556640.9485 743.6632 2âˆ’3+4+57984.0686 308.0287 1+3+4+5+55426.8776 1240.3841 1âˆ’2âˆ’55445.0676 1397.9335 1âˆ’2âˆ’55612.9710 1276.9688 2âˆ’ 0.0012556640.9485 743.6632 2âˆ’3+4+57984.0686 308.0287 1+3+4+5+55426.8776 1240.3841 1âˆ’2âˆ’55445.0676 1397.9335 1âˆ’2âˆ’55612.9710 1276.9688 2âˆ’
5055820.0179 844.5763 2âˆ’3+4+5+57226.0199 306.6676 1+3+4+5+54716.3294 1027.2713 1âˆ’2âˆ’54143.1674 1205.6714 1âˆ’2âˆ’54818.0086 1257.6477 1âˆ’2âˆ’strong-500
222230.12538739.7417 688.5044 2âˆ’3âˆ’4âˆ’5âˆ’40301.3374 447.3446 1+3+4+5+39707.3872 412.9829 1+2âˆ’39669.4439 422.3664 1+2âˆ’39685.3277 389.7418 1+2âˆ’
5038280.9153 613.7020 2âˆ’3âˆ’4âˆ’5âˆ’39897.8123 344.8981 1+3+4+5+39273.3775 598.3347 1+2âˆ’39315.7031 477.1865 1+2âˆ’39247.8886 377.7601 1+2âˆ’
0.012538563.3178 680.7776 2âˆ’3âˆ’4âˆ’5âˆ’40109.3511 442.0526 1+3+4+5+39525.9425 407.4683 1+2âˆ’39488.2712 416.7806 1+2âˆ’39504.1345 384.7767 1+2âˆ’
5037930.8422 599.1733 2âˆ’3âˆ’4âˆ’5âˆ’39510.9695 336.7709 1+3+4+5+38909.4678 582.7780 1+2âˆ’38950.9755 464.0994 1+2âˆ’38885.5815 367.8049 1+2âˆ’
0.0012538427.9430 674.8592 2âˆ’3âˆ’4âˆ’5âˆ’39962.0501 437.9920 1+3+4+5+39386.7151 403.2421 1+2âˆ’39349.2525 412.4983 1+2âˆ’39365.1001 380.9688 1+2âˆ’
5037662.2216 588.0761 2âˆ’3âˆ’4âˆ’5âˆ’39214.1346 330.5707 1+3+4+5+38630.2301 570.8539 1+2âˆ’38671.1102 454.0722 1+2âˆ’38607.6080 360.1434 1+2âˆ’
Table 3: Results for different dispersion using Chebyshevâ€™ s inequality
Instance BÎ±GSEMO with g(x) (1) GSEMO+Filtering with g(x) (2) NSGA-II with g(x) (3) NSGA-II with gâ€²(x) (4)
mean std stat mean std stat mean std stat mean std stat
uncorr-100 24070.1 8546.7015 322.7956 8562.9620 323.1475 8565.8942 324.9223 8564.2549 323.8494
0.01 4682.2710 799.1875 4675.9295 795.5029 4674.8735 797.5334 4677.1350 799.3174
0.001 1967.4965 880.0104 1962.3962 886.0726 1919.2445 917.6798 1953.6975 894.4411
strong-100 41870.1 7100.1631 245.6990 7099.8604 250.2445 7122.7698 249.2182 7123.3386 250.5080
0.01 5315.4258 326.6578 5308.5248 343.0757 5329.4856 326.9290 5333.3263 325.5847
0.001 3746.9429 732.1072 3746.1213 731.9397 3734.2093 731.9080 3743.5859 731.6689
uncorr-300 68530.1 29089.9230 479.0749 2âˆ’3âˆ’4âˆ’29580.8035 355.6388 1+29735.0392 358.7213 1+29676.9763 388.6763 1+
0.01 19396.8836 1128.3967 19431.8036 1126.0478 19589.0418 1131.0819 19580.3092 1131.0342
0.001 8910.0087 1370.4531 8850.8254 1381.8863 8899.5025 1378.4832 8971.3050 1383.6696
strong-300 138210.1 21789.9295 335.7672 2âˆ’3âˆ’4âˆ’22171.9138 358.9991 1+22345.3397 309.3574 1+22297.4300 307.0689 1+
0.01 18172.8378 560.3248 18195.2974 615.1645 18338.0359 588.6787 18342.4421 576.7652
0.001 14629.7944 809.3377 14617.5558 794.6289 14643.0814 808.6424 14667.4349 812.9751
uncorr-500 112430.1 50266.4398 709.0211 2âˆ’3âˆ’4âˆ’52494.0984 556.8082 1+52468.0194 532.9634 1+52149.3408 700.4027 1+
0.01 37753.4240 1566.1944 38510.4882 1564.4777 38746.1887 1539.8167 38686.7230 1555.8618
0.001 18969.0800 2144.1783 18880.7433 2144.3506 19153.0886 2137.5579 19190.4696 2134.7447
strong-500 222230.1 35919.5415 631.8822 2âˆ’3âˆ’4âˆ’37833.8138 352.1352 1+37832.1320 332.8651 1+37690.0363 317.8082 1+
0.01 30977.9111 679.1163 2âˆ’3âˆ’4âˆ’31554.3119 682.8664 1+31822.0362 649.7576 1+31805.6899 637.4521 1+
0.001 25041.2112 721.5121 25018.0126 704.1720 25131.2311 723.9024 25193.7178 741.8816
Table 2 gives the results from the experiments that use Ë†pCheb to estimate the proï¬t values of solutions. uncorr-100,
strong-100, and uncorr-300 results are highest when using G SEMO+Filtering. It outperforms all the other methods
except NSGA-II with gâ€²(x)on strong-100 instance for uncertainty level Î´= 50 . Experiments on strong-300 instance
show that NSGA-II with gâ€²â€²(x)performs equally as the GSEMO+Filtering when considering a lower uncertainty level
(25) for the knapsack items. GSEMO and NSGA-II with gâ€²(x)methods give the lowest results for this instance. On the
contrary, GSEMO performs better than most NSGA-II methods f or uncorr-500. When using gâ€²â€²(x), NSGA-II performs
equally as GSEMO for lower uncertainty level value 25. For al lÎ±andÎ´values, NSGA-II methods are outperformed
by GSEMO+Filtering in the experiments on strong-500 in Tabl e 2. However, NSGA-II methods perform better than
GSEMO on that benchmark.
11 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
GSEMO+Filtering performs signiï¬cantly well when applied t o benchmarks with the same dispersion for proï¬ts. The
ï¬ltering method allows the interim populations to contain m ore solutions that yield a valid conï¬dence level interval.
Therefore, improving upon these solutions eventually give s better results in the ï¬nal outcome. Considering NSGA-II
results,g(x)andgâ€²(x)tends to produce better results than gâ€²â€²(x). This can be due to the fact the crowding distance
assignment is better when considering the variance or the st andard deviation of solutionsâ€™ proï¬ts.
We can compare the results for benchmarks with the same dispe rsion for proï¬ts (given in Table 1 and 2) with the
previous work in Neumann et al. (2022) as it also considers th e same benchmarks and similar experimental setup. The
experimental settings are the same in both works except for t he number of ï¬tness evaluations the algorithms consider.
For each Î±andÎ´value, methods in Neumann et al. (2022) run for one million ï¬t ness evaluations. On the contrary,
we run the multi-objective methods on benchmarks for each Î´value for 10 million ï¬tness evaluations which yield
results for all Î±values from the same algorithm output. The results show that for Chebyshev results 14 out of the
36 settings, the highest mean proï¬t values given in Table 1 ou tperform all the three methods used in Neumann et al.
(2022) and for Hoeffding results in 15 out of the 36 settings g ets better proï¬ts according to Table 2. Generally, most
of these cases are from experiments on uncorrelated benchma rks. For the cases where the new methods perform better
on bounded strongly correlated instances, it is for higher u ncertainty level Î´= 50 and lower conï¬dence values like
Î±={0.01,0.01}.
Table 3 presents results for benchmarks with different disp ersion for proï¬ts of elements. The highest mean values
reported for each case show, for smaller instances, GSEMO an d NSGA-II give the highest mean proï¬ts, and for in-
stances with 300 or 500 elements, GSEMO+Filtering with gâ€²(x)and NSGA-II give the highest mean proï¬t. Although
the highest mean values can be identiï¬ed from different meth ods, the results are similar in most of the settings. Based
on the statistical comparisons, we can see that smaller inst ances: strong-100 and uncorr-100, do not signiï¬cantly diff er
between each methodâ€™s results. Results from other instance s show that for Î±= 0.1GSEMO+Filtering and NSGA-II
methods outperform the GSEMO. In addition, strong-500 inst ance shows better results from GSEMO+Filtering with
gâ€²(x)and NSGA-II with both ï¬tness functions for Î±= 0.01. However, in other settings with Î±={0.01,0.001}, all
methods show similar results for the instances with 300 and 5 00 items.
Compared to the benchmarks with the same dispersion for proï¬ ts, the ones with different dispersion can give higher
variance for the proï¬t of some elements. Therefore, it is cru cial to have a good spread of the solutions in the ï¬nal
population as more solutions tend to give negative proï¬t val ues when considering certain conï¬dence levels. NSGA-
II using crowding distance based sorting appears to achieve this when use with selected objectives in the ï¬tness
evaluations. In comparison, GSEMO+Filtering is also able t o achieve similarly good results by ignoring the solutions
without a valid Î±interval and eventually improving the ï¬nal population.
7 Conclusion
This paper explores multi-objective evolutionary approac hes to solve the proï¬t chance constrained KP. We introduce
ï¬tness evaluations for EAs to cater for this problem. These ï¬ tness functions can evaluate the solutions irrespective
of the required conï¬dence level of the solutions. Therefore , the outcome of EAs gives us a population that includes
solutions giving the best proï¬t value for different conï¬den ce levels. So it is unnecessary to decide on the required solutions giving the best proï¬t value for different conï¬den ce levels. So it is unnecessary to decide on the required
conï¬dence level before executing the algorithms, and no nee d to have multiple executions to investigate solutions
for different conï¬dence levels. After considering the avai lable solutions and risks associated with their proï¬ts, it i s
possible to make more informed decisions on what solutions t o implement for the problem instance. Furthermore, we
introduce a ï¬ltering method, which is applied at regular int ervals of ï¬tness evaluations. It keeps only the solutions wi th
a validÎ±interval in the interim populations, enabling the new offsp ring solutions in the next generations to improve
upon these solutions. The performance of these methods is ev ident in the experimental investigations.
Acknowledgements
This work has been supported by the Australian Research Coun cil (ARC) through grant FT200100536, and by the
South Australian Government through the Research Consorti um ""Unlocking Complex Resources through Lean Pro-
cessing"". This work was also supported with supercomputing resources provided by the Phoenix HPC service at the
University of Adelaide.
References
Yuma Abe, Masaki Ogura, Hiroyuki Tsuji, Amane Miura, and Shu ichi Adachi. 2020. Resource and Network Manage-
ment for Satellite Communications Systems: A Chance-Const rained Approach. IFAC 53 (2020), 3304â€“3309. Issue
12 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
2.
Hirad Assimi, Oscar Harper, Yue Xie, Aneta Neumann, and Fran k Neumann. 2020. Evolutionary Bi-Objective Opti-
mization for the Dynamic Chance-Constrained Knapsack Prob lem Based on Tail Bound Objectives. In ECAI 2020 ,
V ol. 325. IOS Press, 307â€“314.
C.C. Coello, D.A. Van Veldhuizen, and G.B. Lamont. 2013. Evolutionary Algorithms for Solving Multi-Objective
Problems . Springer US.
Kalyanmoy Deb. 2001. Multi-Objective Optimization using Evolutionary Algorit hms. John Wiley & Sons.
Kalyanmoy Deb, Samir Agrawal, Amrit Pratap, and T. Meyariva n. 2002. A fast and elitist multiobjective genetic
algorithm: NSGA-II. IEEE Trans. Evol. Comput. 6, 2 (2002), 182â€“197.
Benjamin Doerr. 2020. Probabilistic Tools for the Analysis of Randomized Optimiz ation Heuristics . Springer, Chap-
ter 1, 1â€“87.
Benjamin Doerr, Carola Doerr, Aneta Neumann, Frank Neumann , and Andrew M. Sutton. 2020. Optimization of
Chance-Constrained Submodular Functions. In The Thirty-Fourth AAAI Conference on Artiï¬cial Intelligen ce, AAAI
2020 . AAAI Press, 1460â€“1467.
Benjamin Doerr and Frank Neumann. 2021. A Survey on Recent Pr ogress in the Theory of Evolutionary Algorithms
for Discrete Optimization. ACM Trans. Evol. Learn. Optim. 1, 4, Article 16 (oct 2021), 43 pages.
Xinbo Geng and Le Xie. 2019. Data-driven decision making in p ower systems with probabilistic guarantees: Theory
and applications of chance-constrained optimization. Annual Reviews in Control 47 (2019), 341â€“363.
O. Giel. 2003. Expected runtimes of a simple multi-objectiv e evolutionary algorithm. In The 2003 Congress on
Evolutionary Computation, 2003. CEC â€™03. , V ol. 3. 1918â€“1925 V ol.3.
Fangguo He and Guiming Shao. 2009. An Evolutionary Algorith m for Uncertain Optimization Problems. In 2009
International Conference on Information Engineering and C omputer Science . IEEE, 1â€“4.
Konstantinos Kepaptsoglou, Grigorios Fountas, and Matthe w G. Karlaftis. 2015. Weather impact on containership
routing in closed seas. Transportation Research Part C: Emerging Technologies 55 (2015), 139â€“155.
Bo Liu, Qingfu Zhang, Francisco V . FernÃ¡ndez, and Georges G. E. Gielen. 2013. An Efï¬cient Evolutionary Algorithm
for Chance-Constrained Bi-Objective Stochastic Optimiza tion. IEEE Trans. Evol. Comput. 17, 6 (2013), 786â€“796.
Daniel H. Loughlin and S. Ranji Ranjithan. 1999. Chance-Con strained Genetic Algorithms. In GECCO â€™99 . Morgan
Kaufmann Publishers Inc., 369â€“376.
Kazuyuki Masutomi, Yuichi Nagata, , and Isao Ono. 2013. An Ev olutionary Algorithm for Black-Box Chance-
Constrained Function Optimization. Journal of Advanced Computational Intelligence and Intell igent Informatics
17, 2 (2013), 272â€“282.
Mehrnaz Mohtasham, Hossein Mirzaei-Nasirabad, and Behroo z Alizadeh. 2021. Optimization of truck-shovel alloca-
tion in open-pit mines under uncertainty: a chance-constra ined goal programming approach. Mining Technology
130 (2021), 81â€“100.
Aneta Neumann and Frank Neumann. 2020. Optimising Monotone Chance-Constrained Submodular Functions Using
Evolutionary Multi-objective Algorithms. In Parallel Problem Solving from Nature - PPSN XVI - 16th Intern ational
Conference, PPSN 2020, Proceedings, Part I (Lecture Notes i n Computer Science, Vol. 12269) . Springer, 404â€“417.
Aneta Neumann, Yue Xie, and Frank Neumann. 2022. Evolutiona ry Algorithms for Limiting the Effect of Uncertainty
for the Knapsack Problem with Stochastic Proï¬ts. In PPSN XVII . Springer, Cham, 294â€“307.
Frank Neumann, Mojgan Pourhassan, and Vahid Roostapour. 20 20.Analysis of Evolutionary Algorithms in Dynamic
and Stochastic Environments . Springer, Chapter 7, 323â€“357.
Frank Neumann and Andrew M. Sutton. 2019. Runtime Analysis o f the (1 + 1) Evolutionary Algorithm for the
Chance-Constrained Knapsack Problem. In FOGA â€™19 (FOGA â€™19) . ACM, 147â€“153.
Frank Neumann and Carsten Witt. 2022. Runtime Analysis of Si ngle- and Multi-Objective Evolutionary Algorithms Chance-Constrained Knapsack Problem. In FOGA â€™19 (FOGA â€™19) . ACM, 147â€“153.
Frank Neumann and Carsten Witt. 2022. Runtime Analysis of Si ngle- and Multi-Objective Evolutionary Algorithms
for Chance Constrained Optimization Problems with Normall y Distributed Random Variables. In IJCAI-22 . 4800â€“
4806.
Shen Peng. 2019. Chance constrained problem and its applications . Theses. UniversitÃ© Paris Saclay (COmUE) ; Xiâ€™an
Jiaotong University.
Feng Shi, Xiankun Yan, and Frank Neumann. 2022. Runtime Anal ysis of Simple Evolutionary Algorithms for the
Chance-Constrained Makespan Scheduling Problem. In PPSN XVII . Springer, 526â€“541.
13 Evolutionary Multi-Objective Algorithms for the Knapsack Problems with Stochastic Proï¬ts A P REPRINT
Hemant Kumar Singh and JÃ¼rgen Branke. 2022. Identifying Sto chastically Non-dominated Solutions Using Evolu-
tionary Computation. In PPSN (2) (Lecture Notes in Computer Science, Vol. 13399) . Springer, 193â€“206.
Yue Xie, Oscar Harper, Hirad Assimi, Aneta Neumann, and Fran k Neumann. 2019. Evolutionary Algorithms for the
Chance-Constrained Knapsack Problem. In GECCO â€™19 . ACM, 338â€“346.
Yue Xie, Aneta Neumann, and Frank Neumann. 2020. Speciï¬c Sin gle- and Multi-Objective Evolutionary Algorithms
for the Chance-Constrained Knapsack Problem. In GECCO â€™20 . ACM, 271â€“279.
Yue Xie, Aneta Neumann, and Frank Neumann. 2021a. Heuristic Strategies for Solving Complex Interacting Stockpile
Blending Problem with Chance Constraints. In GECCO â€™21 . ACM, 1079â€“1087.
Yue Xie, Aneta Neumann, Frank Neumann, and Andrew M. Sutton. 2021b. Runtime Analysis of RLS and the
(1+1) EA for the Chance-Constrained Knapsack Problem with C orrelated Uniform Weights. In GECCO â€™21 . ACM,
1187â€“1194.
14"," This paper reviews five studies on evolutionary multi-objective algorithms for knapsack problems with stochastic profits. It introduces multi-objective formulations of the problem and three bi-objective fitness evaluation methods, and evaluates them using two multi-objective evolutionary algorithms. It also introduces a filtering method to improve the quality of the final population. The effectiveness of the approaches is demonstrated on several benchmarks, showing that GSEMO+Filtering and NSGA-II methods outperform the GSEMO for most settings."
